---
eip: 3534
title: Restricted Chain Context Type Transactions
author: Isaac Ardis (@whilei)
discussions-to: https://ethereum-magicians.org/t/eip-3534-restricted-chain-context-transaction-type/6112
status: Draft
type: Standards Track
category: Core
created: 2021-04-20
requires: 2718, 2930
---

## Simple Summary

Defines a new transaction type with constraints on ancestor block hash, block author, and/or block timestamp maximum.

## Abstract

We introduce a new EIP-2718 transaction type with the format `0x4 || rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])`. 

This proposed `chainContext` element adds a constraint on the validity of a transaction to a chain segment meeting the referenced value(s). Three contexts are defined as subclasses of this type:

- `segmentId`
- `eligibleMinerList`
- `expiry`

These contexts can be used in arbitrary combinations. Annotated context value combinations are referenced by an integer prefix on the annotation.

## Motivation

Establish a protocol-based mechanism with which transactions are able to articulate constraints on eligible chain contexts.
Generally, these constraints give the consumer (the transactor) an ability to express requirements about the transaction's relationship to blockchain data and its provenance.

- Restrict transaction applicability to a chain context that is currently available and reasoned about under some subjective view.
    - Introduces a way for transactions to describe a dependency on their current view of a chain.
- Restrict transaction applicability to a chain context following some foregoing block (and its transactions).
    - Introduces a way for transactions to describe ancestral dependencies at a "macro" (block) level. 
    Indirectly, this offers a way for a transaction to depend on the presence of another, so long as the dependent transaction is in a different block.
- Restrict transaction applicability to blocks benefitting a preferred miner address or addresses.
    - Introduces an opportunity/market for miners to compete for consumers' transactions; under the status quo, the current miner-transaction processing service is almost perfectly homogenous from the consumer perspective.
- Restrict transaction applicability timespan.
    - Introduces an alternative (to the status quo) way for consumers/transactors to have transactions invalidated/ejected from the transaction pool.


## Specification

### Parameters

- `FORK_BLOCK_NUMBER` `TBD`
- `TRANSACTION_TYPE_NUMBER` `0x4`.  See EIP-2718.

As of `FORK_BLOCK_NUMBER`, a new EIP-2718 transaction is introduced with `TransactionType` `TRANSACTION_TYPE_NUMBER`.

The EIP-2718 `TransactionPayload` for this transaction is `rlp([chainId, chainContext, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS])`.


### Definitions

- `chainContext`. The transaction is only valid for blockchain data satisfying ALL OF the annotations.
- `ANNOTATION_COMPOSITE_PREFIX`. A positive integer between `1` and `0xff` that represents the set of subclass annotations in the `chainContext` (_ie._ _which_ chain context subclasses should the provided values be applied to). This value should be the sum of the subclass' `ANNOTATION_PREFIX`s.
- `ANNOTATION_PREFIX`s are defined for Subclasses as octal-derived positive integers, limited to the set `2^0,2^1,2^2,2^3,2^4,2^5,2^6,2^7`.

The `chainContext` value should be of the form `ANNOTATION_COMPOSITE_PREFIX || [{subclass value}...]`, where 
- `...` means "zero or more of the things to the left," and 
- `||` denotes the byte/byte-array concatenation operator.

### Validation

The values defined as subclasses below acts as constraints on transaction validity for specific chain contexts.
Transactions defining contraints which are not satisfied by their chain context should be rejected as invalid.
Blocks containing invalid transactions should be rejected as invalid themselves, per the _status quo_.

### Subclass Combination

`chainContext` values annotating more than one subclass reference should provide those values in the following sequential order:

1. `ANCESTOR_ID`
2. `ELIGIBLE_MINER_LIST`
3. `EXPIRY`

As above, the `ANNOTATION_COMPOSITE_PREFIX` should be the sum of the designated subclass' `ANNOTATION_PREFIX`s.
### Subclasses

- An `ANNOTATION_PREFIX` value is used to represent each of the available context subclasses.

#### `ancestorId`

- `ANNOTATION_PREFIX` `1`.
- `ANCESTOR_ID` `bytes`. A byte array between 4 and 12 bytes in length.

The `ANCESTOR_ID` is a reference to a specific block by concatenating the byte representation of a block number and the first 4 bytes of its hash. 
The block number's should be encoded as a big endian value and should have leading 0's removed.
The block number value may be omitted in case of reference to the genesis block.

The `ANCESTOR_ID` value should be RLP encoded as a byte array for hashing and transmission.

#### `eligibleMinerList`

- `ANNOTATION_PREFIX` `2`.
- `ELIGIBLE_MINER_LIST` `[address...]`. A list of addresses.
- `MAX_ELEMENTS` `10`. The maximum number of addresses that can be provided.

The `ELIGIBLE_MINER_LIST` value is an array of [address hashes](https://github.com/ethereum/yellowpaper/blob/41c1837f7b1ddcd65f135763c8e965146cd0ab70/Paper.tex#L321) referencing an exclusive set of allowed [`beneficiary`](https://github.com/ethereum/yellowpaper/blob/41c1837f7b1ddcd65f135763c8e965146cd0ab70/Paper.tex#L336) values.

The `ELIGIBLE_MINER_LIST` value should be of the type `[{20 bytes}+]`, where `+` means "one or more of the thing to the left." 
Non-unique values are not permitted.

The `ELIGIBLE_MINER_LIST` value should be RLP encoded for hashing and transmission.

#### `expiry`

- `ANNOTATION_PREFIX` `4`.
- `EXPIRY` `integer`.

The `EXPIRY` value is a scalar equal to the maximum valid [`timestamp`](https://github.com/ethereum/yellowpaper/blob/41c1837f7b1ddcd65f135763c8e965146cd0ab70/Paper.tex#L345) of a block header for a block including this transaction.

The `EXPIRY` value should be RLP encoded as an integer for hashing and transmission.

## Rationale

### Subclasses

Subclasses are defined with a high level of conceptual independence, and can be modified and/or extended independently from this EIP.
Their specification definitions allow arbitrary mutual (`AND`) combinations.

This design is intended to form a proposal which offers a concrete set of specifics while doing so with enough flexibility for extension or modification later.

#### `ANNOTATION_PREFIX`

`ANNOTATION_PREFIX` values' use of octal-derived values, ie. `1, 2, 4, 8, 16, 32, 64, 128`, follows a conventional pattern of representing combinations from a limited set uniquely and succinctly, eg. Unix-style file permissioning.
This EIP definines four of the eight possible context subclasses; this seems to leave plenty of room for future growth in this direction if required.
If this limit is met or exceeded, doing so will require a hard fork _de facto_ (by virtue of making consensus protocol facing changes to transaction validation schemes), so revising this scheme as needed should be only incidental and trivial.

#### `ancestorId`

Constrains the validity of a transaction by referencing a prior canonical block by number and hash.
The transaction is only valid when included in a block which has the annotated block as an ancestor.

Practically, the "designated allowable chain segment" can be understood as the segment of blocks from `0..ancestorId` inclusive.

This pattern can be understood as a correlate of EIP-155's `chainId` specification.
EIP155 defines the restriction of transactions between chains; limiting the applicability of any EIP-155 transaction to a chain with the annotated ChainID. 
`ancestorId` further restricts transaction application to one subsection ("segment") of one chain.

From this constraint hierarchy, we note that it is possible an implementation of `ancestorId` to make `chainId` redundant.

##### Construction

The value is generally constructed as a concatenated `BlockNumber``BlockHashPrefix`, where `BlockHashPrefix` is __the first 4 bytes of the block hash of the canonical block with number `BlockNumber`__.

If the referenced `BlockNumber` is `0` it may be omitted. Otherwise, `BlockNumber` should be a __little endian encoded value with trailing zero values truncated__.
This scheme yields a minimum of 0 bytes and a maximum of 8 bytes (uint64).

Decoding can be done by chomping the last 4 bytes of the value as the required prefix of a block hash.
The remaining bytes (those preceeding the last 4 bytes, if any) can be decoded from a little endian into a uint64 or equivalent type.
In case of 0 bytes for the block number, 0 (genesis block) can be safely assumed.

Example values are given below.

#### `eligibleMinerList`

Constrains the validity of a transaction by a chain context subclass referencing the .
The transaction is only valid when included in a block having an `etherbase` contained in annotated list of addresses.

#### `expiry`

Constrains the validity of a transaction by a chain context subclass referencing the timestamp of the block including the transaction (in seconds-since Unix epoch).
The transaction is only valid when included in a block having a `timestamp` less than the value annotated.

### Subclass Combination

Since subclasses use octal-based values for `ANNOTATION_PREFIX`, they can be distinguishably combined as long as we assume annotation cardinality (ie ordering).

For example:

- `ANNOTATION_PREFIX` `1` signals `ancestorId` exclusively. 
- `ANNOTATION_PREFIX` `2` signals `eligibleMinerList` exclusively. 
- `ANNOTATION_PREFIX` `3` combines `ancestorId` and `eligibleMinerList`.
- `ANNOTATION_PREFIX` `4` signals `expiry` exclusively.
- `ANNOTATION_PREFIX` `5` combines `ancestorId` and `expiry`. 
- `ANNOTATION_PREFIX` `6` combines `eligibleMinerList` and `expiry`. 
- `ANNOTATION_PREFIX` `7` combines `ancestorId` and `eligibleMinerList` and `expiry`. 


Annotation values are provided in an array.

For example:

- `chainContext` `1[e4e1c0e78b1ec3]` Transaction can only be included in a block having a canonical ancestor block numbered `15_000_000` and with a hash prefixed with the bytes `e78b1ec3`.
- `chainContext` `2[[Df7D7e053933b5cC24372f878c90E62dADAD5d42]]` Transaction can only be included in a block naming `Df7D7e053933b5cC24372f878c90E62dADAD5d42` as the `etherbase` beneficiary.
- `chainContext` `3[1619008030]` Transaction can only be included in a block having a timestamp with value less than the time signaled by the Unix-epoch value `1619008030` (generally, the transaction expires after Wed Apr 21 07:27:10 CDT 2021).



### EIP2930 Base
The _EIP-2930 Optional Access List Type Transaction_ is used as an assumed "base" transaction type for this proposal. 
However, this is NOT a conceptual dependency; the included `accessList` portion of this proposal (the only differential from post-EIP-155 legacy transaction fields) can readily be removed. 
Standing on the shoulders of EIP2930 is only intended to support and further the adoption of next-generation transactions.

## Backwards Compatibility

This EIP requires a hard fork.

## Test Cases

| Segment ID | Block Number | Canonical Block Hash |
| --- | --- | --- |
| `e78b1ec3` | `0` | `0xe78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58` |
| `01e78b1ec3` | `1` | `0xe78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58` |
| `e4e1c0e78b1ec3` | `15_000_000` | `0xe78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58` |
| `e8d4a50fffe78b1ec3` | `999_999_999_999` | `0xe78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58` |
| `7fffffffffffffffe78b1ec3` | `9223372036854775807` | `0xe78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58` |


## Security Considerations

#### Why 4 bytes of a block hash is "safe enough" for the `ancestorId`

Four bytes, instead of the whole hash (32 bytes), was chosen only to reduce the amount of information required to cross the wire to implement this value.
Using the whole hash would result in a "perfectly safe" implementation.

The goal of the `ancestorId` is to disambiguate one chain segment from another, and in doing so, enable a transaction to define with adequate precision which chain it needs to be on.
When a transaction's `ancestorId` references a block, we want to be pretty sure that that reference won't get confused with a different block than the one the author of the transaction had in mind.

Block hashes are effectively unique (at least ethereum/go-ethereum assumes so in their database schema), and are [cited as approximations for random numbers in the yellow paper](https://github.com/ethereum/yellowpaper/blob/41c1837f7b1ddcd65f135763c8e965146cd0ab70/Paper.tex#L1261).
We assume this trait is uniformly applicable to all possible subsets of the hash value; that is: whether the whole hash, in the first 4 bytes, the first 14, the middle 8, or the last 30; any piece is as random as any other piece. 

- `e78b1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58`. Whole hash, random.
- `e78b1ec3`. First 4 bytes, random.
- `e78b1ec31bcb535548ce4b6ef384`. First 14 bytes, random.
- `384deccad1e7dc59`. Middle 8 bytes, random.
- `1ec31bcb535548ce4b6ef384deccad1e7dc599817b65ab5124eeaaee3e58`. Last 30 bytes, random.

So our preference of using the _first_ 4 bytes is arbitrary and functionally equivalent to any other subset of equal length.

For the sake of legibility and accessibility, the following arguments will reference the hex representation of 4 bytes, which is 8 characters in length, eg. `e78b1ec3`. 

The chance of a colliding `ancestorId` is:

- The chance of "rolling" any one of all possible 4-byte prefixes: `1/(16^8=4_294_967_296)`. One snowflake of a possible 4 billion.
- ... times itself (like rolling two simultaneous 6's in Yahtzee :registered:), because the hash collision needs to happen with the same block number (simultaneity): `1/(16^8=4_294_967_296) * 1/(16^8=4_294_967_296)`. Two equivalent snowflakes (of a possible 4 billion) landing right next to each other at the same time.
- ... times a ballpark chance of 10% (`1/10`) for any given block having a public uncle: `(1/(16^8=4_294_967_296) * 1/(16^8=4_294_967_296)) * 1/10`. The probability of the existence of a second snowflake. Note that this assumes "normal" chain and network behavior. In the case of an enduring competing chain segment, this value rises to 100% (`1`).

![Untitled drawing(2)](https://user-images.githubusercontent.com/45600330/116568752-5ce25c00-a8ce-11eb-9911-2e34e6364c29.png)

Yields: `5.42101e-21` (or `5.42101e-19`).

__TL;DR__: The chance of an ineffectual `ancestorId` is 1 in 4 billion squared times ~10 (or times 1 for intentional duplication scenarios, eg. malicious reorgs).

__If a collision _does_ happen__, that means the transaction will be valid on both segments (as is the case under the status quo).

## Copyright

Copyright and related rights waved via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
