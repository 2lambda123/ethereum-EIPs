---
eip: 62xx
title: Extreme ERC-20
author: Sam Porter (@SamPorter1984)
discussions-to: https://ethereum-magicians.org/
type: Standards Track
status: Draft
category: ERC
created: 2022-12-26
requires: 20
---

## Simple Summary

The underlying token standard is designed to facilitate meta-transactions of any type to accelerate blockchain adoption, particularly optimistic and zero-knowledge roll-ups. This standard proposes a solution in which meta-transaction fees are deducted directly from the user' token transfer amount, no liquidity for keeper incentives required.

While some of the proposed approaches in this EIP may seem extreme, they are ultimately just a way to minimize trust and to make the approach cost-efficient, concise and extensible.

## Abstract

Thanks to the relevant EIPs that came before it, suitable security measures can be taken to protect public signatures and to enable meta-transaction era. This token standard is a step towards establishing a new economy of smart contract automation, where users and keepers interact with each other in a mutually beneficial loop.
This EIP is based on the assumptions:

- That meta-transaction signatures need to be public in order for blockchain adoption to grow. The EIP assumes that token dApps will feature a public pool of signatures similar to Coinbase or Etherscan, which will resemble regular Ethereum transactions but with reduced user friction. In the spirit of decentralization, it enables anybody to be a keeper/relayer and collect fees directly from user transfer amounts. Additionally, users can tip the keeper on top of the gas cost.
- Meta-transactions must become standard procedure when interacting with smart contracts. Modern Ethereum wallets are too complex. All of them must have lite modes/versions. Probably the best off-chain solution to handle meta-transactions is something like only-sign Metamask Lite which forces the user to always use a new signer key when interacting with a dApp on a new domain, remembers dApp profiles and switches them automatically.
- Gas efficiency is in no way less important when it comes to optimistic and zero knowledge roll-ups. If anything, lower network fees enable more automation, which is about to become essential in such a hyper-competitive industry.
- Full automation is too costly for project funding. Therefore, meta-transactions fees should be deducted directly from the transfer amount.

An example:
Alice has never had a wallet before but is eligible for an airdrop on Arbitrum. All she needs to do is install a wallet, sign the data, and then she has airdrop tokens minus the keeper fee. She does not have to make any transactions or possess any ETH. She is not limited in any way more than Bob, who is transacting on his own. Alice can vote, stake, claim rewards, trade on Uniswap. In fact, she can do more than Bob, such as subscribing to staking rewards to get them automatically every month, a part of these rewards then automatically sent to pay her bills and support her favorite content creators.

## Motivation

To solve the issues with existing keeper/relayer solutions today:

- Conservative approaches massively limit the functionality, resulting in a lack of significant impact and usage. This EIP tries to acknowledge and embrace the “wild west” of DeFi without introducing more rules than are absolutely necessary.
- All these solutions rely on funding/supporting a relayer/keeper network, which makes innovation more dependent on external funding, centralizes ability to innovate. Small projects will see their chances of success drop in next-level fully automated DeFi, in which they will need to raise liquidity not only for AMM, but also for meta-transaction relayers. Conversely, this highly experimental EIP attempts to enable DeFi experimental wilderness, and to give an edge to high risk high reward smaller projects.

## Specification

For subscriptions replayability is desirable, therefore barebones specification gets rid of nonces and instead uses `salt`. EIP-62xx salt mimicks nonce until it doesn't. In addition to that, users can re-enable any previously disabled signatures, provided that the deadline of a given signature allows.

Signatories can create executable signatures for transactions of any kind. As long as signatory token balance is above minimum gas cost of a transaction at hand, it is executable and keeper fee is subtracted from balance.

If the signatory wishes to execute a trade that returns a different token from `address(this)`, the returned funds are split between the signatory and the keeper, with the amount being converted to ETH through an on-chain oracle such as Uniswap (which is admittably a bit extreme, depending on the case, but a mature enough solution in case of DeFi as of today). The same flow applies for ETH as the returned token, minus the oracle conversion.

When the returned tokens are different from `address(this)`, the destination MUST be the core token contract from which the keepers operate in order to divide the funds between the signer and the keeper. The barebones specification cannot provide a reliable safety check against malicious signatures of this kind, so the keepers MUST verify that the transaction details are secure before agreeing to carry out the transaction.

Additional options for transactions should be provided to claim staking rewards or an airdrop with the signature even with both ETH and `address(this)` balances at 0, so that the user can start interacting with for example Optimism with fresh new wallet installed and nothing but a record of an airdrop in the contract. To enable this functionality on a larger scale, functions outside the core token contract which are intended to transfer tokens to the user never actually do so. Instead, to allow the injection of the keeper fee in the most efficient way, these functions return the amount (of staking reward to claim, etc.) to the core token contract, where the transfer is executed with the applied fee. This functionality requires treating keeper calls differently, either with an `if` statement or by adding a second version of the call and guarding it with `require` statement.

Specification is currently an untested rough draft and as follows:

#### Request struct

EIP Request struct is abstract enough to contain all the data to perform any transaction, never stored in the contract.

```SOLIDITY
struct Request {
    bytes signature;
    address signer;
    string domainTypehash;
    uint chainId;
    string functionName;// used to compute domain separator
    address callee; // contract/address to call
    bytes4 selector;// function selector to call if any
    bytes callData;//arguments to call with
    uint deadline;
    uint index; //
    uint interval; // if 0, it's one time transaction with salt being invalidated right after, if above 0, it's a subscription. must have a minimum check, otherwise griefing is a possibility
    bool needsHelper; // uniswap trades fail if token address is the sender
    uint salt; // salt is required to invalidate replayable signatures
    address returnToken; // token in which funds are returned after call, ETH is address(0). If it's not ETH or address(this) does not perform a trade, splits returnToken funds
    uint tip; // tip on top of keeper fee is in ETH wei
    address tokenInUse; // if token in use is not address(this), must note that and must have allowance to address(this)
    uint minOut; // minimum out in wei after keeper fee
}
```

#### Account struct

EIP Account contains fields for standard EIP-20 data with additions.

```SOLIDITY
    struct Account {
        mapping(uint => uint) forbiddenSaltsBitMap; // we dont use nonces, we need to also support subscriptions in gas efficient way
        mapping(uint => uint) indexLastClaims; // for replayable subscriptions intervals
        mapping(address => bool) allowances;
        uint balance;// accessible through EIP-20 compliant balanceOf()
        bool forbidAll; // emergency case, etc
    }
```

#### Method callBySignature()

MUST not be used in production. This is an example of EIP callBySignature() function. An update with a tested version will come out soon.

```SOLIDITY
    function callBySignature(Request calldata reqt) external payable {
        uint initGasLeft = gasleft();// gas comes first
        uint gasPrice;
        assembly {
            gasPrice := gasprice()
        }
        require(!users[reqt.signer].forbidAll, 'forbid all is active');
        _verifySig(reqt);
        // check if allowed to use this signature
        require(block.timestamp > users[reqt.signer].indexLastClaims[reqt.index] + reqt.interval, 'sig cant be valid yet');
        require(users[reqt.signer].forbiddenSaltsBitMap[reqt.salt / 256] & (1 << reqt.salt % 256) == 0, 'forbidden salt');
        require(reqt.interval >= 86400);// in seconds, this is to avoid griefing
        // record state change if any
        if (reqt.interval > 0) {
            users[reqt.signer].indexLastClaims[reqt.index] = block.timestamp; // its a subscription, track last execution time
        } else {
            _forbidSalt(reqt.signer, reqt.salt);// it was a one time transaction, forbid this salt
        }
        // call
        // if data is 0, subtract keeper reward from user balance here
        // otherwise data should return amount which is then being split between the user and the keeper
        bytes memory data;
        bool success;
        if (reqt.needsHelper) {
            (success, data) = I(_ab.helper).handle{value: msg.value}(reqt);
            require(success == true, 'beyond help');
        } else {
            (success, data) = reqt.callee.call{value: msg.value}(abi.encodeWithSelector(reqt.selector, reqt.callData));
            require(success == true, 'what went wrong');
        }
        // take fee and complete
        uint amount; // compute amount from data bytes
        assembly {
            amount := mload(add(data, 0x20))
        }
        uint approxGas = (initGasLeft - gasleft() /*+ 21000 */) * gasPrice;
        uint keeperReward = _calculateAmountInNativeToken(reqt.returnToken, approxGas + reqt.tip);
        require(amount - keeperReward >= reqt.minOut);
        if (reqt.returnToken == address(this)) {
            users[msg.sender].balance += keeperReward;
            users[reqt.signer].balance += amount - keeperReward;
        } else {
            if (reqt.returnToken == address(0)) {
                (success, data) = payable(msg.sender).call{value: keeperReward}('');
                require(success);
                (success, data) = payable(reqt.signer).call{value: amount - keeperReward}('');
                require(success);
            } else {
                I(reqt.returnToken).transfer(msg.sender, keeperReward);
                I(reqt.returnToken).transfer(reqt.signer, amount - keeperReward);
            }
        }
    }
```

### Method \_verifySig(Request memory reqt)

MUST not be used in production.

```SOLIDITY
    function _verifySig(Request memory reqt) public {
        bytes memory signature = reqt.signature;
        bytes32 DOMAIN_TYPEHASH = keccak256(bytes(reqt.domainTypehash));
        bytes32 r;
        bytes32 s;
        uint8 v;
        uint chainId;
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
            chainId := chainid()
        }
        bytes32 domainSeparator = keccak256(abi.encodePacked(DOMAIN_TYPEHASH, chainId, reqt.functionName, reqt.selector, address(this)));
        bytes32 hashStructEssentail = keccak256(abi.encodePacked(reqt.signer, reqt.callee, reqt.salt, reqt.index));
        bytes32 hashStructOptions = keccak256(
            abi.encodePacked(reqt.tip, reqt.interval, reqt.returnToken, reqt.tokenInUse, reqt.callData, reqt.minOut)
        );
        bytes32 message = keccak256(abi.encodePacked(domainSeparator, hashStructEssentail, hashStructOptions));
        bytes32 digest = keccak256(abi.encodePacked('\x19Ethereum Signed Message:\n32', message));
        address signer = ecrecover(digest, v, r, s);
        require(signer == reqt.signer, 'sig does not match request');
    }
```

### Method \_calculateAmountInNativeToken(address returnToken, uint amount)

Currently, the least dependent way to calculate the price of a token in a smart contract is through Uniswap's on-chain oracle. The function should be able to compute results even when there is no direct pair between WETH and the given token (the example below would fail in this case, update soon).

```SOLIDITY
    function _calculateAmountInNativeToken(address returnToken, uint amount) internal view returns (uint) {
        address factory = _ab.factory;
        address WETH = _ab.WETH;
        address pool = I(factory).getPair(returnToken, WETH);
        (address token0, ) = WETH < returnToken ? (WETH, returnToken) : (returnToken, WETH);
        (uint reserve0, uint reserve1, ) = I(pool).getReserves();
        (uint reserveToken, uint reserveWETH) = returnToken == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
        return (amount * reserveToken) / reserveWETH;
    }
```

### Salt methods

These methods allow to disable/enable salts in various ways. Ideally, users should be given an opportunity to disable/enable a couple of previous salts not related to meta-transaction with signature at hand.

```SOLIDITY
    function forbidSalt(uint salt) public {
        _forbidSalt(msg.sender, salt);
    }
    function _forbidSalt(address a, uint salt) internal {
        users[a].forbiddenSaltsBitMap[salt / 256] |= (1 << salt % 256);
    }
    // ids should be submitted in order
    function toggleSalts(address a, uint[] calldata salts) public {
        uint word;
        uint bitIndex;
        uint wordIndex;
        for (uint i; i < salts.length; i++) {
            if (salts[i] / 256 != wordIndex) {
                users[a].forbiddenSaltsBitMap[wordIndex] = word;
                wordIndex = salts[i] / 256;
                word = users[a].forbiddenSaltsBitMap[wordIndex];
            }
            bitIndex = salts[i] % 256;
            if (word & (1 << bitIndex) == 0) {
                word ^= (1 << bitIndex);
            }
        }
    }
    // it will be a pain for a user to cherrypick
    // what to toggle without frontend help
    // also keeps the bitmap settings
    function forbidAll() public {
        users[msg.sender].forbidAll = true;
    }
    function unforbidAll() public {
        users[msg.sender].forbidAll = false;
    }
    // emergency case for a gullible user, who does not even know how to transact
    // on their own yet, because used meta transactions for months
    // depending on how you look at it could actually be a bad idea,
    // since can be abused by governance in various ways
    function forbidAllFor(address a) public {
        require(msg.sender == _ab.governance);
        users[a].forbidAll = true;
    }
}
```

## Rationale

Moving the logic out of token contract, in other words having an external KeeperGateway is also a solution, in that case token contract will need to have transferBatch or splitTransfer function allowing for 3 SSTORE instead of 4 for 2 transfers to the signer and the keeper. This however, will still require more external calls, which is expensive, and only something like trading on Uniswap by signature will stay at roughly the same cost. An advantage of having a separate KeeperGateway is that the smart contracts structure would be cleaner. However, in Solidity, object-oriented programming and SOLID principles come at a price, as each step of computation requires gas. Concequently, this leads to radical solutions, like dropping seemingly intuitive and established guidelines, and overall treating smart contracts as fundamentally low level code, that should be representative, if the cost of a transaction would suffer. Yul version will also be available.

Another way to improve the user experience is to reduce the meta-transaction fee by making `address(this)` always indebted to the keepers, i.e. the keeper never receives the full fee after executing. This, however, would require at least one additional `SSTORE`, therefore requires more elaborate argumentation to consider.

Storing full signatures as is in a contract is too costly, `salt` as a reference point is enough.

Adding user whitelists of allowed paths is not the best way to increase user security as of now since user whitelists reintroduce the same user friction this EIP tries to avoid. Since if a whitelist can be edited by signature, then it's practically useless, it needs an actual transaction from the signer. 

Global path whitelists are also ineffective unless they are made to be extremely restrictive, as a malicious signature can easily bypass them if a user is tricked into signing malicious data. Relatively often major dApps provide functions with alterable destination address. To make the most of this EIP with restrictive global paths, it would be best to block all such dApps by default and give users the choice to enable them for personal use.

However, a global/user whitelist of paths for only authorized keepers is a way to enhance security. Authorized keepers then would need KYC, or with trust-minimized pseudo-anonymous approach it could be enough to choose authorized keepers among those who frequently enough transact sufficient value to addresses of KYC-required services such as Coinbase exchange or Binance. Additionally, authorized keepers can be required to lock some funds for a potential dispute.

Adding ability for the governance to roll back a transaction by signature is not possible to make actually useful for recovery of stolen funds on a smart contract level. A malicious actor will simply transfer the funds out of malicious destinaotion address, so a rollback would not be effective.

Getting rid of method abstraction and restricting meta-transactions to predetermined token-related paths is a way to decrease overall gas cost and to protect user funds from being stolen, as long as associated contracts' functions do not have an option to alter destination address to any address. However, this will make meta-transactions a cellular phenomenon and restrict adoption of DeFi. In order to increase the relevance of automation trend and thus come to safest standards, gas cost for provided by this EIP abstraction is a necessary evil.

This highly experimental EIP has the potential to rapidly increase overall usage of various networks, including Ethereum, if accompanied with appropriate guidelines or/and collective decision making.

## Backwards Compatibility

Fully compatible with EIP-20.

## Security Considerations

Both signers and keepers can potentially be malicious to each other.

- Any transaction with a destination address as an argument(Uniswap v2 swaps) can maliciously bypass keeper fee. It is essential for keepers to validate signatures before execution and ensure executed transactions are not attempting to circumvent keeper fees.

- Signers must be cautious about signing anything on websites that they are unfamiliar with, as they may be tricked into signing malicious data. Not to mention, that decrease of user friction will make interactions with the blockchain feel more trivial, making human error more likely. Whitelist of paths for only authorized keepers could partly help with this issue. Overall however, it is not possible to fully address the issue of a user who is easily deceived on a smart contract level with today' cost of computation, so it is better to rely on dApp front-end and wallet software to provide guidelines, warnings, alerts and solutions.

The most likely optimal way of dealing with meta-transactions off-chain is something like only-sign Metamask Lite, which forces the user to always use a different signing key when interacting with a new dApp, remembers dApp profiles, automatically switches them, and also shows the simulated result of the transaction. This, at least partly, will greatly enhance user security.

Security requirements on which this EIP-62xx smart contract code relies might never be adopted. It's better for this standard to stay extreme.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
