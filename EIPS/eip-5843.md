---
eip: 5843
title: EVMMAX
status: Draft
type: standards track
author: Jared Wasinger <jared@ethereum.org>
created: 2022-10-26
---

## Abstract

This EIP introduces EVMMAX (EVM Modular Arithmetic Extensions) - a set of opcodes for performing efficient modular addition, subtraction and Montgomery modular multiplication at varying bitwidths.

Depends on:
* [EIP-4750](./eip-4750.md) - This EIP assumes the removal of dynamic jumps

## Motivation

The EVM has `ADDMOD` and `MULMOD` opcodes which perform modular addition and multiplication.  Two inputs and a modulus are passed as stack items and the result is placed on the stack.  Inputs are not required to be less than the modulus.  The EVM word size limits the inputs and modulus to a maximum of 256 bits in size.

The permissiveness of these opcodes makes them useful in a wide variety of cases.  However, they can not make use of optimizations which can greatly improve performance for common usage patterns.

A common usage pattern for crypto is to perform many chained modular arithmetic operations over a fixed, odd modulus with inputs always less than the modulus. Under these assumptions, modular addition and subtraction can be implemented efficiently with each requiring one extended-precision addition and one extended-precision subtraction.  Modular multiplication is slower requiring an extended-precision multiplication to compute a double-width product, and a modular reduction.

To improve the performance of modular multiplication, values can be expressed in Montgomery form.  This allows for the use of Montgomery modular multiplication which replaces the division by the modulus with a bit-shift and single subtraction in the reduction step.

Operating in Montgomery form requires precomputation of a modulus-specific constant as well as the cost of converting values in canonical form to/from Montgomery form.  However, these costs are greatly offset by the savings gained when performing many modular multiplications.

This EIP proposes a new model for performing modular arithmetic using odd, fixed moduli in the EVM.  The efficiency gain can result in a minimum 80% gas cost reduction per operation compared to current EVM modular arithmetic opcodes, which combined with the ability to use larger values than 256bits enables many desired primitives to be implemented efficiently as EVM contracts.

## Specification

#### Context Variables

| Name | Type | Meaning |
| ---- | ------- | --- |
| `evmmax_state` | `EVMMAXState` | a variable representing ephemeral state which exists for the duration of the current call and in the scope of the current call |

```
class EVMMAXState():
	def __init__(self, mod: int, r_squared: int, mod_inv: int, input_size: int):
		self.mod = mod
		self.r_squared = r_squared
		self.mod_inv = mod_inv
		self.input_size = input_size
```

#### Conventions

| Syntax | Meaning |
| ------ | ------  |
| `x === y % m` | equality of residue classes: `x % m == y % m` |
| `pow(x, -1, m)` | modular multiplicative inverse of `x` with respect to modulus `m`: `x * pow(x, -1, m) === -1 % m` |
| `gcd(x,y)`      | greatest common denominator of `x` and `y` |

#### Definitions

| Word | Meaning |
| ---- | ------- |
| word | a value which is the smallest addressable memory size on a user's computer |

#### Constants:

| Name | Value |
| ---- | ------- |
| `MAX_INPUT_SIZE` | 16 |

Introduce new opcodes:

| Name | Opcode | Stack In | Stack out | Immediate Size (bytes) |
| ----- | ----  | -------- | --------- | -------------- |
| SETMODX | 0x21 | 2 | 0 | 0 |
| ADDMODX | 0x22 | 0 | 0 | 3 |
| SUBMODX | 0x23 | 0 | 0 | 3 |
| MULMONTX | 0x24 | 0 | 0 | 3 |
| TOMONTX | 0x25 | 2 | 0 | 0 |

`ADDMODX`, `SUBMODX` and `MULMONTX` take inputs encoded in a required 3-byte immediate value appended to the opcode.

Gas cost models assume 30ns of execution time for 1 gas and are based on benchmarks of a pure-Go Geth implementation of the EIP on consumer hardware (i7-6500U CPU @ 2.50GHz, 4kb cache (what is cache from /proc/cpuinfo? I assume l2)).

### `SETMODX`

`SETMODX` takes two stack inputs: `(top of stack) mod_offset, mod_size` where `mod_offset` refers to an EVM memory offset where a modulus represented in `mod_size * 8` bytes with big-endian ordering is expected. If `mod_size > MAX_INPUT_SIZE` or `(mod_offset + mod_size * 8) - 1` falls outside the bounds of allocated memory, consume all call gas and return to the caller in an exceptional state.  Charge `gas_setmodx(mod_size)` return to the caller in an exceptional state if there was insufficient gas remaining:
```
SETMODX_GAS_A = 3.8 
SETMODX_GAS_B = 75.0

def gas_setmodx(input_size):
    return round(SETMODX_GAS_A * input_size + SETMODX_GAS_B)
```

Load the modulus and check that the modulus is:
* odd
* greater than 1
* greater than or equal to `(1<<((input_size - 1) * 64)`: the modulus representation occupies the most significant 64 bits.
* can be represented in `MAX_INPUT_SIZE` * 8 bytes.

If any check fails, consume all call gas and return to the caller in an exceptional state.  Otherwise, compute `evmmax_state` (overwriting the previous value if `evmmax_state != None`)
```
# input_size is the size (expressed in 64bit increments) needed to represent mod
input_size = len(hex(mod)[2:])
input_size = (input_size + input_size % 8) / 8
R = 1 << (input_size * 64)
aux_mod = 1 << SYSTEM_WORD_SIZE_BITS
mod_inv = pow(-mod, -1, aux_mod)
r_squared = (r_val ** 2) % mod

evmmax_state = EVMMAXState(mod, r_squared, mod_inv, mod_inv_small, input_size)
```

### Arithmetic Opcodes

`ADDMODX`, `SUBMODX`, `MULMONTX` take inputs encoded in a 3-byte immediate value appended to the opcode.  The immediate is interpreted as 3 1-byte values `out_slot`,`x_slot`,`y_slot`.  Each slot corresponds to a range of the memory space:
```
def map_slot_to_mem_range(input_size, slot):
    return (slot * input_size * 8, (slot + 1) * input_size * 8 - 1)
```

If `evmmax_state` is not set with the call context or the maximum byte of the ranges specified in the inputs is outside the bounds of allocated memory, consume all call gas and return to the caller in an exceptional state.  Otherwise, charge a gas cost based on the input size (`gas_addmodx`, `gas_submodx` or `gas_mulmontx`), returning to the caller in an exceptional state if there was insufficient remaining gas.

```
MULMONTX_GAS_A = 0.1
MULMONTX_GAS_B = 0.7

ADDMODX_GAS_A = 0.2
ADDMODX_GAS_B = 0.6

def gas_mulmontx(input_size):
    cost = round(MULMONTX_GAS_A * (input_size ** 2) + MULMONTX_GAS_B)
    if cost == 0:
        cost = 1
    return cost

def gas_addmodx(input_size):
    cost = round(ADDMODX_GAS_A * input_size + ADDMODX_GAS_B)
    if cost == 0:
        cost = 1
    return cost

def gas_submodx(input_size):
    return gas_addmodx(input_size)

def gas_tomontx(input_size):
    return gas_mulmontx(input_size)
```

##### Gas Cost Table

| Operation | 64bit | 128bit | 192bit | 256bit | 320bit | 384bit | 448bit | 512bit | 576bit | 640bit | 704bit | 768bit | 832bit | 896bit | 960bit |
| --------- | ---------- | ---- | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- |
|MULMONTX/TOMONTX|1|1|2|2|3|4|6|7|9|11|13|15|18|20|23|26|
|ADDMODX/SUBMODX|1|1|1|1|2|2|2|2|2|3|3|3|3|3|4|4|
|SETMODX|79|83|86|90|94|98|102|105|109|113|117|121|124|128|132|136|

Interpret the memory ranges associated with `x_slot`, `y_slot` as big-endian values `x`,`y`.  Assert that `x` and `y` are less than the modulus, returning to the caller in an exceptional state if they are not.  Then, each arithmetic opcode computes a result, expressing it as a 64bit-padded big-endian value and placing it into the memory range referenced by `out_slot`.

`ADDMODX` and `SUBMODX` compute normal modular addition/subtraction:
```
# define some helpers ----------------------------------------------------

# note: LIMB_BITS = 64, BASE = 1<<64 on a 64-bit system

# extract two words of a double-width value into hi, low
def hi_lo(valDouble: int) -> (int, int):
    assert valDouble < 1 << (LIMB_BITS * 2), "val must fit in two words"
    return (valDouble >> LIMB_BITS) % BASE, valDouble % BASE

# single-word subtraction with borrow-in/out
# compute (x - y - b). if negative return (1, abs(x - y - b) % BASE), else return (0, (x - y - b) % BASE)
# b (borrow-in) must be 1 or 0
def sub_with_borrow(x: int, y: int, b: int) -> (int, int):
    assert b == 0 or b == 1, "borrow in must be zero or one"
    res = x - y - b 
    b_out = 0 
    if res < 0:
        res = BASE - abs(res)
        b_out = 1 

    return b_out, res 

# modular addition
# input
#    x, y, mod - arrays of words, big endian word order.
#    x, y < mod
#    len(x) == len(y) == len(mod)
# returns
#    (x + y) % mod expressed as an array of words with big-endian word order
def addmodx_arith(x: [int], y: [int], mod: [int]) -> [int]:
    assert len(x) == len(y) and len(y) == len(mod), "bignum inputs must have same length"
    limb_count = len(mod)
    tmp = [0] * limb_count
    z = [0] * limb_count
    c, c1 = 0, 0

    for i in reversed(range(limb_count)):
        c, tmp[i] = hi_lo(x[i] + y[i] + c)

    for i in reversed(range(limb_count)):
        c1, z[i] = sub_with_borrow(tmp[i], mod[i], c1)

    if c == 0 and c1 != 0:
        z[:] = tmp[:]

    return z

# modular subtraction
# input
#    x, y, mod
#    x, y < mod
#    len(x) == len(y) == len(mod)
# returns
#    (x - y) % mod
def submodx_arith(x: [int], y: [int], mod: [int]) -> [int]:
    assert len(x) == len(y) and len(y) == len(mod), "bignum inputs must have same length"
    limb_count = len(mod)
    tmp = [0] * limb_count
    z = [0] * limb_count
    c, c1 = 0, 0

    for i in reversed(range(limb_count)):
        c, tmp[i] = sub_with_borrow(x[i], y[i], c)

    for i in reversed(range(limb_count)):
        c1, z[i] = hi_lo(tmp[i] + mod[i] + c1)

    if c == 0:
        z[:] = tmp[:]

    return z
```

`MULMONTX` computes `mulmont(x, y, mod)`: the Montgomery modular multiplication of `x` and `y` with respect to `mod` (described below).

#### Montgomery Multiplication

A value `x` expressed in Montgomery form is is `(x * R) % mod` where `R > mod` and `gcd(R, mod) = 1`.  We choose `R = 1 << (input_size * 64)`.

Modular addition and subtraction of values in Montgomery form is computed the same as normally.

```
x * R % mod + y * R % mod == (x + y) * R % mod
x * R % mod + y * R % mod == (x - y) * R % mod
```

However modular multiplication in Montgomery form works somewhat differently.  The modular multiplication `x_mont * y_mont == x * R % mod * y * R % mod == x * y * R * R % mod` is not the expected value in Montgomery form: `x * y * R % mod`.  The extra factor of `R` must be removed.  Therefore `mulmont(x_mont, y_mont, mod)` computes `x_mont * y_mont * pow(R, -1, mod) % mod`.

```
# input:
#     x < mod
#     y < mod
#   mod - an odd modulus
#     R -  a power of two, and greater than mod
#     mod_inv_full - pow(-mod, -1, R)
# output:
#    (x * y * pow(R, -1, mod)) % mod
#
def mulmont(x: int, y: int, mod: int, mod_inv: int, R: int) -> int:
    T = x * y                            # 1
    m = ((T % R) * mod_inv_full) % R     # 2
    T1 = T + m * mod                     # 3
    T1 /= R                              # 4
    if T1 >= mod:
            T1 -= mod                    # 5
    return T1
```

To show that `mulmont` is correct, we can prove a few properties of the algorithm:
* `T1 % R == 0` before the division in step 4: `T1 == ((T % R) * modinv * mod) % R + T % R === ((-1) * T + T) % R === 0 % R`
* `T1 === x * y * r_inv % mod`: `T1 = (T%R + m*mod)R**-1 % mod === ((T%R)R**-1 + m*(R**-1)*mod) % mod === TR**-1 % mod`.
* `0 < T1 < 2 * mod` after the division in step 4: `m` is between 0 and `R*mod - 1` so `0 < T1 < (mod**2 - 1) + (R - 1) * mod < (R*mod - 1) + (R - 1)*mod  < 2*R*mod` which after division by `R` makes the result smaller than `2 * mod`.

Note that the choice of `R` as a power of two enables the division in step 4 to be implemented as a bit-shift.

`mulmont` is the generic algorithm to perform Montgomery Multiplication.  There are other algorithms which achieve better performance at small bit-widths.  These use a different Montgomery constant (`mod_inv`).

#### Conversion between Montgomery and Canonical forms

Conversion of a value to Montgomery form can be computed with `mulmont(val, evmmax_state.r_squared, mod) == val * R % mod`.

`TOMONTX` takes two stack items as input `(top of stack) input, output`.  The most significant byte of each input is an EVMMAX slot (`input_slot`/`output_slot`).  If `evmmax_state == None` or the offset of the highest byte of the ranges referenced by the inputs is outside the bounds of allocated memory, consume all call gas and return to the caller in an exceptional state. Interpret the memory range associated with `input_slot` as little-endian value `input`, compute `mulmont(input, evmmax_state.r_squared, mod)` and place the result in the memory range referenced by `output_slot`.

Conversion from Montgomery form `x_mont` to canonical form can be computed with `mulmont(x_mont, 1, mod)`.

## Rationale


---

Design goals:
* minimal spec providing improvements for operations that constitute most bottlenecks:
    * operations like inverse and square root are omitted.  And it seems for prime modulus, both can be implemented using the operations here (mostly multiplications)
* efficiency:
    * encoding of arguments using 3-byte immediates saves 3 stack operations per arithmetic op and minimizes the bytecode size footprint.
        * operands/offsets are known statically which makes the resulting bytecode easier to analyze and opens the potential for optimizations like squaring
    * Montgomery multiplication is chosen because it is used ubiquitously in crypto libraries and has most application (TODO compare to barrett reduction?)
The choice of using an offset-based approach where operations happen on values in memory overcomes the need for stack manipulation and enables a wider variety of bit-widths than currently economical in the EVM.

choice of 1-byte immediates:
* smaller bytecode size
    * restriction to single byte offset is made to reduce contract size footprint while still providing ample potential memory slots.
* offsets known statically enables potential client-side optimizations:
    * detection of cases such as squaring at deployment time
    * may allow easier JIT/compilation of EVMMAX code
* reduced cost and better performance compared to stack-supplied arguments: "reduces cost of each EVMMAX arith op invocation by 3-gas without requiring PUSH cost reduction (which would be hard to propose because there may be pathological cases that could be excacerbated if PUSH were cheaper)."

* The choice of big-endian value format allows better interoperability with the rest of the EVM.

`TOMONTX` is necessary for contracts which do not fix the modulus: an example use-case is a contract which implements a replacement of the modexp precompile.
`TOMONTX` doesn't take memory offsets because conversion to/from Montgomery won't be a big overhead in most (all?) use-cases, and stack-based arguments give more flexibility to developers.

Choice to not potentially expand memory: there's no real use-case for it, and it adds complexity to the spec.

Addmodx/Submodx are linear, Mulmontx is quadratic (this should be obvious?)

## Security Considerations

### Validity of inputs

Because `R` and `mod` are coprime, the set of `(q * R ) % mod` where `q < mod` is a permutation of the set `q % mod`: all representable values less than `mod` are Montgomery form representations of other values less than `mod`.

## Implementation

Geth: https://github.com/jwasinger/go-ethereum/tree/evmmax

## Test Cases

TBD

## Open Questions


### Optimizations for Moduli of Special Forms

Example: [Gnark](https://hackmd.io/@gnark/modular_multiplication) optimization of 20% reduction in runtime when the most significant word of the modulus is less than `(D - 1) / 2` where `D` is `2**64` on a 64bit system.

### Input Size Cap

`EVMMAX_INPUT_SIZE` is tentatively set to 16.  Use cases such as 2048/4096bit RSA verification are not possible to implement with using EVMMAX unless the limit is raised.

This hinges on two issues:
1) Comprehensive memory benchmarks: Currently, the cost of a memory access is 6 gas to access a 256bit value (1 push + 1 mload).  EVMMAX arithmetic opcodes access 3 memory values of varying size.  The current memory cap of 260kb ensures that EVMMAX memory fits within the L2 cache of most machines.  Adjusting the cap higher will require analysis and a new model to account for memory overhead with larger bitwidths.
2) Altered algorithms and gas-model for Montgomery Multiplication at larger bitwidths:  Subquadratic algorithms like CIOS have poor asymptotic complexity.  The implementation and gas model for larger bitwidths could use the generic `mulmont` algorithm where the constituent multiplications use a multiplication method with better asymptotic complexity (like Karatsuba with `O(N**1.58)`)

### Trading more Precomputation/Complexity for Better Performance:

**TODO:** remove this sub-section and put into another document.  it's too complex to discuss here.

This is a sketch of an idea to optimize performance for contracts with a static modulus:

State values that comprise `EVMMAXState` are expected to be pre-computed (off-chain) and placed manually in the deployed bytecode.
Introduce a new EOF section type.  Values that are computed by `SETMODX` are expected to be manually embedded in this section during contract creation.  Expect state values from `EVMMAXState` (set with the contract creation call state) to be embedded in the section followed by a number of optional execution hints.

For blocks of EVMMAX arithmetic opcodes, provide the following values:
* maximum EVMMAX slot accessed by all opcodes in the block
* count the number of multiplications/additions/subtractions in the block
* any slots in the block which are inputs

Also, ensure during contract creation that there are no jumps to any positions in a block past the first.

Using these execution hints, blocks of EVMMAX arithmetic opcodes can be executed "atomically":
* one memory bounds check is computed per block.
* The gas of an entire block is charged at the start of the block.
* Only do input bounds checks on block inputs.

This would remove much of the interpreter-loop overhead and potentially warrant the use of [particle gas metering](./eip-2045.md) for pricing EVMMAX arithmetic ops in blocks.

## Appendix

### 1 - Fast Montgomery multiplication for small bit-widths

`mulmont` algorithms which are most performant for smaller bit-widths opt to interleave the multiplication and reduction steps, removing the need to compute the full double-width product of `x` and `y`.  Many use a different montgomery constant: `mod_inv_small`.

The "CIOS" Montgomery multiplication algorithm is an example, which is noted to be the most performant out of several surveyed in [tolga acar's thesis].

```
# given two equally-sized, multiple-limb numbers x, y: return x >= y
def bigint_gte(x, y) -> bool:
    assert len(x) == len(y), "x and y should have same number of limbs"
    
    for (x_limb, y_limb) in list(zip(x,y)):
        if x_limb > y_limb:
            return True
        elif x_limb < y_limb:
            return False

    return True

# return x - y (omitting borrow-out)
def bigint_sub(x: [int], y: [int]) -> [int]:
    assert len(x) == len(y), "num_limbs must be equal"
    num_limbs = len(x)
    res = [0] * num_limbs
    c = 0 

    for i in reversed(range(num_limbs)):
        c, res[i] = sub_with_borrow(x[i], y[i], c)

    return res[:]


# CIOS Montgomery multiplication algorithm implementation adapted from section 2.3.2 in https://www.microsoft.com/en-us/research/wp-content/uploads/1998/06/97Acar.pdf
#
# input:
#    x, y, mod - numbers represented by arrays of words with big-endian word order
#    x, y < mod
#    mod % 2 != 0
#    mod_inv_small = pow(-mod, -1, 1<<SYSTEM_WORD_SIZE_BITS)
# output:
#    (x * y * pow(R, -1, mod)) % mod represented by an array of words with big-endian word order.
#
def mulmont_cios(x, y, mod, modinv) -> [int]:
    assert len(x) == len(y) and len(y) == len(mod), "{}, {}, {}".format(x, y, mod)
    assert mod[0] != 0, "modulus must occupy all limbs"

    limb_count = len(mod)

    t = [0] * (limb_count + 2)

    for i in reversed(range(limb_count)):
        # first inner-loop multiply x * y[i]
        c = 0 
        for j in reversed(range(limb_count)):
            c, t[j + 2] = hi_lo(t[j + 2] + x[j] * y[i] + c)

        t[0], t[1] = hi_lo(t[1] + c)

        m = (modinv * t[-1]) % BASE
        c, _ = hi_lo(m * mod[-1] + t[-1])

        # second inner-loop: reduction.
        for j in reversed(range(1, limb_count)):
            c, t[j + 2] = hi_lo(t[j + 1] + mod[j - 1] * m + c)


        hi, t[2] = hi_lo(t[1] + c)
        t[1] = t[0] + hi

    t = t[1:]
    if t[0] != 0:
        return bigint_sub(t, [0] + mod)[1:]
    elif bigint_gte(t[1:], mod):
        return bigint_sub(t[1:], mod)
    else:
        return t[1:]
```

TODO: demonstrate that `mulmont_cios` has the same properties as `mulmont`.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
