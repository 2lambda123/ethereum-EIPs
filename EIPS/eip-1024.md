---
eip: 1024
title: Add web3.eth.encrypt
author: Tope Alabi <alabitemitope@gmail.com>
status: Draft
type: Interface Track
created: 2018-05-14
---


### Abstract
This EIP proposes a cross-client method for requesting encryption/decryption. This method will include a version parameter, so that different encryption methods can be added under the same name. This solution will utilize the cryptographically complete and well audited nacl library. Ethereum keypairs are not used directly for encryption, instead we derive an encryption keypair from the account's private key for decryption and generate a random ephemeral keypair for encryption.   
 
Parity wallet already implements a compatible encrypt/decrypt method and the MetaMask version is on the way. Having a cross-client standard will enable a whole new wave of decentralized applications that will allow users to securely store their private data in public databases such as IPFS.

### Motivation
Imagine an illegal immigrant named Martha. Martha moved to the United States illegally but then had 2 children there, so her children are citizens. One day Martha gets arrested and deported but her children get to stay. How will Martha pass power of Attorney, bank account info, identification docs, and other sensitive information to her children? Storing that data in a centralized database can be incriminating for Martha, so maybe decentralized databases like IPFS could help, but if the data is not encrypted anyone can see it, which kind of defeats the purpose. If Martha had access to a Dapp with end-to-end encryption connected to her identity, she could save her data in a decentralized, censor-proof database and still have confidence that only her children can access it.

More casually, Martha can create a treasure hunt game, or a decentralized chat app etc.

### Specification

Using the nacl library this solution will generate an encryptionKeyPair(ethereumPrivateKey) for each account.  
```
//Javascript Implementation

const nacl = require('tweetnacl')

/**
* Returns user's public Encryption key
*/
web3.eth.getPublicEncryptionKey(account) { /* implementation */ }

/**
* Encrypts plain data.
* @param {Account} account - The account to encrypt with
* @param {string} version - A unique string identifying the encryption strategy.
* @param {Object} data - The data to encrypt
* @param {Function} callback - The function to call back when decryption is complete.
*/
web3.eth.encrypt = function encrypt (account, version, data, callback) { /* implementation */ }
web3.eth.encrypt(account, 'x25519-xsalsa20-poly1305-v1', data, callback)

/**
* Decrypts some encrypted data.
* @param {Account} account - The account to decrypt with
* @param {string} version - A unique string identifying the decryption strategy.
* @param {Object} data - The data to decrypt
* @param {Function} callback - The function to call back when decryption is complete.
*/
web3.eth.decrypt = function decrypt (account, version, data, callback) { /* implementation */ }
web3.eth.decrypt(account, 'x25519-xsalsa20-poly1305-v1', data, callback)

```

**To Encrypt:**
- Alice requests Bob's publicEncryptionKey
- Bob generates his encryptionKeypair using nacl.box.keyPair.fromSecretKey(bob.ethereumPrivateKey)
- Bob sends Alice his encryptionKeyPair.publicKey
- Alice generates a random ephemeralKeyPair
- Alice uses her ephemeralKeypair.secretKey and Bob's encryptionPublicKey to encrypt the data using nacl.box. She sends him an encrypted blob of the form:

```
{ version: 'x25519-xsalsa20-poly1305',
  nonce: '1dvWO7uOnBnO7iNDJ9kO9pTasLuKNlej',
  ephemPublicKey: 'FBH1/pAEHOOW14Lu3FWkgV3qOEcuL78Zy+qW1RwzMXQ=',
  ciphertext: 'f8kBcl/NCyf3sybfbwAKk/np2Bzt9lRVkZejr6uh5FgnNlH/ic62DZzy' }
```


**To Decrypt:**
- Bob generates his encryptionPrivatekey using nacl.box.keyPair.fromSecretKey(bob.ethereumPrivateKey).secretKey
- Bob passes his encryptionPrivateKey along with the encrypted blob to nacl.box.open(ciphertext, nonce, ephemPublicKey, myencryptionPrivatekey)


### Rationale
These methods should require user confirmation. We include the versioning to allow different encryption/decryption types to be added under the same method name. For example, it might make sense to have a few kinds of decrypt methods, for different kinds of consent:
- Consent to download a decrypted file.
- Consent to return decrypted file to the current site.
- Consent to return any number of decrypted messages to the current site over a certain period of time. (could enable chat apps)


### Backwards Compatibility
This solution is compatible with existing Parity implementation.
https://github.com/paritytech/parity/blob/bd7273061e3f13f53fdd2fa91dc641a83bcc47f0/ethcore/crypto/src/lib.rs#L211

### Test Cases
`getPublicEncryptionKey(account)` should return a public encryption key of the form `"C5YMNdqE4kLgxQhJO1MfuQcHP5hjVSXzamzd/TxlR0U="`

`web3.eth.encrypt(account, 'x25519-xsalsa20-poly1305-v1', 'data', callback)` should return a blob of the form `{ version: 'x25519-xsalsa20-poly1305',
  nonce: '1dvWO7uOnBnO7iNDJ9kO9pTasLuKNlej',
  ephemPublicKey: 'FBH1/pAEHOOW14Lu3FWkgV3qOEcuL78Zy+qW1RwzMXQ=',
  ciphertext: 'f8kBcl/NCyf3sybfbwAKk/np2Bzt9lRVkZejr6uh5FgnNlH/ic62DZzy' }` 

`web3.eth.decrypt(account, 'x25519-xsalsa20-poly1305-v1', 'data', callback)` should return plain text/file of the form `{ data:'My name is Satoshi Buterin' }` 

### Implementation
Parity wallet has already implemented a compatible encryption/decryption method. The Metamask version will be published soon.
https://github.com/topealabi/eth-sig-util/blob/master/index.js

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
