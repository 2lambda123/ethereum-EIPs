---
eip: 3345
title: Chain Reaction
author: Alberto Cuesta Ca√±ada (@albertocuestacanada)
discussions-to: https://ethereum-magicians.org/t/erc-3345-call-chaining/5508
status: Draft
type: Standards Track
category: ERC
created: 2021-03-06
---

## Simple Summary

This ERC provides a standard to execute a combination of calls in one smart contract, and another set of calls from that first smart contract to a second smart contract.

## Abstract

This standard is a generalization of ERC667, in which we remove:
 - The specialization to ERC20.transfer functions.
 - The duplication of functions, only one function is required per contract implementing ERC3345Caller.

In this standard we include:
 - Interfaces and processes for an ERC3345Receiver to react to a call from an ERC3345Caller, with knowledge of the previous call for a minimal gas cost.

Central to this standard is the shifting of responsibility to the receiver, which must implement mechanisms to be able to trust the data received from the caller, usually through mechanisms to trust the caller itself.

## Motivation

Previous standards such as ERC667 and ERC1363 have three main drawbacks:
1. Cumbersome in that all functions to be followed by a contract call need to be duplicated.
2. Opaque in that the encoded data to be forwarded is not easily interpreted.
3. Rigid in that the receiver of the tokens is also the receiver of the control.

The main drawback of ERC777, which is also an alternative to this standard, is its reliance on ERC1820, which is both complex to implement and costly in gas terms.

This standard aims to solve those drawbacks.

## Specification

A chain reaction pattern integrates two smart contracts. These are called the CALLER and the RECEIVER in this EIP.

### Receiver Specification

A `receiver` of MUST implement the IERC3345Receiver interface:

```
interface IERC3345Receiver {
    function receiveControl(
        bytes calldata lastCall,
        bytes calldata thisCall
    ) external returns (bytes32);
}
```

If successful, `receiveControl` MUST return the keccak256 hash of "ERC3345Receiver.receiveControl".

The `lastCall` parameter includes the abi-encoded data of the function call that preceded `receiveControl`:
 - msg.sender
 - msg.value
 - last abi-encoded local call
 - abi-encoded output of the last local call

The `thisCall` parameter is the abi-encoded data of the function to be called in `receiver`.

### Caller Specification

A `caller` MUST call the `receiveControl` function on an IERC3345Receiver, as specified above.

## Rationale

[What I've done is to go back to the very beginning of the ERC667 discussion, and choose a different set of trade offs. From the beginning, it was assumed that the receiver of the control couldn't trust the contract in which the `transfer` was executed. From ERC3156 I know this is false.]

[In addition to that, using an adaptation of the `multicall` pattern in ENS, we can avoid duplicating every function in a contract. We can just add one function to any contract, and any function in that contract can be chained to a call in a remote contract.]

[I've also removed the restriction that the receiver of the control must be the receiver of the tokens.]

[Taking some lessons from ERC3156, we pack the details (msg.sender, msg.sig, msg.value, parameters and outputs) of the local call along with the remote call, so the receiver contract can decide what to do.]

[
The biggest upsides are:
 - External calls to a service like ERC1820 are not needed, which makes it cheaper than ERC777.
 - Callers only need to inherit a contract, making the standard easy to adopt.
 - Flexible, can be used for any contract (ERC20, ERC721, whatever).

The biggest downsides are:
 - Complexity in the receiver, which needs to verify the caller and then decode the previous call. However, this is mitigated by allowing arbitrary receivers.
 - Opacity of the transaction signed. However, given that it is a list of abi-encoded function calls, UIs should be able to decode them and show them to the user on signing.
]

## Backwards Compatibility

No backwards compatibility issues identified.

## Implementation

### ERC3345Caller Reference Implementation

```
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

/// @dev Contracts wishing to pass the control to ERC3345Receiver contracts must inherit this contract
contract ERC3345User {

    // ALTERNATIVE 1
    // Do a local call.
    // Pack its inputs (msg.sig, msg.sender, msg.value, parameters) and outputs.
    // Pass the details about the executed local call to an ERC3345Receiver, along with an abi-encoded call for the ERC3345REceiver to execute
    function chainCall(bytes calldata localCall, IERC3345Receiver receiver,  bytes calldata remoteCall) public returns(bytes[] memory results) {
        // Inspired in multicall from ENS - https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/PublicResolver.sol#L56-L64
        results = new bytes[](2);
        (bool success, bytes memory result) = address(this).delegatecall(localCall);
        require(success);
        results[0] = result;
        // Pack the local call with msg.sender, msg.value, and call output with into lastCall.
        bytes lastCall = abi.encode(msg.sender, msg.value, localCall, result);
        // Then we execute the remote call
        require(
            receiver.receiveControl(lastCall, remoteCall) == ERC3345_SUCCESS,
            "Remote call failed"
        );
        results[1] = ERC3345_SUCCESS;
        return results;
    }

    // ALTERNATIVE 2
    // Same as above, but do an arbitrary amount of local calls before passing control to the ERC3345Receiver.
    // Only the details of the last call executed need to be passed along.
    function chainMulticall(bytes[] calldata localCalls, IERC3345Receiver receiver,  bytes calldata remoteCall) public returns(bytes[] memory results) {
        // First we copy multicall from ENS - https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/PublicResolver.sol#L56-L64
        results = new bytes[](localCalls.length + 1);
        for(uint i = 0; i < localCalls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(localCalls[i]);
            require(success);
            results[i] = result;
        }
        // Pack the last local call with msg.sender, msg.value, and call output with into lastCall.
        bytes lastCall = if (localCalls.length > 0) abi.encode(msg.sender, msg.value, localCalls[localCalls.length - 1], result) : 0x00;
        // Then we execute the remote call
        require(
            receiver.receiveControl(lastCall, remoteCall) == ERC3345_SUCCESS,
            "Remote call failed"
        );
        results[localCalls.length] = ERC3345_SUCCESS;
        return results;
    }
}
```

### ERC3345 Receiver Reference Implementation

```
/// @dev Contracts wishing to receive the control from ERC3345 contracts must implement this interface
interface ERC3345Receiver {

    // Recommended implementation:
    // 1. If the data from the lastCall is going to be decoded, verify that msg.sender is trusted.
    // 2. Extract lastCallMsgSender, lastCallMsgValue, lastCall and bytes lastCallOutput
    // 3. Verify that the first 4 bytes of lastCall are known to this contract, and therefore allows decoding lastCallParameters and bytes lastCallOutput
    // 4. Do whatever needs to be done
    // 5. return keccak256(ERC3345.receiveControl)
    function receiveControl(bytes calldata lastCall, bytes calldata thisCall) public returns(bytes32);
}
```

## Security Considerations

### Verification of callback arguments

The `lastCall` of `receiveControl` is expected to reflect the conditions of the previous call, but cannot be trusted unconditionally. To trust the veracity of `lastCall` the `receiver` must match `msg.sender` against a list of trusted callers.

### Using the caller for shady purposes

A caller that implements ERC3345 will execute any abi-encoded function call that it receives, on any target, with the only condition that it will execute the `receiveControl` function and expect a `keccak256(ERC3345.receiveControl)` result. It is required to carefully investigate the abuse opportunities derived from this, and how can they be mitigated.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
