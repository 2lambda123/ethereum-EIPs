---
eip: 6662
title: AA Account Metadata
description: An ERC-4337 extension to define how dApps authenticate AA accounts
author: Shu Dong (@dongshu2013), Zihao Chen (@zihaoccc)
discussions-to: https://ethereum-magicians.org/t/eip-6662-account-metadata-for-aa-account-authentication/13232
status: Draft
type: Standards Track
category: ERC
created: 2023-03-09
requires: 712, 4337, 4804
---

## Abstract

This ERC proposes a new **IAccountMetadata** interface as an extension for [ERC-4337](./eip-4337.md) to store account information on-chain to promote a simplified authentication model.

## Motivation

In this proposal, we propose a new **IAccountMetadata** interface as an extension of ERC-4337 **IAccount** interface. With the new interface, users can store authentication related data on-chain through one-time publishing, allowing dApps to proactively fetch account-related information from the chain to support more flexible, lower-complexity authentication/authorization processes. This will serve as an alternative to the current authentication model where users need to log in with their wallet every time and push account-related information to dApps by connecting the wallet.

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

### Authentication Flow

![Authentication Flow](../assets/eip-6662/auth-flow.png)

### Definition of Terms

**User**: End user, AA account owner, whom has ability to interact with dApps

**Smart Contract Account**: Stands for ERC-4337 compatible account

**dApps**: software applications that run on a decentralized network of computers, rather than on a centralized server. AKA, Decentralized Applications

**Relay**: Relay is an on-line service to forward requests from dApps to an off-line Authenticator. If the authenticator is always online, then it could bypass the Relay and listen to dApps directly.

**Authenticator**:  Authenticator could be anything holding the private key to sign user operations. It could be a wallet, an authenticator mobile app or even a cloud service.

### Interface

```
interface IAccountMetadata {
  struct AuthenticationInfo {
    // the service URI to relay message from dApps to authenticator
    string relayURI;
    // a JSON string or URI pointing to a JSON file describing the
    // schema of AuthenticationRequest. The URI should follow ERC-4804
    // if the schema file is stored on-chain
    string schema;
  }

  function authenticationData() external view returns(AuthenticationInfo);
}
```

The relay endpoint should accept an AuthenticationRequest object as input. The format of the AuthenticationRequest object is defined by the schema field at AuthenticationInfo.

Following is a schema example which supports end to end encryption, where we pack all encrypted fields into an encryptedData field. The symbol “\$e2ee” indicates that the field is encrypted and we should search its unencrypted value at the encryptedData field. Here we listed three basic fields but there may be more fields per schema definition.

```
{
    "title": "AuthenticationRequest",
    "type": "object",
    "properties": {
        "entrypoint": {
            "type": "string" | "$e2ee",
            "description": "the entrypoint contract address",
        },
        "chainId": {
            "type": "string" | "$e2ee",
            "description": "the chain id",
        },
        "userOp": {
            "type": "object" | "$e2ee",
            "description": "UserOp defined by ERC-4337 without signature",
        },
        "encryptedData": {
            "type": "string",
            "description": "contains all encrypted fields"
        },
    }
}
```

## Rationale

To enable the new authentication workflow we described above, dApp needs to know two things:

1. **Where is the authenticator?** This is solved by the relayURI field. Users can publish the uri as the account metadata which will be pulled by dApp to do service discovery.

2. **What’s the format of AuthenticationRequest?** This is solved by the schema field in struct AuthenticationInfo, which defines the schema of the encryptedData field in the AuthenticationRequest object. The data could be used either by the relay service to authenticate the request, or by the authenticator to display information at screen.


## Backwards Compatibility

The new interface is fully backward compatible with ERC-4337.

## Security Considerations

### End to End Encryption

To protect the user’s privacy and prevent front-running attacks, we should keep the data encrypted during transmission from dApps to authenticators. This could be done by adopting the JWE (JSON Web Encryption, RFC-7516) method to encrypt. Before sending out AuthenticationRequest, we generate a symmetric CEK(Content Encryption Key) to encrypt the whole request and encrypt the CEK with the signer's public key. dApp will pack the encrypted data as a JWE object and send it to the relay service so everything is end to end encrypted.

### Signing

We will follow [EIP-712](./eip-712.md) standard for signing to improve the usability of off-chain message signing.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
