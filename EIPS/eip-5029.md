---
eip: 5029
title: Subscription Tokens
description: Tokens with the ability to pay recurring costs
author: Pandapip1 (@Pandapip1)
discussions-to: https://ethereum-magicians.org/t/eip-5029-subscription-tokens/9013
status: Draft
type: Standards Track
category: ERC
created: 2022-04-21
requires: 20, 165, 4524
---

## Abstract
Recurring payments (hereafter referred to as "subscriptions"), are often tricky to implement, and frequently bad for user experience. The current merged standards ([EIP-1337](./eip-1337.md) and [EIP-4885](./eip-4885.md)) are cumbersome for users, because they have to continually remember to transfer an advance amount. The user would rather have to approve a fixed amount of transactions than to approve a linear amount of transactions over time.

This EIP proposes to fix these issues using an extension of [EIP-4524](./eip-4524.md), itself an extension of [EIP-20](./eip-20.md). It adds new functions to allow addresses to "subscribe" to other addresses, and for the receiving address to control the amount received so that the user can pay for their usage.

## Motivation
A typical type of ICO is where the token amount is paid out over time. This is usually done through a form of pull payment, which is cumbersome for the user. With this system, the user only has to make a single transaction to receive the funds: `updateSubscription` for the maximum uint256 value. Lottery payouts or pensions could also be paid out in this manner.

NFTs could require that a maintenance cost be paid. An silly example could be an NFT game with virtual chickens that require virtual food to stay alive. These could be combined in interesting manners -- food can be used to "feed" chickens, which "lay" eggs automatically. Eggs could be automatically "exported" to a market, and so on.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

### ERC5029Token
Tokens with subscription functionality MUST implement the following interface:

```solidity
interface ERC5029Token is /* ERC20, */ ERC165, ERC4524 {

    /////////////////
    //// GETTERS ////
    /////////////////

    /// @notice             Gets the number of tokens that are sent per block from `from` to `to`
    /// @param  from        The address sending tokens
    /// @param  to          The address receiving tokens
    /// @return amount      The amount of tokens being sent
    function subscription(address from, address to) external view returns (uint256 amount);


    /// @notice             Gets the maximum number of tokens that can be sent per block from `from` to `to`
    /// @param  from        The address sending tokens
    /// @param  to          The address receiving tokens
    /// @return allowance   The maximum value of `amount` in `updateSubscription`
    function subscriptionAllowance(address from, address to) external view returns (uint256 allowance);

    /// @notice             Gets if the balance is larger than or equal to the amount paid each block
    /// @param  subscriber  The account paying
    /// @return active      Whether or not the account is able to pay
    function subscriptionActive(address subscriber) external view returns (bool active);

    /////////////////
    //// SETTERS ////
    /////////////////

    /// @notice             Sets the subscription allowance to `amount`
    /// @param  to          The address receiving tokens
    /// @param  amount      The amount to send/approve each block
    function subscribe(address to, uint256 amount) external;


    /// @notice             Sets the subscription allowance to `amount`, and performs validation
    /// @param  to          The address receiving tokens
    /// @param  amount      The amount to send/approve each block
    function safeSubscribe(address to, uint256 amount) external;


    /// @notice             Sets the subscription allowance to `amount`, and performs validation
    /// @param  to          The address receiving tokens
    /// @param  amount      The amount to send/approve each block
    /// @param  data        Data to provide to `onERC20Subscribed`
    function safeSubscribe(address to, uint256 amount, bytes memory data) external;


    /// @notice             Sets the subscription amount to `amount`
    /// @param  from        The address sending tokens
    /// @param  amount      The amount to send/approve each block. If greater than the allowance, then only the allowance will be sent
    /// @return authed      `true` if `amount` is less than or equal to the authorization.
    function updateSubscription(address from, uint256 amount) external returns (bool authed);

    ////////////////
    //// EVENTS ////
    ////////////////

    /// @notice             Emitted when the subscription amount is changed
    /// @param  from        The address sending tokens
    /// @param  to          The address receiving tokens
    /// @param  amount      The amount sent each block
    event Subscription(address indexed from, address indexed to, uint256 amount);


    /// @notice             Emitted when the subscription allowance is changed
    /// @param  from        The address sending tokens
    /// @param  to          The address receiving tokens
    /// @param  amount      The maximum amount sent each block
    event SubscriptionApproval(address indexed from, address indexed to, uint256 amount);
}
```

`ERC5029Token`s MUST comply with [EIP-165](./eip-165.md). The identifier for `ERC5029Token` is `0xTODO`.

`ERC5029Token`s MUST comply with the [EIP-4524](./eip-4524.md) and [EIP-20](./eip-20.md) token standards.

`safeSubscribe` MUST transfer as expected to EOA addresses, and to contracts implementing `ERC20Subsriber` and returning the function selector (`0xTODO`) when called, and MUST revert when transferring to a contract which either does not have `ERC20Subsriber` implemented, or does not return the function selector when called. This wording is taken from [EIP-4524](./eip-4524.md#specification).

### ERC20Subscriber
Contracts that accept subscriptions MUST implement the following interface:

```solidity
interface ERC20Subscriber is ERC20Receiver {
    /// @dev                `updateSubscription` MAY be safely called from this function,
    ///                     because it does not re-call `onERC20Subscribed`. This is the 
    ///                     RECOMMENDED way to automatically accept subscriptions.
    ///                     This MUST return the function selector, `0xTODO`.
    function onERC20Subscribed(address from, uint256 amount, bytes data) external returns(bytes4);
}
```

`ERC20Subscriber`s MUST comply with [EIP-165](./eip-165.md). The identifier for `ERC20Subscriber` is `0xTODO`.

## Rationale
[EIP-4524](./eip-4524.md) was used as a base because of the similarity in use-cases (automatic receiving of one-off payments vs automatic receiving of ongoing payments).

The reason that `subscribe` and `safeSubscribe` set an "allowance" is so that contracts can receive payments based on their usage (e.g. an NFT doesn't need to pull payments from everyone who ever owned it, only the current owner).

The reason that `subscribe` and `safeSubscribe` do not set the subscription amount directly is because it might mess with contract logic that depends on the amount they receive being a certain amount, and to reduce gas costs for the account sending funds.

The names of `ERC20Subscriber` and `onERC20Subscribed` were chosen because of similar naming in [EIP-4524](./eip-4524.md) (`ERC20Receiver`, `onERC20Received`).

## Backwards Compatibility
There are no backwards compatibility issues. All function and event names are unique and do not conflict.

## Security Considerations
`onERC20Subscribed` is a callback function. Callback functions have been exploited in the past as a reentrancy vector, and care should be taken to make sure implementations are not vulnerable. This wording is taken from [EIP-4524](./eip-4524.md#security-considerations)).

Subscriptions are not enumerable, and balance changes because of subscriptions do not show up in event logs because there are no associated transactions. Client-side tracking of subscriptions is essential.

While implementing an `ERC20Subscriber` contract, make sure that `subscriptionActive(subscriber)` and that the subscription amount is high enough. No callback is called if the subscriber runs out of tokens.

Implementing `ERC5029Token` significantly increases the code complexity, because balances change without changes in state. In particular, watch out for edge cases, particularly overflows and underflows. Make sure to have your code **thoroughly** audited, or use a commonly-used library.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
