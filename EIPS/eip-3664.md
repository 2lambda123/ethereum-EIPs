---
eip: 3664
title: Next generation metaverse NFT
description: This is a standard for next generation metaverse NFTs, which extends [ERC-1155](./eip-1155.md)
author: TylerZ (@tylerztl), TY (@nimocat)
discussions-to: https://ethereum-magicians.org/t/eip-3664-next-generation-game-nft-standard/6738
status: Draft
type: Standards Track
category: ERC
created: 2021-07-17
requires: 20, 1155
---

## Abstract
In this proposal, we created the next gen component-NFT standard, which makes up for the problem that ERC-721 and ERC-1155 can only support unchangeable attributes of NFTs. component-NFT can make the attributes in a NFT have five characteristics: transferable, upgradeable, changeable, combinable and evolvable. By using ERC-3664 standard NFTs in any fields, users can create any valueable dapps based on component-NFT standard.

## Motivation
In the early days of NF, ERC-721 was the main NFT protocol. It focused on differentiating NFTs from FTs. But since the emergence of the Layer 2 and Metaverse, outdated NFT protocols would no longer suffice for NFT standards in the new era. We hope to objectize NFTs, and allow for their upgrades, assembly and disaggregation on the blockchain. We will also let them change with the passage of time so that these fundamental functionalities will endow NFTs with a world of possibilities, creating unparalleled value.

The NFT standard proposed by EIP-3664 enable unlimited disaggregation and assembly. Players can forge modularized NFTs with this proposal, and aggregate modularized NFTs into a new NFT, and let new NFTs combine with each other. On the other hand, NFTs can be disaggregated into component parts and reassembled. These powerful functionalities can sustain many different use cases in the future, such as team configuration in competitive gaming, amendable terms and clauses in financial contracts and honor awarding mechanisms in blockchain games. With the present proposal, you can realize any arbitrary functionality with your NFT. At the same time, the present proposal is an extension protocol of ERC-1155 and ERC-721, implying compatibility with ERC-721 and ERC-1155, and enabling the aggregation of NFTs on old protocols into newly modularized ones. 

## Specification

ERC-3664 extends ERC-1155, divides NFT attributes into five categories:

1. General changeable attributes: usually refers to basic attributes such as ATK and DEF. Its functions include increase or decrease in attribute value.
2. Transferable attributes: refers to the NFT's transferable attributes can be transferred to other NFTs in the event of destruction or other circumstances.
3. Upgradeable attributes: refers to the NFT that can be upgraded according to the formula, the player pays the fee, and it is reflected in the increase of the level, usually accompanied by the increase of other attribute values.
4. Combinable, NFTs can be combined with other NFTs, to make all NFT world combinable and separatable, each NFT is a component of other NFTs, freely combine to make greater value.
5. Evolvable attribute: refers to the attribute that NFT may evolve automatically over time (the height of the chain block), simulate the time attributes in the real world, so that NFT has the characteristics of time-varying.

```solidity
function remove(uint256 _nftId, uint256 _attrId) external;
```

Remove the attribute from NFT. only called by contract operator.

- Param1: attribute owned id 
- Param2：attribute id

### IGenericAttribute

```
pragma solidity ^0.8.0;

interface IGenericAttribute {
    /**
     * @dev Returns the name of the attribute .
     */
    function name(uint256 _attrId) external view returns (string memory);

    /**
     * @dev Returns the description of the attribute.
     */
    function description(uint256 _attrId) external view returns (string memory);

    /**
     * @dev Returns the attributes of the nft.
     */
    function getNFTAttrs(uint256 _nftId) external view returns (uint256[] memory);

    /**
     * @dev Returns the decimals places of the attribute.
     */
    function attributeDecimals(uint256 _attrId) external view returns (uint8);

    /**
     * @dev Returns the value of the attribute.
     */
    function attributeValue(uint256 _nftId, uint256 _attrId) external view returns (uint256);

    /**
     * @dev Create new attribute.
     */
    function create(uint256 _id, string memory _name, string memory _description, uint8 _decimals) external;

    /**
     * @dev Attach the attribute to NFT.
     */
    function attach(uint256 _nftId, uint256 _attrId,  uint256 amount) external;

    /**
     * @dev Remove the attribute from NFT.
     */
    function remove(uint256 _nftId, uint256 _attrId) external;

    /**
     * @dev Increase the attribute value.
     */
    function increase(uint256 _nftId, uint256 _attrId, uint256 _amount) external;

    /**
     * @dev Decrease the attribute value.
     */
    function decrease(uint256 _nftId, uint256 _attrId, uint256 _amount) external;

    event GenericAttributeCreated(string name, uint256 id);
    event GenericAttributeAttached(uint256 nftId, uint256 attrId, uint256 amount);
    event GenericAttributeRemoved(uint256 nftId, uint256 attrId);
    event GenericAttributeIncrease(uint256 nftId, uint256 attrId, uint256 amount);
    event GenericAttributeDecrease(uint256 nftId, uint256 attrId, uint256 amount);
}

```

`increase` function

```solidity
function increase(uint256 _nftId, uint256 _attrId, uint256 _amount) external;
```

Increase the attribute value.  only called by contract operator.

- Param1：attribute owned id 
- Param2：attribute id
- Param3：increased attribute value

`decrease` function

```solidity
function decrease(uint256 _nftId, uint256 _attrId,  uint256 amount) external;
```

Decrease the attribute value.only called by contract operator.

- Param1：attribute owned id 
- Param2：attribute id
- Param3：decreased attribute value

### ITransferableAttribute

```
pragma solidity ^0.8.0;

interface ITransferableAttribute {
    /**
     * @dev Returns the name of the attribute .
     */
    function name(uint256 _attrId) external view returns (string memory);

    /**
     * @dev Returns the description of the attribute.
     */
    function description(uint256 _attrId) external view returns (string memory);

    /**
     * @dev Returns the attributes of the nft.
     */
    function getNFTAttrs(uint256 _nftId) external view returns (uint256[] memory);

    /**
     * @dev Returns the decimals places of the attribute.
     */
    function attributeDecimals(uint256 _attrId) external view returns (uint8);

    /**
     * @dev Returns the value of the attribute.
     */
    function attributeValue(uint256 _nftId, uint256 _attrId) external view returns (uint256);

    /**
     * @dev Create new attribute.
     */
    function create(uint256 _id, string memory _name, string memory _description, uint8 _decimals) external;

    /**
     * @dev Attach the attribute to NFT.
     */
    function attach(uint256 _nftId, uint256 _attrId,  uint256 amount) external;

    /**
     * @dev Remove the attribute from NFT.
     */
    function remove(uint256 _nftId, uint256 _attrId) external;

    /**
     * @dev Approve the attribute to another NFT.
     */
    function approve(uint256 _from, uint256 _to, uint256 _attrId) external;

    /**
     * @dev If there are Approved attributes, they can be transferred to NFT.
     */
    function transferFrom(uint256 _from, uint256 _to, uint256 _attrId) external;

    event TransferableAttributeCreated(string name, uint256 id);
    event TransferableAttributeAttached(uint256 nftId, uint256 attrId, uint256 amount);
    event TransferableAttributeApproval(uint256 from, uint256 to, uint256 attrId);
    event TransferableAttributeRemoved(uint256 nftId, uint256 attrId);
    event TransferableAttributeTransfer(uint256 from, uint256 to);
}


```

`approve` function

```solidity
function approve(uint256 _from, uint256 _to, uint256 _attrId) external;
```

Approve the attribute to another NFT.  only called by nft creator .

- Param1：attribute owned id
- Param2：attribute recipient id
- Param3：attribute id

`transferFrom` function

```solidity
function transferFrom(uint256 _from, uint256 _to, uint256 _attrId) external;
```

Decrease the attribute value.only called by contract operator.

- Param1：attribute owned id
- Param2：attribute recipient id
- Param3：attribute id

### IUpgradableAttribute

```
pragma solidity ^0.8.0;

interface IUpgradableAttribute {
    /**
     * @dev Returns the name of the attribute .
     */
    function name(uint256 _attrId) external view returns (string memory);

    /**
     * @dev Returns the description of the attribute.
     */
    function description(uint256 _attrId) external view returns (string memory);

    /**
     * @dev Returns the attributes of the nft.
     */
    function getNFTAttrs(uint256 _nftId) external view returns (uint256[] memory);

    /**
     * @dev Returns the max level of the attributes.
     */
    function maxLevel(uint256 _attrId) external view returns (uint8);

    /**
     * @dev Returns the max sub level of the attributes.
     */
    function maxSubLevel(uint256 _attrId) external view returns (uint8);

    /**
     * @dev Create new attribute.
     */
    function create(uint256 _id, string memory _name, string memory _description, uint8 _level, uint8 _subLevel) external;

    /**
     * @dev Attach the attribute to NFT.
     */
    function attach(uint256 _nftId, uint256 _attrId) external;

    /**
     * @dev Remove the attribute from NFT.
     */
    function remove(uint256 _nftId, uint256 _attrId) external;

    /**
     * @dev attribute upgrade level for nft.
     */
    function upgradeLevel(uint256 _nftId, uint256 _attrId, uint8 _level) external;

    /**
     * @dev attribute upgrade sub level for nft.
     */
    function upgradeSubLevel(uint256 _nftId, uint256 _attrId, uint8 _subLevel) external;

    event UpgradableAttributeCreated(string name, uint256 id);
    event UpgradableAttributeAttached(uint256 nftId, uint256 attrId);
    event UpgradableAttributeRemoved(uint256 nftId, uint256 attrId);
    event AttributeLevelUpgraded(uint256 nftId, uint256 attrId, uint8 level);
    event AttributeSubLevelUpgraded(uint256 nftId, uint256 attrId, uint8 subLevel);
}


```

`upgradeLevel` function

```solidity
function upgradeLevel(uint256 _nftId, uint256 _attrId, uint8 _level) external;
```

Attribute upgrade level for nft.  only called by contract operator.

- Param1：attribute owned id
- Param2：attribute recipient id
- Param3：attribute level

`upgradeSubLevel` function

```solidity
function upgradeSubLevel(uint256 _nftId, uint256 _attrId, uint8 _subLevel) external;
```

Attribute upgrade sub level for nft. only called by contract operator.

- Param1：attribute owned id
- Param2：attribute recipient id
- Param3：attribute sub level

### IEvolutiveAttribute

```
pragma solidity ^0.8.0;

interface IEvolutiveAttribute {
    /**
     * @dev Returns the name of the attribute .
     */
    function name(uint256 _attrId) external view returns (string memory);

    /**
     * @dev Returns the description of the attribute.
     */
    function description(uint256 _attrId) external view returns (string memory);

    /**
     * @dev Returns the attributes of the nft.
     */
    function getNFTAttrs(uint256 _nftId) external view returns (uint256[] memory);

    /**
     * @dev Returns the max level of the attribute.
     */
    function maxLevel(uint256 _attrId) external view returns (uint8);

    /**
     * @dev Create new attribute.
     */
    function create(
        uint256 _id,
        string memory _name,
        string memory _description,
        uint8 _level,
        uint8[] memory _probabilities,
        uint256[] memory _block_intervals
    ) external;

    /**
     * @dev Attach the attribute to NFT.
     */
    function attach(uint256 _nftId, uint256 _attrId) external;

    /**
     * @dev Remove the attribute from NFT.
     */
    function remove(uint256 _nftId, uint256 _attrId) external;

    /**
     * @dev Evolutive the attribute of the NFT.
     */
    function evolutive(uint256 _nftId, uint256 _attrId, uint8 _level) external;

    /**
     * @dev Evolution has the probability to damage the NFT, if it is damaged, it can be repaired.
     */
    function repair(uint256 _nftId, uint256 _attrId) external;

    event EvolutiveAttributeCreated(string name, uint256 id);
    event EvolutiveAttributeAttached(uint256 nftId, uint256 attrId);
    event EvolutiveAttributeRemoved(uint256 nftId, uint256 attrId);
    event AttributeEvolutive(uint256 nftId, uint256 attrId, uint8 level);
    event AttributeRepaired(uint256 nftId, uint256 attrId);
}


```

`evolutive` function

```solidity
function evolutive(uint256 _nftId, uint256 _attrId, uint8 _level) external;
```

Evolutive the attribute of the NFT.  only called by nft creator.

- Param1：attribute owned id
- Param2：attribute recipient id
- Param3：attribute level

`repair` function

```solidity
function repair(uint256 _nftId, uint256 _attrId) external;
```

Evolution has the probability to damage the NFT, if it is damaged, it can be repaired. only called by nft creator.

- Param1：attribute owned id
- Param2：attribute recipient id
- Param3：attribute sub level

## Backward Compatibility
The EIP-3664 standard can plug into existing ERC-721 and ERC-1155 interfaces (接口), and regard them as part of the modularized NFT, which uses EIP-3664 to extend and aggregate.

Thus any contract that has already deployed ERC-721 and ERC-1155 could be extended, assembled and disaggregated with EIP-3664.

## Test Cases

[gNFT/test at main · DRepublic-io/gNFT (github.com)](https://github.com/DRepublic-io/gNFT/tree/main/test)

## Reference Implementation
https://github.com/DRepublic-io/drepublic-contracts

## Security Considerations
Since the owner becomes vacuous after every ERC-721 is aggregated by EIP-3664, and since each contract only allows the contract owner to invoke functions in contract，ERC-721 and ERC-1155 aggregated by EIP-3664 are guaranteed to be safe.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
