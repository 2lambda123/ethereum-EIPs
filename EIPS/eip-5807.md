---
eip: 5807
title: Complex Numbers stored in Bytes32 types
description: Store real and imaginary parts of complex numbers in the lower 16 bytes and upper 16 bytes respectively of a bytes32 type.
author: Paul Edge (@genkifs)
discussions-to: https://ethereum-magicians.org/t/TBC
status: Draft
type: Standards Track
category: ERC
created: 2022-10-29
---
 
## Abstract

This EIP proposes a natural way for complex numbers to be stored in the bytes32 data-type.

## Motivation

This EIP proposes to package both the real and imaginary within one existing data type, Bytes32.  This allows compact storage without the need for structures and facilitates easy library implementations.  The bytes32 would remain available for existing, non-complex uses.

## Specification

A complex number would be defined as Bytes32 and initalized with the `cnNew` function and converted back with `RealIm`, both given below.

## Rationale

Only the split is defined in this EIP.  Manipulation of complex numbers (addition, multiplication etc.), number of decimal places and other such topics are left for other EIP discussions.

By defining real numbers in the lower 16bytes this allows direct conversion from positive int to bytes32 for positive real values less than 2**127.  

Direct conversion back from bytes32 -> uint -> int is not recommended as the bytes32 may contain imaginary parts and/or the real part may be negative.  Better to always use `RealIm` for seperating the complex part.  

Libraries for complex number manipulation can be implemented with the `Using Complex for bytes32` syntax where `Complex` is the name of the library.  

## Backwards Compatibility
There is no impact on other uses of the `bytes32` datatype.

## Reference Implementation
To create a complex number one would use

```JavaScript

	function cnNew(int128 _Real, int128 _Imag) public pure returns (bytes32){
        bytes32 Imag32 = bytes16(uint128(_Imag));
        bytes32 Real32 = bytes16(uint128(_Real));
        return (Real32>> 128) | Imag32; 
	}

```
and to convert back

```JavaScript

	function RealIm(bytes32 _cn)  public pure returns (int128 Real, int128 Imag){
	bytes16[2] memory tmp = [bytes16(0), 0];
	assembly {
	    mstore(tmp, _cn)
	    mstore(add(tmp, 16), _cn)
	}
	Imag=int128(uint128(tmp[0]));
	Real=int128(uint128(tmp[1]));
	}
	
```

## Security Considerations
If complex numbers are manipulated in bytes32 form then overflow checks must be performed manually during the manipulation.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
