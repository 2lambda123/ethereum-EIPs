---
eip: 6963
title: Multi Injected Provider Discovery
description: Using JavaScript window events to announce injected Wallet Providers to Dapps
author: Pedro Gomes (@pedrouid), Kosala Hemachandra (@kvhnuke), Richard Moore (@ricmoo), Gregory Markou (@GregTheGreek), Kyle Den Hartog (@kdenhartog), Glitch (@glitch-txs), Jake Moxey (@jxom), Pierre Bertet (@bpierre), Darryl Yeo (@darrylyeo), Yaroslav Sergievsky (@everdimension)
discussions-to: https://ethereum-magicians.org/t/eip-6963-multi-injected-provider-discovery/14076
status: Last Call
last-call-deadline: 2023-10-10
type: Standards Track
category: Interface
created: 2023-05-01
requires: 1193
---

## Abstract

Using JavaScript `window` events as an alternative discovery mechanism to [EIP-1193][EIP-1193] provider objects injected to `window.ethereum`, enabling Dapps to discover and interact with multiple Wallet Providers in the same webpage session.

## Motivation

Currently, many Wallet Providers offer a browser extension that injects an [EIP-1193][EIP-1193] provider object to the global JavaScript variable `window.ethereum`; however, this creates conflicts for users that have more than one browser extension installed.

In a given webpage session, browser extensions may be loaded in an unpredictable and unstable order, resulting in a race condition where the [EIP-1193][EIP-1193] provider object at `window.ethereum` is overwritten. Thus, a given Wallet Provider may not be available to a Dapp via `window.ethereum` at all times; instead, the last Wallet Provider to execute its injected content script usually "wins".

This not only results in a degraded user experience but also presents a barrier to entry for new Wallet Providers, as users are forced to activate or install only one browser extension at a time.

Some browser extensions attempt to counteract this problem by delaying their write to `window.ethereum`, which creates an unfair competition for Wallet Providers and hinders interoperability.

In this proposal, we present a solution to reduce barriers to entry for new Wallet Providers, foster fairer competition and interoperability between multiple Wallet Providers, and enhance the user experience for Dapps on Ethereum networks by allowing users to freely select their Wallet Provider of choice.

This is achieved through a set of standardized JavaScript `window` events, establishing a two-way communication protocol between client-side Ethereum libraries used by Dapps and content scripts injected by browser extensions.

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in [RFC-2119].

### Definitions

Wallet Provider: A user agent that manages keys and facilitates transactions with Ethereum via a browser extension.

Decentralized Application (Dapp): A webpage that relies upon one or more web3 platform APIs which are exposed to the webpage by the Wallet Provider (via an injected content script).

Wallet Provider Discovery Library: A library or piece of software that enables a Dapp to discover and interact with one or more Wallet Providers.

### Wallet Provider info

An EIP-6963 compliant Wallet Provider MUST announce itself with an `Eip6963ProviderInfo` object. The following values in the `Eip6963ProviderInfo` interface MUST be included within the object:

- **`uuid`** - a [UUIDv4][RFC-4122] compliant globally unique identifier for the Wallet Provider. The cryptographic uniqueness provided by [UUIDv4][RFC-4122] guarantees that any two `Eip6963ProviderInfo` objects discovered by the Dapp during the lifetime of the page can be uniquely identified, even if other properties (defined below) match.
- **`name`** - a human-readable local alias of the Wallet Provider to be displayed to the user by the Dapp. (e.g. `Example Wallet Extension` or `Awesome Example Wallet`)
- **`icon`** - a [URI][RFC-3986] referencing an image to represent the Wallet Provider. The image SHOULD be a square with 96x96px minimum resolution. See [Icon images](#icon-images) below for additional requirements.
- **`rdns`** - a registered domain name from the Domain Name System associated with the Wallet Provider, in reverse domain name notation (e.g `com.example.subdomain`). It is RECOMMENDED this identifier remain the same throughout the development of the Wallet Provider. See [RDNS identifiers](#rdns-identifiers) below for additional requirements.

```typescript
/**
 * The information needed for a Dapp to identify and display a Wallet Provider
 */
interface Eip6963ProviderInfo {
  uuid: string;
  name: string;
  icon: string;
  rdns: string;
}
```

The `Eip6963ProviderInfo` object MAY also be extended with additional properties. If a Dapp does not recognize the additional properties, it SHOULD ignore them.

#### Icon images

The `icon` string MUST be a data URI as defined in [RFC-2397]. The image SHOULD be a square with a minimum resolution of 96x96px. The image format is RECOMMENDED to be either lossless or vector-based such as PNG, WebP or SVG to make it easily renderable by the Dapp.

URI-encoded images are flexible and allow for multiple protocols for fetching and rendering icons, for example:

```sh
# SVG (data URI)
data:image/svg+xml,<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32px" height="32px" viewBox="0 0 32 32"><circle fill="red" cx="16" cy="16" r="12"/></svg>
# PNG (data URI)
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==
```

Since SVG images can execute JavaScript, Dapps and Wallet Provider Discovery Libraries MUST NOT embed the `<svg>` tag as-is. Instead, they SHOULD render SVG images using the `<img>` tag or equivalent means to ensure no untrusted JavaScript execution can occur.

#### RDNS identifiers

The `rdns` (reverse-DNS) property serves as an identifier which Dapps can rely on to be stable between page sessions. The Reverse Domain Name Notation is chosen to prevent namespace collisions. The domain should be controlled by the Wallet Provider and be followed by a subdomain or a product name. Example: `com.example.MyBrowserWallet`.

- The `rdns` value MUST BE a valid [RFC-1034] Domain Name;
- The domain part of the `rdns` value SHOULD be an active domain controlled by the Wallet Provider;
- Dapps MAY reject Wallet Providers which do not follow the Reverse-DNS convention correctly;
- Dapps SHOULD NOT use the `rnds` value for feature detection, as these are self-attested and prone to impersonation or bad incentives without an additional verification mechanism; feature-discovery and verification are both out of scope of this interface specification.

Note that similar to a user agent string in browsers, the supplied value may be unknown, invalid, incorrect, or attempt to spoof a domain associated with a different Wallet Provider. Therefore, the Dapp SHOULD be able to handle these failure cases with minimal degradation to functionality.

### Wallet Provider announcement detail

The `Eip6963ProviderDetail` is used as a composition interface to announce a Wallet Provider's [EIP-1193][EIP-1193] provider object and related metadata. The `Eip6963ProviderDetail` MUST contain an `info` property of type `Eip6963ProviderInfo` and a `provider` property of type `Eip1193Provider` defined by [EIP-1193][EIP-1193].

```typescript
interface Eip6963ProviderDetail {
  info: Eip6963ProviderInfo;
  provider: Eip1193Provider;
}
```

### Events

Each Dapp and Wallet Provider are expected to emit an event and instantiate an event listener. This forms an event-driven concurrency loop that efficiently facilitates Wallet Provider discovery without namespace collisions.

There are two event interfaces used by the Dapp and Wallet to discover each other. Since the Dapp code and Wallet Provider code aren't guaranteed to run in a particular order, the events are designed to handle such race conditions.

#### Dispatching/observing events

Both Dapps and Wallet Providers MUST use the `window.dispatchEvent()` function to emit events and MUST use the `window.addEventListener()` function to observe events.

#### Wallet Provider: `eip6963:announceProvider` event

The `Eip6963AnnounceProviderEvent` MUST be a `CustomEvent` object with a `type` property containing a string value of `"eip6963:announceProvider"` and a `detail` property with an object value of type `Eip6963ProviderDetail`. The `Eip6963ProviderDetail` object SHOULD be frozen with `Object.freeze()`.

```typescript
// "Announce" event dispatched by a Wallet Provider
interface Eip6963AnnounceProviderEvent extends CustomEvent {
  type: "eip6963:announceProvider";
  detail: Eip6963ProviderDetail;
}
```

#### Dapp: `eip6963:requestProvider` event

The `Eip6963RequestProviderEvent` MUST be an `Event` (or `CustomEvent`) object with a `type` property containing a string value of `"eip6963:requestProvider"`.

```typescript
// "Request" event dispatched by a Dapp
interface Eip6963RequestProviderEvent extends Event {
  type: "eip6963:requestProvider";
}
```

### Event loop

The Wallet Provider MUST announce the `eip6963:announceProvider` event to the Dapp via the `window.dispatchEvent()` method. The Wallet Provider MUST add an event listener to catch an `eip6963:requestProvider` event dispatched from the Dapp. This event listener MUST use a handler that will re-dispatch an `eip6963:announceProvider` event.

This re-announcement by the Wallet Provider is useful for when a Wallet's initial announcement event may have been delayed or fired before the Dapp had initialized its event listener. This allows the various Wallet Providers to react to the Dapp without polluting the `window.ethereum` namespace, which can produce non-deterministic behavior such as different wallets connecting each time.

The Wallet Provider dispatches the `eip6963:announceProvider` event with immutable contents and listens to the `eip6963:requestProvider` event:

```typescript
let info: Eip6963ProviderInfo;
let provider: Eip1193Provider;

const announceEvent: Eip6963AnnounceProviderEvent = new CustomEvent(
  "eip6963:announceProvider",
  { detail: Object.freeze({ info, provider }) }
);

// The Wallet Provider dispatches an `eip6963:announceProvider` event
// which is heard by the Dapp's event listener (initialized earlier)
window.dispatchEvent(announceEvent);

// The Wallet Provider listens for `eip6963:requestProvider` events (which may be dispatched at any later time)
// and re-dispatches the `eip6963:announceProvider` event in turn
window.addEventListener("eip6963:requestProvider", () => {
  window.dispatchEvent(announceEvent);
});
```

The Dapp MUST listen for the `eip6963:announceProvider` event dispatched by the Wallet via the `window.addEventListener()` method and MUST NOT remove the event listener for the lifetime of the page session in order to continue handling events beyond the initial page load interaction. The Dapp MUST dispatch the `eip6963:requestProvider` via the `window.dispatchEvent()` method after the `eip6963:announceProvider` handler has been initialized.

```typescript
// The Dapp listens for announced Wallet Providers
window.addEventListener(
  "eip6963:announceProvider",
  (event: Eip6963AnnounceProviderEvent) => {}
);

// The Dapp dispatches a `eip6963:requestProvider` event
// which is heard by Wallet Provider's event listener (initialized earlier)
window.dispatchEvent(new Event("eip6963:requestProvider"));
```

The Dapp MAY elect to persist the `Eip6963ProviderDetail` objects announced by multiple Wallet Providers. Thus, if the user wishes to utilize a different Wallet Provider within the same page session, the user can express this intent within the Dapp's interface, and the Dapp can immediately elect to send transactions to the newly-chosen Wallet Provider. Additionally, the Dapp MAY re-initiate the Wallet Provider discovery flow at any time by dispatching a new `eip6963:requestProvider` event, potentially discovering a different set of Wallet Providers.

The orchestration of events described above guarantees that the Dapp is able to discover the Wallet Provider, regardless of whether the Wallet Provider code or the Dapp code executes first.

## Rationale

The previous proposal introduced mechanisms that relied on a single, mutable window object that could be overwritten by multiple parties. We opted for an event-based approach to avoid the race conditions, the namespace collisions, and the potential for "pollution" attacks on a shared mutable object; the event-based orchestration creates a bidirectional communication channel between Wallet Provider and Dapp that can be re-orchestrated over time.

To follow the JavaScript event name conventions, the names are written in present tense and are prefixed with the number of this document (`Eip6963`). 

### Interfaces

Standardizing an interface for provider information (`Eip6963ProviderInfo`) allows a Dapp to determine all information necessary to populate a user-friendly Wallet Provider selection modal. This is particularly useful for Dapps that rely on libraries such as Web3Modal, RainbowKit, Web3-Onboard, or ConnectKit to programmatically generate such selection modals.

Regarding the announced provider interface (`Eip6963ProviderDetail`), it was important to leave the [EIP-1193][EIP-1193] provider interface untouched for backwards compatibility; this allows conformant Dapps to interface with Wallet Providers conforming to either, and for Wallet Providers conformant to this spec to still inject [EIP-1193][EIP-1193] providers for legacy Dapps. Note that a legacy Dapp or a Dapp conformant with this spec connecting to a legacy Wallet Provider cannot guarantee the correct Wallet Provider will be selected if multiple are present.

## Backwards Compatibility

This EIP doesn't require supplanting `window.ethereum`, so it doesn't directly break existing applications that cannot update to this method of Wallet Provider discovery. However, it is RECOMMENDED Dapps implement EIP-6963 to ensure discovery of multiple Wallet Providers and SHOULD disable `window.ethereum` usage except as a fail-over when discovery fails. Similarly, Wallet Providers SHOULD keep compatibility of `window.ethereum` to ensure backwards compatibility for Dapps that have not implemented EIP-6963. In order to prevent the previous issues of namespace collisions, it's also RECOMMENDED that Wallet Providers inject their provider object under a wallet specific namespace then proxy the object into the `window.ethereum` namespace.

## Reference Implementation

### Wallet Provider

Here is a reference implementation for an injected script by a Wallet Provider to support this new interface in parallel with the existing pattern.

```typescript
function onPageLoad() {
  let provider: Eip1193Provider;

  window.ethereum = provider;

  function announceProvider() {
    const info: Eip6963ProviderInfo = {
      uuid: "350670db-19fa-4704-a166-e52e178b59d2",
      name: "Example Wallet",
      icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'/>",
      rdns: "com.example.wallet"
    };

    window.dispatchEvent(
      new CustomEvent("eip6963:announceProvider", {
        detail: Object.freeze({ info, provider }),
      })
    );
  }

  window.addEventListener(
    "eip6963:requestProvider",
    (event: Eip6963RequestProviderEvent) => {
      announceProvider();
    }
  );

  announceProvider();
}
```

### Dapp implementation

Here is a reference implementation for a Dapp to display and track multiple Wallet Providers that are injected by browser extensions. 

```typescript
const providers: Eip6963ProviderDetail[];

function onPageLoad() {
  window.addEventListener(
    "eip6963:announceProvider",
    (event: Eip6963AnnounceProviderEvent) => {
      providers.push(event.detail);
    }
  );

  window.dispatchEvent(new Event("eip6963:requestProvider"));
}
```

## Security Considerations

### EIP-1193 security considerations

The security considerations of [EIP-1193][EIP-1193] apply to EIP-6963. Implementers are expected to consider and follow the guidance of the providers they're utilizing as well.

### Prototype pollution of Wallet Provider objects

Browser extensions, and therefore wallet extensions, are able to modify the contents of the page and the Provider object by design. The provider objects of various Wallet Providers are considered a highly trusted interface to communicate transaction data. In order to prevent the page or various other extensions from modifying the interaction between the Dapp and the Wallet Provider in an unexpected way, the best practice is to "freeze" the provider discovery object by utilizing `object.freeze()` on the  `Eip1193Provider` object before the Wallet Provider dispatches it in the `eip6963:announceProvider` Event. However, there are difficulties that can occur around web compatability where pages need to monkey patch the object. In scenarios like this there's a tradeoff that needs to be made between security and web compatibility that implementers of Wallet Providers are expected to consider.

### Wallet imitation and manipulation

Similarly so, Dapps are expected to actively detect for misbehavior of properties or functions being modified in order to tamper with or modify other Wallet Providers. One way this can be easily achieved is to look for when the `uuid` property within two `Eip6963ProviderInfo` objects match. Dapps and Dapp discovery libraries are expected to consider other potential methods that the `Eip6963ProviderInfo` objects are being tampered with and consider additional mitigation techniques to prevent this as well in order to protect the user.

### Prevent SVG JavaScript execution

The use of SVG images introduces a cross-site scripting risk as they can include JavaScript code. This JavaScript executes within the context of the page and can therefore modify the page or the contents of the page. So when considering the experience of rendering the icons, Dapps need to take into consideration how they'll approach handling these concerns in order to prevent an image being used as an obfuscation technique to hide malicious modifications to the page or to other wallets.

### Prevent wallet fingerprinting

One advantage to the concurrency Event loop utilized by this design is that it operates in a manner where either the Dapp or the Wallet Provider can initiate the flow to announce a provider. For this reason, implementers of Wallet Providers can now consider whether or not they wish to announce themselves to all pages or attempt alternative means in order to reduce the ability for a user to be fingerprinted by the injection of the `window.ethereum` object. Some examples of alternative flows to consider would be to wait to inject the Wallet Provider object until the Dapp has announced the `eip6963:requestProvider`. At that point, the wallet can initiate a UI consent flow to ask the user if they would like to share their wallet address. This allows for the Wallet Provider to enable the option of a "private connect" feature. However, if this approach is taken, Wallet Providers must also consider how they intend to support backwards compatibility with a Dapp that does not support EIP-6963.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).


[EIP-1193]: ./eip-1193.md
[RFC-1034]: https://www.rfc-editor.org/rfc/rfc1034
[RFC-2119]: https://www.rfc-editor.org/rfc/rfc2119
[RFC-2397]: https://www.rfc-editor.org/rfc/rfc2397
[RFC-3986]: https://www.rfc-editor.org/rfc/rfc3986
[RFC-4122]: https://www.rfc-editor.org/rfc/rfc4122
