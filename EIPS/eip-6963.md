---
eip: 6963
title: Multi Injected Provider Discovery
description: Using window events to announce injected Wallet Providers
author: Pedro Gomes (@pedrouid), Kosala Hemachandra (@kvhnuke), Richard Moore (@ricmoo), Gregory Markou (@GregTheGreek), Kyle Den Hartog (@kdenhartog), Glitch (@glitch-txs), Jake Moxey (@jxom), Pierre Bertet (@bpierre), Darryl Yeo (@darrylyeo), Yaroslav Sergievsky (@everdimension)
discussions-to: https://ethereum-magicians.org/t/eip-6963-multi-injected-provider-discovery/14076
status: Last Call
last-call-deadline: 2023-10-10
type: Standards Track
category: Interface
created: 2023-05-01
requires: 1193
---

## Abstract

An alternative discovery mechanism to `window.ethereum` for [EIP-1193][EIP-1193] providers which supports discovering multiple injected Wallet Providers in a webpage using JavaScript's `window` events.

## Motivation

Currently, Wallet Providers that offer browser extensions must inject their Ethereum providers ([EIP-1193][EIP-1193]) into the same window object `window.ethereum`; however, this creates conflicts for users that may install more than one browser extension.

Browser extensions are loaded in the webpage in an unpredictable and unstable order, resulting in a race condition where the user does not have control over which Wallet Provider is selected to expose the Ethereum interface under the `window.ethereum` object. Instead, the last wallet to load usually wins.

This results not only in a degraded user experience but also increases the barrier to entry for new browser extensions as users are forced to only install one browser extension at a time.

Some browser extensions attempt to counteract this problem by delaying their injection to overwrite the same `window.ethereum` object which creates an unfair competition for Wallet Providers and lack of interoperability.

In this proposal, we present a solution that focuses on optimizing the interoperability of multiple Wallet Providers. This solution aims to foster fairer competition by reducing the barriers to entry for new Wallet Providers, along with enhancing the user experience on Ethereum networks.

This is achieved by introducing a set of window events to provide a two-way communication protocol between Ethereum libraries and injected scripts provided by browser extensions thus enabling users to select their wallet of choice.

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in [RFC-2119].

### Definitions

Wallet Provider: A user agent that manages keys and facilitates transactions with Ethereum.

Decentralized Application (Dapp): A webpage that relies upon one or more web3 platform APIs which are exposed to the webpage via the Wallet Provider.

Provider Discovery Library: A library or piece of software that assists a Dapp to interact with the Wallet Provider. 

### Provider info

Each Wallet Provider will be announced with the following interface `Eip6963ProviderInfo`. The values in the `Eip6963ProviderInfo` MUST be included within the `Eip6963ProviderInfo` object. The `Eip6963ProviderInfo` MAY also include extra extensible properties within the object. If a Dapp does not recognize the additional properties, it SHOULD ignore them.

- **`uuid`** - a globally unique identifier the Wallet Provider that MUST be ([UUIDv4][RFC-4122] compliant) to uniquely distinguish different [EIP-1193][EIP-1193] provider sessions that have matching properties defined below during the liftetime of the page. The cryptographic uniqueness provided by [UUIDv4][RFC-4122] guarantees that two independent `Eip6963ProviderInfo` objects can be separately identified.
- **`name`** - a human-readable local alias of the Wallet Provider to be displayed to the user on the Dapp. (e.g. `Example Wallet Extension` or `Awesome Example Wallet`)
- **`icon`** - a [URI][RFC-3986] pointing to an image. The image SHOULD be a square with 96x96px minimum resolution. See the [Images/Icons](#imagesicons) below for further requirements of this property.
- **`rdns`** - The Wallet Provider MUST supply the `rdns` property which is intended to be a domain name from the Domain Name System in reverse syntax ordering such as `com.example.subdomain`. It's up to the Wallet Provider to determine the domain name they wish to use, but it's generally expected the identifier will remain the same throughout the development of the Wallet Provider. It's also worth noting that similar to a user agent string in browsers, there are times where the supplied value could be unknown, invalid, incorrect, or attempt to imitate a different Wallet Provider. Therefore, the Dapp SHOULD be able to handle these failure cases with minimal degradation to the functionality of the Dapp.

```typescript
/**
 * Represents the assets needed to display a Wallet Provider
 */
interface Eip6963ProviderInfo {
  uuid: string;
  name: string;
  icon: string;
  rdns: string;
}
```

#### Images/icons

A URI-encoded image was chosen to enable flexibility for multiple protocols for fetching and rendering icons, for example:

```sh
# SVG (data URI)
data:image/svg+xml,<svg version="1.1" xmlns="http://www.w3.org/2000/svg" width="32px" height="32px" viewBox="0 0 32 32"><circle fill="red" cx="16" cy="16" r="12"/></svg>
# PNG (data URI)
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==
```

The `icon` string MUST be a data URI as defined in [RFC-2397]. The image SHOULD be a square with 96x96px minimum resolution. The image format is RECOMMENDED to be either lossless or vector based such as PNG, WebP or SVG to make the image easy to render on the Dapp. Since SVG images can execute JavaScript, applications and libraries MUST render SVG images using the `<img>` tag to ensure no untrusted JavaScript execution can occur.

#### RDNS

The **`rdns`** (Reverse-DNS) property serves to provide an identifier which Dapps can rely on to be stable between sessions. The Reverse Domain Name Notation is chosen to prevent namespace collisions.
The Reverse-DNS convention implies that the value should start with a reversed DNS domain name controlled by the Provider. The domain name should be followed by a subdomain or a product name. Example: `com.example.MyBrowserWallet`.

- The `rdns` value MUST BE a valid [RFC-1034] Domain Name;
- The DNS part of the `rdns` value SHOULD BE an active domain controlled by the Provider;
- Dapps MAY reject the Providers which do not follow the Reverse-DNS convention correctly;
- Dapps SHOULD NOT use the `rnds` value for feature detection as these are self-attested and prone to impersonation or bad incentives without an additional verification mechanism; feature-discovery and verification are both out of scope of this interface specification.

### Provider detail

The `Eip6963ProviderDetail` is used as a composition interface to announce a Wallet Provider and related metadata about the Wallet Provider. The `Eip6963ProviderDetail` MUST contain an `info` property of type `Eip6963ProviderInfo` and a `provider` property of type `Eip1193Provider` defined by [EIP-1193][EIP-1193].

```typescript
interface Eip6963ProviderDetail {
  info: Eip6963ProviderInfo;
  provider: Eip1193Provider;
}
```

### Window events

In order to prevent provider collisions, the Dapp and the Wallet Provider are expected to emit an event and instantiate an eventListener to discover the various Wallet Providers. This forms an Event concurrency loop. 

Since the Dapp code and Wallet Provider code aren't guaranteed to run in a particular order, the events are designed to handle such race conditions.

To emit events, both Dapps and Wallet Provider MUST use the `window.dispatchEvent` function to emit events and MUST use the `window.addEventListener` function to observe events. There are two Event interfaces used for the Dapp and Wallet Provider to discover each other.

#### Announce and request events

The `Eip6963AnnounceProviderEvent` interface MUST be a `CustomEvent` object with a `type` property containing a string value of `eip6963:announceProvider` and a `detail` property with an object value of type `Eip6963ProviderDetail`. The `Eip6963ProviderDetail` object SHOULD be frozen by calling `Object.freeze()` on the value of the `detail` property.

```typescript
// Announce Event dispatched by a Wallet Provider
interface Eip6963AnnounceProviderEvent extends CustomEvent {
  type: "eip6963:announceProvider";
  detail: Eip6963ProviderDetail;
}
```

The `Eip6963RequestProviderEvent` interface MUST be an `Event` object with a `type` property containing a string value of `eip6963:requestProvider`.

```typescript
// Request Event dispatched by a Dapp
interface Eip6963RequestProviderEvent extends Event {
  type: "eip6963:requestProvider";
}
```

The Wallet Provider MUST announce the `Eip6963AnnounceProviderEvent` to the Dapp via a `window.dispatchEvent()` function call. The Wallet Provider MUST add an EventListener to catch an `Eip6963RequestProviderEvent` dispatched from the Dapp. This EventListener MUST use a handler that will re-dispatch an `Eip6963AnnounceProviderEvent`. This re-announcement by the Wallet Provider is useful for when a Wallet Provider's initial Event announcement may have been delayed or fired before the Dapp had initialized its EventListener. This allows the various Wallet Providers to react to the Dapp without the need to pollute the `window.ethereum` namespace which can produce non-deterministic behavior such as different wallets connecting each time.

The Wallet Provider dispatches the `"eip6963:announceProvider"` event with immutable contents and listens to the `"eip6963:requestProvider"` event:

```typescript
let info: Eip6963ProviderInfo;
let provider: Eip1193Provider;

const announceEvent: Eip6963AnnounceProviderEvent = new CustomEvent(
  "eip6963:announceProvider",
  { detail: Object.freeze({ info, provider }) }
);

// The Wallet Provider dispatches an announce event which is heard by
// the Dapp code that had run earlier
window.dispatchEvent(announceEvent);

// The Wallet Provider listens to the request events which may be
// dispatched later and re-dispatches the `Eip6963AnnounceProviderEvent`
window.addEventListener("eip6963:requestProvider", () => {
  window.dispatchEvent(announceEvent);
});
```

The Dapp MUST listen for the `Eip6963AnnounceProviderEvent` dispatched by the Wallet Provider via a `window.addEventListener()` method and MUST NOT remove the Event Listener for the lifetime of the page so that the Dapp can continue to handle Events beyond the initial page load interaction. The Dapp MUST dispatch the `Eip6963RequestProviderEvent` via a `window.dispatchEvent()` function call after the `Eip6963AnnounceProviderEvent` handler has been initialized.

```typescript
// The Dapp listens to announced providers
window.addEventListener(
  "eip6963:announceProvider",
  (event: Eip6963AnnounceProviderEvent) => {}
);

// The Dapp dispatches a request event which will be heard by 
// Wallet Provider's code that had run earlier
window.dispatchEvent(new Event("eip6963:requestProvider"));
```

The Dapp MAY elect to persist various `Eip6963ProviderDetail` objects contained in the  announcement events sent by multiple Wallet Providers. Thus, if the user wishes to utilize a different Wallet Provider over time, the user can express this within the Dapp's interface and the Dapp can immediately elect to send transactions to that new Wallet Provider. Otherwise, the Dapp MAY re-initiate the Wallet Provider discovery flow via dispatching a new `Eip6963RequestProviderEvent`, potentially discovering a different set of Wallet Providers.

The described orchestration of events guarantees that the Dapp is able to discover the Wallet Provider, regardless of which code executes first, the Wallet Provider code or the Dapp code.

## Rationale

The previous proposal introduced mechanisms that relied on a single, mutable window object that could be overwritten by multiple parties. We opted for an event-based approach to avoid the race conditions, the namespace collisions, and the potential for "pollution" attacks on a shared mutable object; the event-based orchestration creates a bidirectional communication channel between Wallet Provider and Dapp that can be re-orchestrated over time.

To follow the JavaScript event name conventions, the names are written in present tense and are prefixed with the number of this document (`Eip6963`). 

### Interfaces

Standardizing an interface for provider information (`Eip6963ProviderInfo`) allows a Dapp to determine all information necessary to populate a user-friendly Wallet Provider selection modal. This is particularly useful for Dapps that rely on libraries such as Web3Modal, RainbowKit, Web3-Onboard, or ConnectKit to programmatically generate such selection modals.

Regarding the announced provider interface (`Eip6963ProviderDetail`), it was important to leave the [EIP-1193][EIP-1193] provider interface untouched for backwards compatibility; this allows conformant Dapps to interface with Wallet Providers conforming to either, and for Wallet Providers conformant to this spec to still inject [EIP-1193][EIP-1193] providers for legacy Dapps. Note that a legacy Dapp or a Dapp conformant with this spec connecting to a legacy Wallet Provider cannot guarantee the correct Wallet Provider will be selected if multiple are present.

## Backwards Compatibility

This EIP doesn't require supplanting `window.ethereum`, so it doesn't directly break existing applications that cannot update to this method of Wallet Provider discovery. However, it is RECOMMENDED Dapps implement EIP-6963 to ensure discovery of multiple Wallet Providers and SHOULD disable `window.ethereum` usage except as a fail-over when discovery fails. Similarly, Wallet Providers SHOULD keep compatibility of `window.ethereum` to ensure backwards compatibility for Dapps that have not implemented EIP-6963. In order to prevent the previous issues of namespace collisions, it's also RECOMMENDED that Wallet Providers inject their provider object under a wallet specific namespace then proxy the object into the `window.ethereum` namespace.

## Reference Implementation

### Wallet Provider

Here is a reference implementation for an injected script by a Wallet Provider to support this new interface in parallel with the existing pattern.

```typescript
function onPageLoad() {
  let provider: Eip1193Provider;

  window.ethereum = provider;

  function announceProvider() {
    const info: Eip6963ProviderInfo = {
      uuid: "350670db-19fa-4704-a166-e52e178b59d2",
      name: "Example Wallet",
      icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'/>",
      rdns: "com.example.wallet"
};
    window.dispatchEvent(
      new CustomEvent("eip6963:announceProvider", {
        detail: Object.freeze({ info, provider }),
      })
    );
  }

  window.addEventListener(
    "eip6963:requestProvider",
    (event: Eip6963RequestProviderEvent) => {
      announceProvider();
    }
  );

  announceProvider();
}
```

### Dapp implementation

Here is a reference implementation for a Dapp to display and track multiple Wallet Providers that are injected by browser extensions. 

```typescript
const providers: Eip6963ProviderDetail[];

function onPageLoad() {

  window.addEventListener(
    "eip6963:announceProvider",
    (event: Eip6963AnnounceProviderEvent) => {
      providers.push(event.detail);
    }
  );

  window.dispatchEvent(new Event("eip6963:requestProvider"));
}
```

## Security Considerations

### EIP-1193 security considerations

The security considerations of [EIP-1193][EIP-1193] apply to EIP-6963. Implementers are expected to consider and follow the guidance of the providers they're utilizing as well.

### Prototype pollution of Wallet Provider objects

Browser extensions, and therefore wallet extensions, are able to modify the contents of the page and the Provider object by design. The provider objects of various Wallet Providers are considered a highly trusted interface to communicate transaction data. In order to prevent the page or various other extensions from modifying the interaction between the Dapp and the Wallet Provider in an unexpected way, the best practice is to "freeze" the provider discovery object by utilizing `object.freeze()` on the  `Eip1193Provider` object before the Wallet Provider dispatches it in the `eip6963:announceProvider` Event. However, there are difficulties that can occur around web compatability where pages need to monkey patch the object. In scenarios like this there's a tradeoff that needs to be made between security and web compatibility that implementers of Wallet Providers are expected to consider.

### Wallet imitation and manipulation

Similarly so, Dapps are expected to actively detect for misbehavior of properties or functions being modified in order to tamper with or modify other Wallet Providers. One way this can be easily achieved is to look for when the `uuid` property within two `Eip6963ProviderInfo` objects match. Dapps and Dapp discovery libraries are expected to consider other potential methods that the `Eip6963ProviderInfo` objects are being tampered with and consider additional mitigation techniques to prevent this as well in order to protect the user.

### Prevent SVG JavaScript execution

The use of SVG images introduces a cross-site scripting risk as they can include JavaScript code. This JavaScript executes within the context of the page and can therefore modify the page or the contents of the page. So when considering the experience of rendering the icons, Dapps need to take into consideration how they'll approach handling these concerns in order to prevent an image being used as an obfuscation technique to hide malicious modifications to the page or to other wallets.

### Prevent wallet fingerprinting

One advantage to the concurrency Event loop utilized by this design is that it operates in a manner where either the Dapp or the Wallet Provider can initiate the flow to announce a provider. For this reason, implementers of Wallet Providers can now consider whether or not they wish to announce themselves to all pages or attempt alternative means in order to reduce the ability for a user to be fingerprinted by the injection of the `window.ethereum` object. Some examples of alternative flows to consider would be to wait to inject the Wallet Provider object until the Dapp has announced the `eip6963:requestProvider`. At that point, the wallet can initiate a UI consent flow to ask the user if they would like to share their wallet address. This allows for the Wallet Provider to enable the option of a "private connect" feature. However, if this approach is taken, Wallet Providers must also consider how they intend to support backwards compatibility with a Dapp that does not support EIP-6963.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).


[EIP-1193]: ./eip-1193.md
[RFC-1034]: https://www.rfc-editor.org/rfc/rfc1034
[RFC-2119]: https://www.rfc-editor.org/rfc/rfc2119
[RFC-2397]: https://www.rfc-editor.org/rfc/rfc2397
[RFC-3986]: https://www.rfc-editor.org/rfc/rfc3986
[RFC-4122]: https://www.rfc-editor.org/rfc/rfc4122
