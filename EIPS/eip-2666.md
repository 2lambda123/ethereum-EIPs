---
eip: 2666
title: Repricing of precompiles and Keccak256 function, homogeneous error handling for precompiles
author: Alex Vlasov (@shamatar)
discussions-to: https://ethereum-magicians.org/t/eip2666-global-precompiles-repricing-and-many-more-discussion-thread/4332
status: Draft
type: Standards Track
category: Core
created: 2020-05-22
requires: 1352, 2046, 2565
---

<!--You can leave these HTML comments in your merged EIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new EIPs. Note that an EIP number will be assigned by an editor. When opening a pull request to submit your EIP, please use an abbreviated title in the filename, `eip-draft_title_abbrev.md`. The title should be 44 characters or less.-->

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Provide a simplified and layman-accessible explanation of the EIP.-->
This EIP tries to fix the problems with Ethereum precompiles and built-in EVM function:
- EIP-2046 changes a `STATICCALL` cost to precompile and it may be necessary to adjust costs of some precompiles that have taken old large cost (`700` gas) into account 
- Some precompiles are overpriced and their pricing formulas to not reflect the structure of underlying function
- Keccak256 built-in function in EVM has pricing that does not reflect underlying hash function structure
- Better specify behavior of how gas handled if the precompile call fails (DDoS handling behavior)

## Abstract
<!--A short (~200 word) description of the technical issue being addressed.-->
Costs of many precompiles and built-in functions are invalid at the current state of the clients. This EIP contains a list of changes to the pricing formulas to better reflect underlying computations' structure.

## Motivation
<!--The motivation is critical for EIPs that want to change the Ethereum protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the EIP solves. EIP submissions without sufficient motivation may be rejected outright.-->
Motivation is simple: make pricing formulas accurately reflect resources (CPU time) requires to actually perform the called computations.

## Specification
<!--The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Ethereum platforms (go-ethereum, parity, cpp-ethereum, ethereumj, ethereumjs, and [others](https://github.com/ethereum/wiki/wiki/Clients)).-->

This EIP proposes the following changes:
- Small running time to perform gas estimation for precompile call is absorbed into the precompile cost itself
- Precompiles are repricied as:
  - `SHA256` precompile (address `0x02`) was priced as `60` gas plus `12` gas per `32` bytes of input. Now it should be priced as `5 + ((len(input) + 8)/64 + 1) * 9`
    - Improvements in Rust implementation can allow to reduce price to `3 + ((len(input) + 8)/64 + 1) * 5` (both constant and length-dependent contributions)
  - RIPEMD precompile (address `0x03`) was priced as `600` gas plus `120` gas per `32` bytes of input. Now it should be priced as `6 + ((len(input) + 8)/64 + 1) * 12`
    - Improvements in Go implementation can allow to reduce price to `2 + ((len(input) + 8)/64 + 1) * 8` (both constant and length-dependent contributions)
  - `BNADD` precompile (address `0x06`) should be repriced from `150` gas to `350` gas
  - `BNMUL` precompile (address `0x07`) should be repriced from `6000` gas to `6300` gas
- Keccak256 built-in function was priced as `30` gas plus `6` gas per `32` bytes of the input. Now it should be priced as `13 + (len(input)/136 + 1)*15`
  - Improvements in Go implementation can allow to reduce price to `2 + (len(input)/136 + 1)*15` (constant contribution reduction)
- Client implementations of gas metering function SHOULD be implemented with efficiency in mind, e.g. use `uint64` type instead of `uint256` that is sufficient for all reasonable prices taking into the account gas limits in the block

This EIP requires that `MODEXP` repricing is [implemented](https://eips.ethereum.org/EIPS/eip-2565) to also accurately reflect that there is implicit compensation for an old `STATICCALL` cost (pre-2046).

### DDoS handling in precompile calls

Some of the precompiles (Blake2f and all BN254 curve related precompiles) require an input to be well-formed and can not operate on an arbitrary bytestring as an input. Right now behavior is that if precompile is called using `STATICCALL` with `X` gas supplied and precompile returns an error then all `X` gas is consumed. Such behavior is overzealous and in all the cases it's possible to put an upper bound on the execution of a well-designed precompile. So we have not many cases to cover and those are precompile specific and we'll cover them below in subsection. We should emphasize that there are no error cases for `SHA256` and `RIPEMD` precompiles, and there is no error case possible for Keccak256 at all as for EVM function.

The proposal itself is that now in case of precompile error **only some fixed and predefined gas must be consumed**. We cover specific cases below.

#### Blake2f error cases

Blake2f precompile has two error cases:
- input length is invalid
- invalid "final block" indicator flag

We propose that for all these cases precompile must consume it's minimal logical quant of gas that is `GFROUND = 1` constant.

#### BN254 curve related error cases

For all these precompiles (`BNADD`, `BNMUL` and `PAIR`) we can also split error cases into few large categories

- Input length is invalid for fixed input length precompile (`BNADD`, `BNMUL`)
- Input length is invalid for variable input length precompile (`PAIR`)
- Encoded data is not valid (while length is valid)

Let's cover them one by one:
- For `BNADD` and `BNMUL` precompiles if input length is invalid precompile should consume a normal precompile success-case gas cost
- For `PAIR` precompile if input length is then one should calculate `num_pairs = ceil(len(input)/192)` parameter and precompile should consume a success-case gas cost for such number of pairs. For an empty input length precompile should consume cost of one pair.
- For all `BNADD`, `BNMUL` and `PAIR` precompiles if error arises during other stages than input length validation precompile should consume a success-case gas cost for a corresponding number of pairs (for `PAIR` precompile) or a fixed cost operation (`BNADD`, `BNMUL`).

#### Proposed design of error handling routines

All various cases described above precompiles should implement two functions with a following signatures:

```
  function input_length_is_valid(uint256 input_length) returns (bool is_valid, uint256 gas_penalty, uint256 success_case_cost);
  function perform_computations(bytes memory input) returns (bool success, bytes memory output, uint256 gas_penalty);
```

First one should quickly validate input length and for fixed-length input precompiles will return `gas_penalty` equal to the success-case cost of the precompile if input length is invalid, and for variable-length input precompiles it will return `gas_penalty` according some policy (like ones described above).

Second one will perform true input validation and computations and MUST first validate the input and if input is not well-formed for further expensive computations and return `success = false` and some `gas_penalty` value for this case, and then continue computations to the end. If `success == false && gas_penalty == 0` then precompile call MUST consume a success-case gas cost for this input length that was returned by the previous function as `success_case_cost` parameter. 


## Rationale
<!--The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->

Cost of functions being executed must accurately reflect real CPU time spent on computations, so benchmarking was performed for current precompiles and Keccak256 function to measure running time versus input parameters. 

## Backwards Compatibility
<!--All EIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The EIP must explain how the author proposes to deal with these incompatibilities. EIP submissions without a sufficient backwards compatibility treatise may be rejected outright.-->
Precompile repricings has happened in a past and can be considered standard procedure. Gas costs of many contracts is expected to reduce that may break re-entrancy protection measures based on fixed gas costs. In any case, such protection should have never been considered good and final.

## Test Cases
<!--Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.-->
There are no explicit test cases.

## Implementation
<!--The implementations must be completed before any EIP is given status "Final", but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of "rough consensus and running code" is still useful when it comes to resolving many discussions of API details.-->

Reference material with raw data can be found [here](https://docs.google.com/spreadsheets/d/1aCQnk7prrp3Mbcf011BE5zZnkbc3Iw7QAixn6mLbKS0/edit?usp=sharing).


## Security Considerations
<!--All EIPs must contain a section that discusses the security implications/considerations relevant to the proposed change. Include information that might be important for security discussions, surfaces risks and can be used throughout the life cycle of the proposal. E.g. include security-relevant design decisions, concerns, important discussions, implementation-specific guidance and pitfalls, an outline of threats and risks and how they are being addressed. EIP submissions missing the "Security Considerations" section will be rejected. An EIP cannot proceed to status "Final" without a Security Considerations discussion deemed sufficient by the reviewers.-->

As described in backward compatibility section in some cases reduction of cost may allow e.g. re-entrancy that was not expected before, but we think that re-entrancy protection based on fixed gas costs is anyway flawed design decision.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
