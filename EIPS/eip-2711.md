---
eip: 2711
title: Sponsored, expiring and batch transactions.
author: Micah Zoltu (@MicahZoltu)
discussions-to: https://ethereum-magicians.org/t/eip-2711-separate-gas-payer-from-msg-sender/4353
status: Draft
type: Standards Track
category: Core
created: 2020-06-11
requires (*optional): 2718
---

## Simple Summary
Creates a new transaction type that supports sponsored transactions (separate gas payer from sender), batch transactions (multiple transactions executed in sequence), and expiring transactions (transactions which are not valid after a certain timestamp).

## Abstract
An EIP-2718 transactions with the type number `2` is a new type of transaction that includes support for:
1. **Sponsored Transactions**: an optional additional signature from which the account that will pay for gas (`GAS_PAYER`) can be recovered
2. **Batch Transactions**: multiple transactions from the same sender that will be executed in sequence
3. **Expiring Transactions**: an optional `validUntil` field that makes the transaction invalid after a certain point in time

## Motivation
### Sponsored Transactions
With the advent of tokens and especially stable coins, it has become common for users to not hold ETH in an account while they may have other assets of value in that account.  Some users don't want to be exposed to the perceived volatility of ETH and instead would prefer to transact using other assets.  Unfortunately, since gas **MUST** be paid for with ETH, this prevents the user from transacting with their assets without first acquiring some ETH using some other means, and then using that ETH to pay fees.

This EIP proposes a mechanism by which we can allow people to transact without ever having to own any ETH by allowing someone else to cover gas costs.  The arrangements that enable the covering of gas costs is out of scope for this EIP but it could be an extra-protocol monthly subscription, payment could occur as part of the transaction being submitted, the recpient may be willing to cover gas costs, or it could be a free service offered as a value-ad by a company that you are working with.

While it is possible to implement these sort of mechanisms at the individual contract layer, such solutions require integration by just about every contract and those solutions also end up depending on gas costs being stable with time in order to appropriately bake them into contracts without putting either party at risk of malicious participants in the system.  For this reason, it is deemed beneficial that separating out `GAS_PAYER` from `msg.sender` at the protocol layer is valuable.

### Batch Transactions
Often times an EOA may want to execute a series of transactions with a strong guarantee that they happen in order with nothing occurring between them.  For example, one may want to send some tokens to a contract and then follow that up with another transaction that makes a contract call on the destination address that causes those tokens to be registered to them.  By supporting transaction batching at layer 1, we can ensure that the user can get strong guarantees at signing time of cross-transaction atomicity.

### Expiring Transactions
* If any form of dust-account clearing is introduced, e.g. (https://github.com/ethereum/EIPs/issues/168), it will be necessary to introduce a replay protection, such as https://github.com/ethereum/EIPs/issues/169 . Having temporal replay protection removes the need to change nonce-behaviour in the state, since transactions would not be replayable at a later date than explicitly set by the user.
* In many cases, such as during ICOs, a lot of people want their transactions to either become included soon (within a couple of hours) or not at all. Currently, transactions are queued and may not execute for several days, at a cost for both the user (who ends up paying gas for a failing purchase) and the network, dealing with the large transaction queues.
* Node implementations have no commonly agreed metric for which transactions to keep, discard or propagate. Having a TTL on transactions would make it easier to remove stale transactions from the system.
Transaction expiration is optional in this EIP, 

## Specification
### Definitions
**`TransactionType`** 1.  See [EIP-2718](./eip-2718.md)

**`TransactionSubtype`** is either 1, 2, 3, or 4.

**`ChainId`** The transaction is valid if this value is `0` or it is included in a block on a chain whose ID is equal to this value.

**`ValidUntil`** The transaction is valid if this value is `0` or it is included in a block whose timestamp is less than or equal to this value.

**`YParity`** The parity (0 for even, 1 for odd) of the y-value of a secp256k1 signature.

**`SenderPayload`** Defined based on the `TransactionSubtype` as follows:
1. `[1, [to_0, value_0, data_0, ..., to_n, value_n, data_n], nonce, ChainId, ValidUntil, gasLimit, gasPrice]`
1. `[2, [to_0, value_0, data_0, ..., to_n, value_n, data_n], nonce, ChainId, ValidUntil, gasLimit, gasPrice]`
2. `[3, [to_0, value_0, data_0, ..., to_n, value_n, data_n], nonce, ChainId, ValidUntil, gasLimit]`
3. `[4, [to_0, value_0, data_0, ..., to_n, value_n, data_n], nonce, ChainId, ValidUntil]`

**`SenderSignature`** `[YParity, r, s]` of `secp256k1(keccak256(rlp([TransactionType, SenderPayload])))`

**`GasPayerPayload`** Defined based on the `TransactionSubtype` as follows:
1. `[]`
2. `[]`
3. `[gasPrice]`
4. `[gasLimit, gasPrice]`

**`GasPayerSignature`** is `[]` for `TransactionSubType` `1` or `[YParity, r, s]` of `secp256k1(keccak256(rlp([SenderPayload, SenderSignature, GasPayerPayload])))` for others.

### New Transaction Type

As of `FORK_BLOCK_NUMBER` an [EIP-2718](./eip-2718.md) transaction with a `TransactionType` of `1` will have its `Payload` interpreted as an RLP encoded tuple of:
```
[...SenderPayload, ...SenderSignature, ...GasPayerPayload, ...GasPayerSignature]
```

The address recovered from `SenderSignature` is the address...
1. ...returned by the `CALLER` opcode (0x33, aka `msg.sender`) during the first call frame of the transaction
2. ...returned by the `ORIGIN` opcode (0x32, aka `tx.origin`)
3. ...whose `nonce` is used
4. ...whose ETH balance is deducted if any value is attached to the transaction
5. ...whose ETH balance is deducted to pay for gas if `GasPayerSignature` is not present.

If `GasPayerSignature` is present, then the address recovered from it is the address...
1. ...whose ETH balance is deducted to pay for gas

The base gas cost of transactions of this type will be `BASE_GAS_PRICE` + `BASE_SUBTRANSACTION_GAS_PRICE` * `n-1`, rather than the base cost associated with transactions of type `0` and legacy transactions.

## Rationale
### One Monolithic EIP
This EIP could be split up into multiple EIPs, one for each of the subtypes and one for the meta-type.  Alternatively, each of the subtypes could be a unique TransactionType.  The reason we chose to go with a single EIP with subtypes is because these 4 transactions all have a *lot* in common and each separate EIP would be almost identical to the previous.  We felt that in this case, splitting into multiple EIPs wasn't worth the duplication of EIP content.
### ChainID not encoded with `v`
While we could save one byte in the common case by bundling the y-parity bit of the signature with the Chain ID like in EIP-155, this adds complexity to signing tools that the authors deem not worth it given the size of the transaction overall.
### Optionality ChainID
Sometimes it is useful to have a transaction that *can* be replayed on multiple chains.  An example of this is when you construct a vanity signature for a transaction and have the `from` be whatever address that signature recovers to.  With the ability to have someone else be a gas payer (setting both the gas limit and the gas price), one can have transactions that deploy contracts which live at the same address on every chain.  While this can be accomplished with CREATE2 using legacy transactions, we have the opportunity here to simplify the process and enable potentially other future uses of deterministic transactions by making ChainID optional.
### Optionality of ValidUntil
A user can set `ValidUntil` to a very large number which effectively makes it non-expiring.  By making `ValidUntil` optional, we can save some bytes on the wire by allowing such transcations to simply have a `0` (1 byte in RLP) value for this field.
### `SENDER` sets `gasLimit` and `gasPrice`
This type of transaction is useful when the transaction may execute differently depending on what these values are set to.  By having the `SENDER` set both, we ensure that the `SENDER` has full control over the transaction details.
### `SENDER` sets `gasLimit`, `GAS_PAYER` sets `gasPrice`
This type of transaction is useful when the transaction may execute differently depending on how much gas it is allowed (e.g., number of loops) but where the `SENDER` would like to give the `GAS_PAYER` the ability to price the transaction to maximize chances of inclusion.
### `GAS_PAYER` sets `gasLimit` and `gasPrice`
This type of transaction allows the `SENDER` to define what they want to do, and leaves all worry about gas to the `GAS_PAYER`.  This is useful for transactions where the sender doesn't care how much gas is used or the price that is paid and also either trusts the `GAS_PAYER` to be non-malicious or doesn't care if the `SENDER`'s nonce is increased.  Such situations are useful when you have extra-protocol trust between the `SENDER` and `GAS_PAYER` and you want to separate concerns (what to do vs how to get included) for security or complexity reasons.
