---
eip: 2771
title: Secure Protocol for Native Meta Transactions
author:
discussions-to: 
status: Draft
type: Standards Track
category: ERC
created: 2020-07-01
requires: 2770
---

## Simple Summary

We define a minimal secure protocol that allows an Ethereum contract to natively receive a meta transaction.

## Abstract

There is a growing interest in making it possible for Ethereum contracts to accept calls from externally owned accounts that do not have ETH to pay for gas. 

This can be accomplished with meta transactions, which are transactions that have been:
Signed by an externally owned account (the original sender)
Relayed by an untrusted third party that pays for the gas (the gas relay)

## Motivation

`msg.sender` is a transaction parameter that can be inspected by a contract to determine who signed the transaction. The integrity of this parameter is guaranteed by the Ethereum EVM, but for a meta transaction securing `msg.sender` is insufficient.

The problem is that for a contract that is not natively aware of meta transactions, the `msg.sender` of the transaction will make it appear to be coming from the gas relay and not the original sender. A secure protocol for a contract to accept meta transactions needs to prevent the gas relay from forging, modifying or duplicating requests by the original sender.

## Specification

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119] (https://www.ietf.org/rfc/rfc2119.txt).

Any meta transaction must include at least:

The address of the Recipient contract 
Signature from the Externally Owned Account (EOA) of the Original Sender
Data of the call to be executed

The scope of this ERC is limited to the protocol that a Recipient contract uses to accept a meta transaction through the ERC-2770 Forwarder Contract that it trusts to help it identify the address of the Original Sender.

####Components

`Original Sender` - Externally Owned Account that signs & sends to request to Gas Relay\
`Gas Relay` - receives a signed request off-chain from Original Sender and pays gas to turn it into a valid transaction that goes through Trusted Forwarder\
`Trusted Forwarder`  - a contract that is trusted by the Recipient to correctly verify the signature and nonce before forwarding the request from Original Sender\
`Recipient` - a contract that can securely accept meta-transactions through a Trusted Forwarder by being compliant with this standard.

### Extracting The Original Sender address

The ERC-2770 Forwarder is responsible for calling the Recipient contract and MUST append the address of the Original Sender (20 bytes of data) to the end of the call data.

For example :

```solidity
(bool success, bytes memory returnData) = to.call.value(value)(abi.encodePacked(data, from));
```

The Recipient contract can then extract the Original Sender address by performing 2 operations:
* Check that the Forwarder is trusted. How this is implemented is out of the scope of this proposal.
* Extract the Original Sender address from the last 20 bytes of the call data and use that as the original `sender` of the transaction (instead of `msg.sender`)
If the `msg.sender` is not a trusted forwarder (or if the msg.data is shorter than 20 bytes), then return the original `msg.sender` as is.

The Recipient MUST check that it trusts the Forwarder to prevent it from extracting address data appended from an untrusted contract. This could result in a forged address.

### Protocol Support Discovery Mechanism

Unless a Recipient contract is being used by a particular frontend that knows that this contract has support for native meta transactions,
it would not be possible to offer the user the choice of using meta-transaction to interact with the contract.
We thus need a mechanism by which the Recipient can let the world know that it supports meta transactions. 

This is especially important for meta transactions to be supported at the Web3 wallet level. Such wallets may not necessarily know anything about the Recipient contract users may wish to interact with.

As a Recipient could trust forwarders with different interfaces and capabilities (e.g., transaction batching, different message signing formats), we need to allow wallets to discover which Forwarder is trusted.

To provide this discovery mechanism a Recipient contract MUST implement this function:

```
function isTrustedForwarder(address forwarder) external returns(bool);
```

That function MUST return true if the forwarder is trusted by the Recipient.
That function MUST return false if the forwarder is not trusted.
That function MUST NOT throw to avoid false negative.

Internally, the Recipient MUST then accept a request from forwarder.

That function can be called on-chain and as such gas restriction needs to be put in place. 

###  Recipient example :

An example of this is as follow :

```solidity
contract RecipientExample {

    function purchaseItem(uint256 itemId) external {
        address sender = _msgSender();
        // perform the purchase for sender
    }

    address immutable _trustedForwarder;
    constructor(address trustedForwarder) internal {
        _trustedForwarder = trustedForwarder;
    }

    function isTrustedForwarder(address forwarder) external returns(bool) {
        return forwarder == _trustedForwarder;
    }

    function _msgSender() internal view returns (address payable signer) {
        signer = msg.sender;
        if (isTrustedForwarder(signer)) {
            bytes memory data = msg.data;
            uint256 length = msg.data.length;
            assembly { signer := mload(add(data, length))) }
        }    
    }

}
```

## Rationale
<!--The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->
The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->

## Backwards Compatibility
<!--All EIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The EIP must explain how the author proposes to deal with these incompatibilities. EIP submissions without a sufficient backwards compatibility treatise may be rejected outright.-->
All EIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The EIP must explain how the author proposes to deal with these incompatibilities. EIP submissions without a sufficient backwards compatibility treatise may be rejected outright.

## Test Cases
<!--Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.-->
Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.

## Implementation
<!--The implementations must be completed before any EIP is given status "Final", but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of "rough consensus and running code" is still useful when it comes to resolving many discussions of API details.-->
The implementations must be completed before any EIP is given status "Final", but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of "rough consensus and running code" is still useful when it comes to resolving many discussions of API details.

## Security Considerations

The recipient has full trust on the forwarder to check the nonce and signature (hence its called “trusted”). 
Modifying the recipient contract’s trusted forwarder is equivalent to give full control over the contract, so it is important that only the owner/admin of the contract can modify it - or leave it unmodifiable, as in the example above.

## References
<!--All EIPs must contain a section that discusses the security implications/considerations relevant to the proposed change. Include information that might be important for security discussions, surfaces risks and can be used throughout the life cycle of the proposal. E.g. include security-relevant design decisions, concerns, important discussions, implementation-specific guidance and pitfalls, an outline of threats and risks and how they are being addressed. EIP submissions missing the "Security Considerations" section will be rejected. An EIP cannot proceed to status "Final" without a Security Considerations discussion deemed sufficient by the reviewers.-->
All EIPs must contain a section that discusses the security implications/considerations relevant to the proposed change. Include information that might be important for security discussions, surfaces risks and can be used throughout the life cycle of the proposal. E.g. include security-relevant design decisions, concerns, important discussions, implementation-specific guidance and pitfalls, an outline of threats and risks and how they are being addressed. EIP submissions missing the "Security Considerations" section will be rejected. An EIP cannot proceed to status "Final" without a Security Considerations discussion deemed sufficient by the reviewers.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
