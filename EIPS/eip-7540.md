---
eip: 7540
title: Asynchronous ERC-4626 Tokenized Vaults
description: Extension of ERC-4626 with asynchronous deposit and redemption support
author: Jeroen Offerijns (@hieronx), Alina Sinelnikova (@ilinzweilin), Vikram Arun (@vikramarun), Joey Santoro (@joeysantoro)
discussions-to: https://ethereum-magicians.org/t/eip-7540-asynchronous-erc-4626-tokenized-vaults/16153
status: Draft
type: Standards Track
category: ERC
created: 2023-10-18
requires: 20, 4626
---

## Abstract

The following standard extends [ERC-4626](./eip-4626.md) by adding support for asynchronous deposit and redemption flows. The async flows are called "Requests".

New methods are added to asynchronously request a deposit or redemption, and view the pending status of the request. The existing deposit, mint, withdraw, and redeem ERC-4626 methods are used for executing claimable Requests. 

Implementations can choose to whether to add asynchronous flows for deposits, redemptions, or both. 

## Motivation

The ERC-4626 Tokenized Vaults standard has helped to make yield-bearing tokens more composable across decentralized finance. The standard is optimized for atomic deposits and redemptions up to a limit. If the limit is reached, no new deposits or redemptions can be submitted.

This limitation does not work well for any smart contract system with asynchronous actions or delays as a prerequisite for interfacing with the Vault (e.g. real-world asset protocols, undercollateralized lending protocols, cross-chain lending protocols, liquid staking tokens, or insurance safety modules). 

This standard expands the utility of 4626 Vaults for asynchronous use cases. The existing Vault interface (deposit/withdraw/mint/redeem) is fully utilized to claim asynchronous Requests.

## Specification

### Definitions:

The existing definitions from [ERC-4626](./eip-4626.mn) apply. In addition, this spec defines:

- request: a function call that initiates an asynchronous deposit/redemption flow
- pending request: the state where a request has been made but is not yet claimable
- claimable: the Vault's step of processing the request and enabling the user to claim corresponding shares (for async deposit) or assets (for async redeem)
- claim: the corresponding Vault method to complete a request (e.g. `deposit` claims `shares` from `requestDeposit`)
- operator: the account specified by the sender of the request which has has the right to claim a given request once it is claimable
- asynchronous deposit Vault: a Vault that implements asynchronous requests for deposit flows
- asynchronous redemption Vault: a Vault that implements asynchronous redemption flows
- fully asynchronous Vault: a vault that implements asynchronous requests for both deposit and redemption

### Request Flows

EIP-X vaults MUST implement one or both of asynchronous deposit and redemption request flows. If either flow is not implemented in a request pattern, it MUST use the ERC-4626 standard synchronous interaction pattern. 

All EIP-X asynchronous tokenized vaults MUST implement ERC-4626, with the following overrides for request flows:

1. In asynchronous deposit Vaults, the `deposit` and `mint` methods do not transfer  `asset` to the vault, because this already happened on `requestDeposit`.
2. In asynchronous redemption Vaults, the `redeem` and `withdraw` methods do not transfer `shares` to the vault, because this already happened on `requestRedeem`. 
3. In asynchronous redemption Vaults, the `owner/operator` field of `redeem` and `withdraw` MUST be `msg.sender` to prevent the theft of requested redemptions by a non-owner/operator.
4. The `receiver` field of the max* methods for asynchronous flows SHOULD be renamed to `operator`.
5. The `owner` field of the `redeem` and `withdraw` methods for async flows SHOULD be renamed to `operator`.
6. The preview* functions treat the `msg.sender` as the `operator`.

### Request Lifecycle

After submission, Requests go through Pending, Claimable, and Claimed stages. An example lifecycle for a deposit request is visualized in the table below.

| **State** | **User**                         |                                                                                                                **Vault** |
| ---------:|:-------------------------------- | ------------------------------------------------------------------------------------------------------------------------:|
|   Pending | requestDeposit(assets, operator) |                               asset.transferFrom(msg.sender, vault, assets)<br>pendingDepositRequest[operator] += assets |
| Claimable |                                  | <i>Internal request fulfillment</i><br>pendingDepositRequest[msg.sender] -= assets<br>maxDeposit[operator] += assets<br> |
|   Claimed | deposit(assets, receiver)        |                                                  maxDeposit[msg.sender] -= assets<br>vault.balanceOf[receiver] += shares |

An important vault inequality is that following a Request(s), the cumulative requested quantity MUST be more than `pendingDepositRequest + maxDeposit - claimed`. The inequality may come from fees or other state transitions outside implemented by vault logic such as cancellation of a Request, otherwise this would be a strict equality.

Requests MUST NOT skip or otherwise short-circuit the claim step. In other words, to initiate and claim a request, a user MUST call both request* and the corresponding claim function separately, even in the same block.

For asynchronous request vaults, the exchange rate between shares and assets including fees and yield is up to the vault implementation. In other words, pending redemption requests MAY NOT be yield bearing and MAY NOT have a fixed exchange rate.

### Methods

#### requestDeposit

Locks `assets` from `msg.sender` into the Vault and submits a Request for asynchronous `deposit/mint`. This places the Request in Pending state, with a corresponding increase in `pendingDepositRequest` for the amount `assets`.

When the Request is claimable, `maxDeposit` and `maxMint` will be increased, and `deposit` or `mint` can be called by `operator` to receive `shares`. A Request MAY transition straight to claimable state but MUST NOT skip the claimable state.

The `shares` that will be received on `deposit` or `mint` MAY NOT be equivalent to the value of `convertToShares(assets)` at the time of Request, as the price can change between request and claim.

MUST support ERC-20 `approve` / `transferFrom` on `asset` as a deposit Request flow.

MUST revert if all of `assets` cannot be requested for `deposit`/`mint` (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).

Note that most implementations will require pre-approval of the Vault with the Vault's underlying `asset` token.

MUST emit the `RequestDeposit` event.

```yaml
- name: requestDeposit
  type: function
  stateMutability: nonpayable

  inputs:
    - name: assets
      type: uint256
    - name: operator
      type: address
```

#### pendingDepositRequest

The amount of requested `assets` in pending state for the `operator` to `deposit` or `mint`.

MUST NOT include any assets in claimable state for `deposit` or `mint`.

MUST NOT show any variations depending on the caller.

MUST NOT revert unless due to integer overflow caused by an unreasonably large input.

```yaml
- name: pendingDepositRequest
  type: function
  stateMutability: view

  inputs:
    - name: operator
      type: address

  outputs:
    - name: assets
      type: uint256
```

#### requestRedeem

Assumes control of `shares` from `owner` and submits a request for asynchronous `redeem/withdraw`. This places the Request in Pending state, with a corresponding increase in `pendingRedeemRequest` for the amount `shares`. 

MAY support either a locking or a burning mechanism for `shares` depending on the vault implemention. 

MUST support a redeem Request flow where the `shares` control of shares is taken from `owner` directly where `msg.sender` has EIP-20 approval over the `shares` of `owner`.

When the Request is claimable, `maxRedeem` and `maxWithdraw` will be increased, and `redeem` or `withdraw` can be called by `operator` to receive `assets`. A Request MAY transition straight to claimable state but MUST NOT skip the claimable state.

If a Vault uses a locking mechanism for `shares`, those `shares` MUST be burned from the vault balance before or upon claiming the Request.

The `assets` that will be received on `redeem` or `withdraw` MAY NOT be equivalent to the value of `convertToAssets(shares)` at time of Request, as the price can change between request and claim.

SHOULD check `msg.sender` can spend owner funds using allowance.

MUST revert if all of `shares` cannot be requested for `redeem` / `withdraw` (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).

MUST emit the `RequestRedeem` event.

```yaml
- name: requestRedeem
  type: function
  stateMutability: nonpayable

  inputs:
    - name: shares
      type: uint256
    - name: operator
      type: address
    - name: owner
      type: address
```

#### pendingRedeemRequest

The amount of requested `shares` in pending state for the `operator` to `redeem` or `withdraw`.

MUST NOT include any `shares` in claimable state for `redeem` or `withdraw`.

MUST NOT show any variations depending on the caller.

MUST NOT revert unless due to integer overflow caused by an unreasonably large input.

```yaml
- name: pendingRedeemRequest
  type: function
  stateMutability: view

  inputs:
    - name: operator
      type: address

  outputs:
    - name: shares
      type: uint256
```

### Events

#### DepositRequest

`sender` has locked `assets` in the Vault to request a deposit. `operator` controls this request.

MUST be emitted when a deposit request is submitted using the `requestDeposit` method.

```yaml
- name: DepositRequest
  type: event

  inputs:
    - name: sender
      indexed: true
      type: address
    - name: operator
      indexed: true
      type: address
    - name: assets
      indexed: false
      type: uint256
```

#### RedeemRequest

`sender` has locked `shares`, owned by `owner`, in the Vault to request a redemption. `operator` controls this request.

MUST be emitted when a redemption request is submitted using the `requestRedeem` method.

```yaml
- name: RedeemRequest
  type: event

  inputs:
    - name: sender
      indexed: true
      type: address
    - name: operator
      indexed: true
      type: address
    - name: owner
      indexed: true
      type: address
    - name: assets
      indexed: false
      type: uint256
```

## Rationale

### Symmetry and Non-inclusion of requestWithdraw and requestMint

In ERC-4626, the spec was written to be fully symmetrical with respect to converting assets and shares by including deposit/withdraw and mint/redeem.

Due to the asynchronous nature of requests, the vault can only operate with certainty on the quantity that is fully known at the time of the request (`assets` for `deposit` and `shares` for `redeem`). The deposit request flow cannot work with a `mint` call, because the amount of `assets` for the requested `shares` amount may fluctuate before the fulfillment of the request. Likewise, the redemption request flow cannot work with a `withdraw` call.

### Optionality of flows

Certain use cases are only asynchronous on one flow but not the other between request and redeem. A good example of an asynchronous redemption vault is a liquid staking token. The unstaking period necessitates support for asynchronous withdrawals, however, deposits can be fully synchronous.

### Non Inclusion of a Request Cancelation Flow

In many cases, canceling a request may not be straightforward or even technically feasible. The state transition of cancelations could be synchronous or asynchronous, and the way to claim a cancelation interfaces with the remaining vault functionality in complex ways.

A separate EIP should be developed to standardize behavior of cancelling a pending Request. Defining the cancel flow is still important for certain classes of use cases for which the fulfillment of a Request can take a considerable amount of time.

### Request Implementation flexibility

The standard is flexible enough to support a wide range of interaction patterns for request flows. Pending requests can be handled via internal accounting, globally or on per-user levels, use ERC-20 or [ERC-721](./eip-721.md), etc.

Likewise yield on redemption requests can accrue or not, and the exchange rate of any request may be fixed or variable depending on the implementation.

### Not allowing short-circuiting for claims
If claims can short circuit, this creates ambiguity for integrators and  complicates the interface with overloaded behavior on request functions.

Instead there can be router contracts which atomically check for claimable amounts immediately upon request. Frontends can dynamically route requests in this way depending on the state and implementation of the vault.

### Operator function parameter on requestDeposit and requestRedeem

To support flows where a smart contract manages the request lifecycle on behalf of a user, the `operator` parameter is included in the `requestDeposit` and `requestRedeem` functions. This is not called `owner` because the `assets` or `shares` are not transferred from this account on request submission, unlike the behaviour of an `owner` on `redeem`. It is also not called `receiver` because the `shares` or `assets` are not necessarily transferred on claiming the request, this can be chosen by the operator when they call `deposit`, `mint`, `redeem`, or `withdraw`.

## Backwards Compatibility

The interface is fully backwards compatible with [ERC-4626](https://eips.ethereum.org/EIPS/eip-4626). The specification of the `deposit`, `mint`, `redeem`, and `withdraw` methods is different as described in [Specification](#specification).

## Reference Implementation

Centrifuge has been developing [an implementation](https://github.com/centrifuge/liquidity-pools/blob/72f1ddddf3493db5e166f6c3317a6a5c27675eeb/src/LiquidityPool.sol) that can provide a reference.

## Security Considerations

The methods `pendingDepositRequest` and `pendingRedeemRequest` are estimates useful for display purposes, and can be outdated due to the asynchronicity.

In general, asynchronicity concerns make state transitions in the vault much more complex and vulnerable to security risks. Access control on vault operations, clear documentation of state transitioning, and invariant checks should all be performed to mitigate these risks.

It is worth highlighting again here that the claim functions for any asynchronous flows MUST enforce that `msg.sender == operator/owner` to prevent theft of claimable `assets` or `shares`

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
