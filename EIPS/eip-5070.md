---
eip: 5070
title: Principal Token Standard
description: A standard for principal tokens (zero-coupon tokens) that are redeemable for a single underlying ERC-20 token at a future timestamp.
author: Julian Traversa (@JTraversa), Alberto Cuesta Ca√±ada (@alcueca), Robert Robbins (@robrobbins)
discussions-to: https://ethereum-magicians.org/t/eip-4626-yield-bearing-vault-standard/7900
status: Draft
type: Standards Track
category: ERC
created: 2021-12-22
requires: 20, 2612
---

## Abstract

The following standard allows for the implementation of a standard API for principal tokens
ownership of a single underlying [ERC-20](./eip-20.md) token at a future timestamp.
This standard is an extension on the ERC-20 token that provides basic functionality for depositing
and withdrawing tokens and reading balances and the ERC-2612 standard that provides
EIP-712 signature based approvals.

## Motivation

Principal tokens have an increasing lack of standardization which has led to a difficult to navigate development space and diverse implementation
schemes.

The primary examples include yield tokenization platforms which strip future yield leaving a principal
token behind, as well as fixed-rate money-markets which utilize principal tokens as a medium
to lend/borrow.

This inconsistency in implementation makes integration difficult at the aggregator layer as well as
any wallet integration layer which are key catalysts for the space's growth. 
Developers are currently expected to implement individual adapters for each principal token, as well as adapters for
their pool contracts, and many times adapters for their custodial contracts as well, wasting significant developer resources. 

## Specification

All ERC-5070 Principal Tokens MUST implement ERC-20 to represent ownership of future underlying redemption (PTs).
If a PT is to be non-transferrable, it MAY revert on calls to `transfer` or `transferFrom`.
The ERC-20 operations `balanceOf`, `transfer`, `totalSupply`, etc. operate on the Principal Token balance
which represents a claim to ownership of 1:1 amounts of underlying upon maturity.

All ERC-5070 Principal Tokens MUST implement ERC-20's optional metadata extensions.
The `name` and `symbol` functions SHOULD reflect the underlying token's `name` and `symbol` in some way, as well as the origination protocol, 
and in the case of yield tokenization protocols, the origination money-market.

ERC-5070 tokenized Vaults MAY implement [EIP-2612](./eip-2612.md) to improve the UX of approving PTs on various integrations.

### Definitions:

- underlying: The deposited token, redeemable 1:1 with Principal Tokens at maturity.
  Has units defined by the corresponding ERC-20 contract.
- maturity: The timestamp (unix) at which a Principal Token matures. Principal Tokens become redeemable for underlying at this timestamp, 
and in Yield-Tokenization protocols, begin accruing yield.
- exchangeRate: A variable used within money-markets to modulate the redeemable ratio of underlying <-> cToken. Used to calculate
yield between user interactions.
- fee: An amount of underlying or Principal Token charged to the user by the Principal Token. Fees can exists for redemption or yield.

### Methods

#### underlying

The address of the underlying token used by the Principal Token for accounting, depositing, and withdrawing.

MUST be an ERC-20 token contract.

MUST _NOT_ revert.

```yaml
- name: underlying
  type: function
  stateMutability: view

  inputs: []

  outputs:
    - name: underlyingAddress
      type: address
```

#### totalUnderlying

Total amount of the underlying asset that is "managed" by the Principal Token contract.

MAY include any compounding that occurs from yield post-maturity for Yield Tokenized Principal Tokens.

MUST be inclusive of any fees that are charged against assets in the Principal Token.

MUST _NOT_ revert.

```yaml
- name: totalUnderlying
  type: function
  stateMutability: view

  inputs: []

  outputs:
    - name: totalManagedUnderlying
      type: uint256
```

#### maturityRate

The exchangeRate during the block that a first user first calls `redeem` or `mature` after maturity.

OPTIONAL - This method can be used to provide needed data for the calculation of interest post-maturity, but interfaces and other contracts MUST NOT expect this method to be present.

MUST _NOT_ revert.

```yaml
- name: maturityRate
  type: function
  stateMutability: view

  inputs: []

  outputs:
    - name: exchangeRate
      type: uint256
```

#### mint

Mints exactly `amount` of Principal Tokens to `to` by depositing that exact same `amount` of underlying tokens.

MUST emit the `Minted` event.

MUST support ERC-20 `approve` / `transferFrom` on `asset` as a mint flow.
MAY support an additional flow in which the underlying tokens are owned by the Principal Token contract before the `mint` execution, and are accounted for during `mint`.

MUST revert if all of `amount` cannot be minted (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the PT contract, etc).

Note that most implementations will require pre-approval of the Principal Token contract with the Principal Tokens `underlying` token.

```yaml
- name: mint
  type: function
  stateMutability: nonpayable

  inputs:
    - name: amount
      type: uint256
    - name: to
      type: address

  outputs:
    - name: success
      type: bool
```

#### redeem

After maturity, burns exactly `amount` of Principal Tokens from `from` and sends the same `amount` of underlying tokens to `to`.

OPTIONAL - This method can be used to improve the usability and integration difficulty of Principal tokens, but interfaces and other contracts MUST NOT expect fund custody to be present.
While custodial redeemption of Principal Tokens for underlying is extremely useful for integrators, some protocols may find doing so breaks their design's backwards compatability. 

MUST emit the `Redeemed` event.

MUST support a redeem flow where the Principal Tokens are burned from `owner` directly where `owner` is `msg.sender` or `msg.sender` has ERC-20 approval over the shares of `owner`.
MAY support an additional flow in which the shares are transferred to the Principal Token contract before the `redeem` execution, and are accounted for during `redeem`.

MUST revert if all of `amount` cannot be redeemed (due to withdrawal limit being reached, slippage, the owner not having enough Principal Tokens, etc).

Note that some implementations will require pre-requesting to the Principal Token before a withdrawal may be performed. Those methods should be performed separately.

```yaml
- name: redeem
  type: function
  stateMutability: nonpayable

  inputs:
    - name: shares
      type: uint256
    - name: receiver
      type: address
    - name: owner
      type: address

  outputs:
    - name: assets
      type: uint256
```

#### mature

Callable once `block.timestamp >= maturity`, stores the current `exchangeRate` as the `maturityRate` and "matures" the Principal Tokens. 

OPTIONAL - This method can be used to provide needed data for the calculation of interest post-maturity, but interfaces and other contracts MUST NOT expect this method to be present.

MUST emit the `Matured` event.

MUST revert if `block.timestamp < maturity`.

```yaml
- name: mature
  type: function
  stateMutability: nonpayable

  inputs: []

  outputs:
    - name: exchangeRate
      type: uint256
```

### Events

#### Matured

The Principal Token has hit maturity, and a user has interacted with the Principal Token contract for the first time post-maturity.

OPTIONAL - This event can be used to improve usability and clarity for index based systems, but interfaces and other contracts MUST NOT expect this event to be present.

MUST be emitted when the `mature` method is called and the `maturityRate` is stored.

```yaml
- name: Matured
  type: event

  inputs:
    - name: matured
      indexed: true
      type: uint256
    - name: exchangeRate
      indexed: true
      type: uint256
```

#### Minted

`from` has exchanged `amount` of underlying for `amount` of Principal Tokens, and transferred those Principal Tokens to `to`.

MUST be emitted when underlying is deposited and Principal Tokens are minted from the contract in the `ERC5070.mint` method.

```yaml
- name: Minted
  type: event

  inputs:
    - name: from
      indexed: true
      type: address
    - name: to
      indexed: true
      type: address
    - name: amount
      indexed: false
      type: uint256
```

#### Redeemed

`from` has exchanged `amount` of Principal Tokens for `amount` of underlying, and transferred that underlying to `to`.

MUST be emitted when Principal Tokens are burnt and underlying is withdrawn from the contract in `ERC4626.redeem`.

```yaml
- name: Redeemed
  type: event

  inputs:
    - name: from
      indexed: true
      type: address
    - name: to
      indexed: true
      type: address
    - name: amount
      indexed: false
      type: uint256
```

## Rationale

The Vault interface is designed to be optimized for integrators with a feature complete yet minimal interface.
Details such as accounting and allocation of deposited tokens are intentionally not specified,
as Vaults are expected to be treated as black boxes on-chain and inspected off-chain before use.

ERC-20 is enforced because implementation details like token approval
and balance calculation directly carry over to the shares accounting.
This standardization makes the Vaults immediately compatible with all ERC-20 use cases in addition to ERC-4626.

The mint method was included for symmetry and feature completeness.
Most current use cases of share-based Vaults do not ascribe special meaning to the shares such that
a user would optimize for a specific number of shares (`mint`) rather than specific amount of underlying (`deposit`).
However, it is easy to imagine future Vault strategies which would have unique and independently useful share representations.

The `convertTo` functions serve as rough estimates that do not account for operation specific details like withdrawal fees, etc.
They were included for frontends and applications that need an average value of shares or assets, not an exact value possibly including slippage or other fees.
For applications that need an exact value that attempts to account for fees and slippage we have included a corresponding `preview` function to match each mutable function. These functions must not account for deposit or withdrawal limits, to ensure they are easily composable, the `max` functions are provided for that purpose.

## Backwards Compatibility

ERC-4626 is fully backward compatible with the ERC-20 standard and has no known compatibility issues with other standards.
For production implementations of Vaults which do not use ERC-4626, wrapper adapters can be developed and used.

## Reference Implementations

See [Solmate ERC4626](https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol):
a minimal and opinionated implementation of the standard with hooks for developers to easily insert custom logic into deposits and withdrawals.

See [Vyper ERC4626](https://github.com/fubuloubu/ERC4626):
a demo implementation of the standard in Vyper, with hooks for share price manipulation and other testing needs.

## Security Considerations

Fully permissionless use cases could fall prey to malicious implementations which only conform to the interface but not the specification.
It is recommended that all integrators review the implementation for potential ways of losing user deposits before integrating.

If implementors intend to support EOA account access directly, they should consider adding an additional function call for `deposit`/`mint`/`withdraw`/`redeem` with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.

The methods `totalAssets`, `convertToShares` and `convertToAssets` are estimates useful for display purposes,
and do _not_ have to confer the _exact_ amount of underlying assets their context suggests.

The `preview` methods return values that are as close as possible to exact as possible. For that reason, they are manipulable by altering the on-chain conditions and are not always safe to be used as price oracles. This specification includes `convert` methods that are allowed to be inexact and therefore can be implemented as robust price oracles. For example, it would be correct to implement the `convert` methods as using a time-weighted average price in converting between assets and shares.

Integrators of ERC-4626 Vaults should be aware of the difference between these view methods when integrating with this standard. Additionally, note that the amount of underlying assets a user may receive from redeeming their Vault shares (`previewRedeem`) can be significantly different than the amount that would be taken from them when minting the same quantity of shares (`previewMint`). The differences may be small (like if due to rounding error), or very significant (like if a Vault implements withdrawal or deposit fees, etc). Therefore integrators should always take care to use the preview function most relevant to their use case, and never assume they are interchangeable.

Finally, ERC-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users:

- If (1) it's calculating how many shares to issue to a user for a certain amount of the underlying tokens they provide or (2) it's determining the amount of the underlying tokens to transfer to them for returning a certain amount of shares, it should round _down_.

- If (1) it's calculating the amount of shares a user has to supply to receive a given amount of the underlying tokens or (2) it's calculating the amount of underlying tokens a user has to provide to receive a certain amount of shares, it should round _up_.

The only functions where the preferred rounding direction would be ambiguous are the `convertTo` functions. To ensure consistency across all ERC-4626 Vault implementations it is specified that these functions MUST both always round _down_. Integrators may wish to mimic rounding up versions of these functions themselves, like by adding 1 wei to the result.

Although the `convertTo` functions should eliminate the need for any use of an ERC-4626 Vault's `decimals` variable, it is still strongly recommended to mirror
the underlying token's `decimals` if at all possible, to eliminate possible sources of confusion and simplify integration across front-ends and for other off-chain users.

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
