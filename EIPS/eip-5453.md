---
eip: 5453
title: Smart Endorsement
description: Defines a format for endorsement on-chain
author: Zainan Victor Zhou (@xinbenlv)
discussions-to: https://ethereum-magicians.org/t/erc-5453-endorsement-standard/10355
status: Draft
type: Standards Track
category: Interface
created: 2022-08-12
requires: 5269
---

## Abstract

Provides a format for endorsement of smart contract transactions in the format of extra data (the last bytes field of a method signature).

## Motivation

1. Support a second approval from another user: TODO
2. Support pay-for-by: TODo
3. Support multi-sig: TODO
4. Support persons acting in concert by endorsements: TODO
5. Support accumulated voting: TODO
6. Support off-line signatures: TODO

## Specification
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

1. A field of method signature MUST be designated to be the endorsement field.
It must exceed a minimum length of `65 bytes` which is the length of (v, r, s) where as

- `r, s` are the ECDSA recover signature pair. `v`'s last bit carries ECDSA recover Y-Parity.

2. For any complying method of compliant contract, the last data field MUST be `bytes`.

3. Such data field MUST conform to the following format

3.1. the last 8-bytes MUST be a magic 8-bytes word in the ASCII representation of "ENDORSED".
Implementing method of smart contract that honors smart endorsement MUST deemed a transaction unendorsed by anyone,
if the ending 8-bytes doesn't matches with this magic word.
3.2. the last 2-bytes MUST be a type-indicator, denoted as `Erc5453FormatType`
3.3. For `Erc5453FormatType == FIRST_TYPE_SINGLE_ENDORSER` <!--TODO determine a type number-->,
it supports a simple endorsement signature in the following format. Any complying contract MUST implement FIRST_TYPE.
Other type number will be used for future extension, such as a multi-but-separate-endorsement scenario.

3.4. Complying contract MUST emit the following `OnEndorsed` event when a transaction is executed because of the endorsement. Complying contract MUST NOT emit such event when a transaction is executed without taking account of the endorsement.

```solidity
event OnEndorsed(byte32 MethodABIKeccak, address[] memory endorsers);
```

4. The format of `FIRST_TYPE_SINGLE_ENDORSER` type is

```solidity
endorser_nonce(uint256, 32bytes) ||
valid_by(uint256, 32bytes) ||
r,s,v (32bytes + 32bytes + 1bytes = 65bytes)||
MAGIC_WORLD(8bytes)
```

The total length denoted as `ENDORSEMENT_LENGTH = 137 bytes`

5. The `(r,s,v)` are a ECDSA signature of all method fields plus the head remainder of `extraData` removing
the last ENDORSEMENT_LENGTH bytes. See reference implementation for clarification.

## Rationale

1. Choosing [EIP-5269](./eip-5269.md) instead of [EIP-165](./eip-165.md) because the data format cannot be represented by format.
2. Originally we considered adding the endorsement at the first part of `extraData`. We turn into adding the endorsement to the ending of data, which allows the following future extensions such as:

- Allow nested endorsements for nested function calls. TODO add reference implementation
- Allow general endorsables be applied

## Backwards Compatibility

The design is assumes a `bytes calldata extraData` and hence to maximize the flexibility of future extension. It is compatible with popular ERCs such as ERC-721, ERC-1155. ERC-20 can also be updated to support it, such as wrapper contract or proxy upgrade.

## Test Cases
TODO

## Reference Implementation
```solidity
contract EndorsableERC721 is SomeERC721 {
  function safeTransferFrom(address from, address to, uint256 id, bytes calldata extraData) {
    super.safeTransferFrom(from, to, id, extraData[LENGTH_OF_ENDORSEMENT])
  }
}
```

## Security Considerations

- `Replay-attack`: Replay attack is a type of attack on cryptography authentication.
In a narrower sense, it usually refers to is a type of attack that circumvent the crypto
signature verification by reusing an existing signature for message being signed again.
Any implementations relying on this ERC must realize that all smart endorsements
described here are cryptography signatures and are *public* and can be obtained by anyone.
They must forsee the possibility of replay of the transactions not only
at the exactly deployment of the same smart contract, but also other deployment
of similar smart contract source, or a version on another chainId etc.
All the `nonce`, `valid_since`, `valid_by` were meant to restrict the surface of attack but
might not eliminate risks of all such attacks, e.g. see **Phishing** for endorsement.

- `Phishing`: It's worth pick out a special form of replay-attack by phishing.
An adversary can design another smart contract in the way that user be tricked
into signing a smart endorsement for a seemingly legitimate purpose,
but the data-to-designed matches the target application

- `nonce` is required to avoid replay attack.
- `valid_by` is needed to ensure a confirmed end of life-cycle for an endorsement.

### Related EIPs

- [EIP-712](./eip-712.md)
- [EIP-2242](./eip-2242.md) proposes postdata: proposed to be unreadable to EVM. It's possible new EIP
proposes supporting a different type of `postData` via Solidity compilation or general additional data
field.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).
