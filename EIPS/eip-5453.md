---
eip: 5453
title: Smart Endorsement
description: Defines a format for endorsement on-chain
author: Zainan Victor Zhou (@xinbenlv)
discussions-to: https://ethereum-magicians.org/t/erc-5453-endorsement-standard/10355
status: Draft
type: Standards Track
category: Interface
created: 2022-08-12
requires:
---
<!-- TODO add 5269 in requires after the ./eip-5269.md becomes available. -->
## Abstract

Provides a format for endorsement of smart contract transactions in the format of extra data (the last bytes field of a method signature).

## Motivation

1. Support a second approval from another user: TODO
2. Support pay-for-by: TODo
3. Support multi-sig: TODO
4. Support persons acting in concert by endorsements: TODO
5. Support accumulated voting: TODO
6. Support off-line signatures: TODO

## Specification
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

1. A field of method signature MUST be designated to be the endorsement field.
It must exceed a minimum length of `65 bytes` which is the length of (v, r, s) where as

- `r, s` are the ECDSA recover signature pair. `v`'s last bit carries ECDSA recover Y-Parity.

2. For any complying method of compliant contract, the last data field MUST be `bytes`.

3. Such data field MUST conform to the following format

3.1. the last 8-bytes MUST be a magic 8-bytes word in the ASCII representation of "ENDORSED".
Implementing method of smart contract that honors smart endorsement MUST deemed a transaction unendorsed by anyone,
if the ending 8-bytes doesn't matches with this magic word.
3.2. the last 2-bytes MUST be a type-indicator, denoted as `Erc5453FormatType`
3.3. For `Erc5453FormatType == FIRST_TYPE_SINGLE_ENDORSER` <!--TODO determine a type number-->,
it supports a simple endorsement signature in the following format. Any complying contract MUST implement FIRST_TYPE.
Other type number will be used for future extension, such as a multi-but-separate-endorsement scenario.

3.4. Complying contract MUST emit the following `OnEndorsed` event when a transaction is executed because of the endorsement. Complying contract MUST NOT emit such event when a transaction is executed without taking account of the endorsement.

```solidity
event OnEndorsed(byte32 MethodABIKeccak, address[] memory endorsers);
```

4. The format of `FIRST_TYPE_SINGLE_ENDORSER` type is

```solidity
endorser_nonce(uint256, 32bytes) ||
valid_by(uint256, 32bytes) ||
r,s,v (32bytes + 32bytes + 1bytes = 65bytes)||
MAGIC_WORLD(8bytes)
```

The total length denoted as `LENGTH_OF_ENDORSEMENT = 137 bytes`

5. The `(r,s,v)` are a ECDSA signature of all method fields plus the head remainder of `extraData` removing
the last LENGTH_OF_ENDORSEMENT bytes. See reference implementation for clarification.

## Rationale

1. Choosing [EIP-5269](./eip-5269.md) instead of [EIP-165](./eip-165.md) because the data format cannot be represented by format.
2. Originally we considered adding the endorsement at the first part of `extraData`. We turn into adding the endorsement to the ending of data, which allows the following future extensions such as:

- Allow nested endorsements for nested function calls. TODO add reference implementation
- Allow general endorsables be applied

## Backwards Compatibility

The design assumes a `bytes calldata extraData` to maximize the flexibility of future extensions.
This assumption is compatible with most newer ERCs such as EIP-721, EIP-1155.
Those that aren't, such as EIP-20, can also be updated to support it,
such as using a wrapper contract or proxy upgrade.

## Test Cases
TODO

## Reference Implementation
```solidity

// Per feature request in Macro https://github.com/ethereum/solidity/issues/10
// Macro is not supported yet in
// Implementer can just replicate the following expansion by hand until
// The macro is supported in solidity.
#define REMAIN_LENGTH extraData.length - LENGTH_OF_ENDORSEMENT;

abstract contract ERC5453 {
    modifier onlyEndorsed(bytes32 _msgDigest, bytes calldata _end/**orsement**/) {
        require(_end.length == LENGTH_OF_ENDORSEMENT);
        require(_end[_end.length - 8:] == MAGIC_WORLD);


        // ERC-1271 prefix. See https://eips.ethereum.org/EIPS/eip-1271
        string memory erc1271Prefix = "\x19Ethereum Signed Message:\n32";
        bytes32 erc1271Hash = keccak256(abi.encodePacked(erc1271Prefix, _msgDigest));
        address endorser = ecrecover(erc1271Hash,
            uint8(_end[128]), // v
            bytes32(_end[64:96]), // r
            bytes32(_eSig[96:128]) // s
        );
        // _isEligibleEndorser is application specific.
        require (_isEligibleEndorser(endorser), "Endorser is not eligible to transfer.");
        _;
    }
}

contract EndorsableERC721 is SomeERC721, ERC5453 {
  function safeTransferFrom(
    address from,
    address to,
    uint256 id,
    bytes calldata extraData)

    onlyEndorsed(  // used as modifier
        keccak256(
            abi.encodePacked(
                from, to, id, amount,
                extraData[:REMAIN_LENGTH], // first part of extraData is reserved for original use for extraData unendorsed.
                extraData[REMAIN_LENGTH: REMAIN_LENGTH + 32], // nonce of endorsement for the {contract, endorser} combination
                extraData[REMAIN_LENGTH + 32: REMAIN_LENGTH + 64], // valid_by for the endorsement
            ),
        data[REMAIN_LENGTH:] // the endorsement component
    ) {
    super.safeTransferFrom(from, to, id, extraData[:REMAIN_LENGTH]); // original
  }
}
```

## Security Considerations

- `Replay-attack`: Replay attack is a type of attack on cryptography authentication.
In a narrower sense, it usually refers to is a type of attack that circumvent the crypto
signature verification by reusing an existing signature for message being signed again.
Any implementations relying on this ERC must realize that all smart endorsements
described here are cryptography signatures and are *public* and can be obtained by anyone.
They must forsee the possibility of replay of the transactions not only
at the exactly deployment of the same smart contract, but also other deployment
of similar smart contract source, or a version on another chainId etc.
All the `nonce`, `valid_since`, `valid_by` were meant to restrict the surface of attack but
might not eliminate risks of all such attacks, e.g. see **Phishing** for endorsement.
- See an example revealed in
[ECDSA signature malleability(CVE-2022-35961)](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h)

- `Phishing`: It's worth pick out a special form of replay-attack by phishing.
An adversary can design another smart contract in the way that user be tricked
into signing a smart endorsement for a seemingly legitimate purpose,
but the data-to-designed matches the target application

- `nonce` is required to avoid replay attack.
- `valid_by` is needed to ensure a confirmed end of life-cycle for an endorsement.

### Related EIPs

- [EIP-712](./eip-712.md)
- [EIP-2242](./eip-2242.md) proposes postdata: proposed to be unreadable to EVM. It's possible new EIP
proposes supporting a different type of `postData` via Solidity compilation or general additional data
field.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).
