---
eip: 7331
title: Private Equity
description: A private equity fund Contract distributes dividends of a private equity fund in stable coins or in fund tokens as per the user's choice.
author: Oasis Pro Markets (@tokenizeassets)
discussions-to: https://ethereum-magicians.org/t/a-proposal-for-private-equity-and-funds-smart-contract/14681
status: Draft
type: Standards Track
category: ERC
created: 2023-07-04
requires: 20, 3643
---

## Abstract

A private equity fund is a type of investment fund that pools together capital from high-net-worth individuals, institutional investors, and sometimes, pension funds to make investments in private companies. These funds are managed by private equity firms, which specialize in acquiring ownership stakes in companies and actively managing them to generate returns.

## Motivation

The existing investment landscape faces multiple challenges, including high investment barriers, limited liquidity, lengthy settlement processes, regulatory compliance issues, counterparty risks, and concerns over custodial control. These barriers prevent individuals from taking control of their investments, diversifying their portfolios, and accessing the benefits of a secure and efficient investment ecosystem. There is a pressing need for a comprehensive solution that addresses these challenges, providing a tokenization platform that sidesteps investment barriers, establishes an unceasing liquid marketplace with the instant settlement, ensures regulatory compliance, eliminates counterparty risks, and enables self-custody, empowering users to make informed investment decisions, access diverse opportunities, and maintain full control over their assets.

### Management Fee

When it comes to compensation, private equity funds typically charge a management fee, which is a percentage of the committed capital, to cover operational expenses. In addition, they also receive a share of the profits generated by the investments, known as carried interest. Carried interest is usually calculated as a percentage of the fund's profits above a certain threshold, often referred to as the "hurdle rate."

### Dividend Distribution

During the life of the fund, the general partner may occasionally distribute interim dividends to the limited partners, who are the investors in the fund. These interim dividends are typically funded by profits generated from the portfolio companies or from the sale of certain investments. However, the primary focus remains on generating capital gains rather than distributing regular dividends. These dividend distributions can be via stable coin transfer or token minting. These distributions are handled within the smart contract itself.

### Waterfall Distributions

The waterfall distribution is a common method used in private equity and venture capital funds to allocate profits among the fund's investors, particularly the general partner (GP) and limited partners (LPs). The term "waterfall" refers to the sequential manner in which profits are distributed. Once the GP has caught up to its specified share, the remaining profits are typically shared between the GP and LPs based on a pre-determined split ratio. Common ratios include the 80/20 or 70/30 splits, favoring the LPs.

It's important to note that the specific terms of the waterfall distribution, including the preferred return rate, GP catch-up threshold, and profit-sharing ratios, are negotiated and documented in the fund's partnership agreement. Different funds may have different structures and variations in their waterfall distributions.

The waterfall distribution model ensures that LPs receive a return on their investment and that the GP's share of profits is aligned with their performance and the success of the investments made by the fund.

## Specification

```solidity
// SPDX-License-Identifier: CC0-1.0

pragma solidity ^0.8.0;

interface IFund {

    // @dev Updates the price of the Net Asset Value (NAV) by fetching the latest price from the API Consumer contract.
    // @return The updated NAV price as a uint256 value.
    // Users of the EIP should create an instance of the APIConsumer contract using the apiConsumer storage variable. 
    // The APIConsumer contract should be able to use an external oracle service, such as Chainlink, to fetch prices from an off-chain price feed.
    // This function will Fetch the latest price from the API Consumer contract and store it in the NAVLatestPrice storage variable.
    // This function will Return the updated NAVLatestPrice to the caller.
    function updatePrice() external returns (uint256);

    // @dev Relay function that distributes dividends to a list of investors based on their holdings of the token and stable coin.
    // @param _dividend The total amount of dividend to be distributed.
    // @param _investors An array of addresses representing the investors to whom the dividend will be distributed to.
    // @param _key An array of uint8 values representing the type of distribution (0 for token-based, 1 for stable coin-based) for each investor.
    // @param _from The address from which the stable coin will be transferred from, in case of stable coin-based distribution.
    // @param _stableCoin The address of the stable coin contract used for stable coin-based dividend distribution.
    // @param _finalDistribution A boolean flag indicating if this is the final dividend distribution event.
    // @dev The maximum number of investors per batch should be limited to 150 to prevent out-of-gas errors.
    // @dev The dividend value is required to be greater than 0.
    // @dev The token contract and the stable coin contract should be deployed and accessible before calling this function.
    // @dev For each investor, the amount of tokens to be minted or stable coins to be transferred is calculated based on their holdings.
    function dividendDistribution(uint256 _dividend, address[] calldata _investors, uint8[] calldata _key, address _from, address _stableCoin, bool _finalDistribution) external;

    // @dev Executes a waterfall distribution for a specific capital call.
    // @param callNo The number representing the specific capital call for which the distribution is being performed.
    // @param _investmentAmount The total investment amount for this capital call.
    // @param _investors An array of addresses representing the investors to whom the distribution will be made.
    // @param _return The preferred return percentage for this capital call.
    // @dev Only callable by the agent who is responsible for the waterfall distributions.
    // @dev The investment amount should be greater than 0.
    // Iterates over each investor and performs the distribution and token burning.
    // @dev Calculates and sets the principal amount for each investor based on their share in the total paid-up amount for the specified capital call.
    // @dev Calculates and sets the preferred return for each investor based on their principal amount and the preferred return percentage.
    // @dev Calculates the total tokens that to the burned.
    // @dev Calculates the tokens that to be burned from every investor and burns the tokens.
    function waterfallDistribution(uint8 callNo, uint256 _investmentAmount, address[] calldata _investors, uint256 _return) external;
    
}
```

## Rationale

This standard is dedicated to revolutionizing the traditional Capital call process that has been in use for over a century. By adopting the new ERC standard, we aim to automate dividend payments, capital calls, and Waterfall distribution on-chain. This, in turn, enhances efficiency and provides complete transparency to investors regarding asset valuations, performance, and ownership information. When companies seek regulated security tokens for Private Equity funds on the Blockchain, this standard proves invaluable.

The ERC standard is designed to address various challenges faced by companies in traditional private equity, including:

1) Speed to market
2) Cost of raising investments
3) Accessibility to general investors
4) Transparency to Limited Partners (LPs) and Auditors
5) Distributing dividends in Stable Coins, Security Tokens, or Fiat
6) Waterfall distribution using Stable Coins or Fiat

With the implementation of fund-specific smart contracts, this standard simplifies the entire Private Equity investment cycle for different stakeholders, such as General Partners (GPs), Limited Partners (LPs), and Issuers.

## Reference Implementation

```solidity
// SPDX-License-Identifier: CC0-1.0

pragma solidity ^0.8.0;

import 'contracts/interface/IFund.sol';
import 'contracts/periphery/roles/AgentRoleFund.sol';
import "contracts/periphery/storage/FundStorage.sol";
import "contracts/interface/IToken.sol";
import "contracts/interface/IAPIConsumer.sol";
import "contracts/periphery/APIConsumer.sol";
import "contracts/libraries/TransferHelper.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "contracts/interface/ITokenFactory.sol";


contract Fund is Initializable, IFund, AgentRoleFund, FundStorage {

    function init(address _token, string calldata _fundName, address fmAddress, 
                uint8 _assetType, 
                string calldata _issuerName, 
                uint256 _targetAUM,
                uint128 _NAVLaunchPrice, string calldata _NAVEndPoint) external initializer{
        _transferOwnership(msg.sender);
        addAgent(msg.sender);
        factory = address(msg.sender);

        fundName = _fundName;
        token = _token;
        fundManagerAddress = fmAddress;
        assetType = _assetType;
        issuerName = _issuerName;
        targetAUM = _targetAUM;
        NAVLaunchPrice = _NAVLaunchPrice;
        issueDate = block.timestamp;

        address _apiConsumer = address(new APIConsumer(_NAVEndPoint));
        setConsumer(_apiConsumer);
    }

    function addUserManagementFee(address[] calldata _address, uint256[] calldata _fee) public onlyAgent{
        require(_address.length == _fee.length, "Invalid Input");
        for(uint8 i =0; i < _address.length; i++){
            managementFee[_address[i]] = _fee[i];
        }
    }

    function _addUserDividend(address _address, uint256 _dividend, uint8 _key) internal{
            if(_key == 0){
                dividend[_address].Token = _dividend;
            }
            else if(_key == 1){
                dividend[_address].StableCoin = _dividend;
            }
            else {
                dividend[_address].Fiat = _dividend;
            }
    }

    function setConsumer(address _Consumer) public onlyAgent{
        apiConsumer =_Consumer;
    }
    function getNAV() external returns (uint256){
        IAPIConsumer api = IAPIConsumer(apiConsumer);
        NAVLatestPrice = api.getPrice();
        return NAVLatestPrice;
    }

    function getAUM() external returns (uint256){
        IToken mytoken = IToken(token);
        uint256 circulatingSupply = mytoken.circulationSupply();
        AssetUnderManagement = circulatingSupply * NAVLatestPrice;
        return AssetUnderManagement;
    }

    function getManagementFee(address _userAddress) external view returns(uint256){
        return managementFee[_userAddress];
    }

    function updateFundManager(address _newFundManager) public onlyAgent{
        require(_newFundManager != address(0), "Zero Address not Allowed");
        fundManagerAddress = _newFundManager;
    }

    function updateTerm(uint256 _newTerm) public onlyAgent{
        require(_newTerm > 0,"Invalid Term");
        termOfFund = _newTerm;
    }

    function updateFundCurrency(string calldata _newCurrency) public onlyAgent{
        fundCurrency = _newCurrency;
    }

    function updateDividendCycle(uint256 _newCycle) public onlyAgent{
        require(_newCycle > 0, "Invalid input");
        dividendCycle = _newCycle;
    }

    function updateIRR(uint _newIRR) public onlyAgent{
        iRR = _newIRR;
    }

    function updateManagementFees(address _userAddress, uint256 _updatedFees) public onlyAgent{
        require(_userAddress != address(0), "Invalid Address");
        managementFee[_userAddress] = _updatedFees;
    }

    function updateNAVEndPoint(string calldata _newEndPoint) public onlyAgent{
        IAPIConsumer api = IAPIConsumer(apiConsumer);
        api.updateEndpoint(_newEndPoint);
    }

    function getStableCoin(uint8 coin) external view returns(address stableCoin){
        ITokenFactory fcty = ITokenFactory(factory);
        stableCoin = fcty.getStableCoin(coin);
    }

    function shareDividend(address[] calldata _address, uint256[] calldata _dividend, address _from, uint8[] calldata _key, uint8 coin) public onlyAgent{
        require(_address.length == _dividend.length && _dividend.length == _key.length, "Invalid Input");
        
        ITokenFactory fcty = ITokenFactory(factory);
        stableCoin = fcty.getStableCoin(coin);
        for(uint i=0; i<_address.length; i++){
        if(_key[i] == 0 ){
            IToken(token).mint(_address[i], _dividend[i]);
        }
        else if(_key[i] == 1){
            TransferHelper.safeTransferFrom(stableCoin, _from, _address[i], _dividend[i]);
        }
        _addUserDividend(_address[i], _dividend[i], _key[i]);
        }
    }

    function distributeAndBurn(address[] calldata _investors, uint256[] calldata _amount, uint256[] calldata _tokens, address _from, uint8 coin) public onlyAgent{
        require(_investors.length == _amount.length && _amount.length == _tokens.length, "Invalid Input");

        IToken tkn = IToken(token);
        ITokenFactory fcty = ITokenFactory(factory);
        stableCoin = fcty.getStableCoin(coin);

        for(uint i = 0; i < _investors.length; i++){

            tkn.burn(_investors[i], _tokens[i]);

            TransferHelper.safeTransferFrom(stableCoin, _from, _investors[i], _amount[i]);
        }
    }

    function rescueAnyERC20Tokens(
        address _tokenAddr,
        address _to,
        uint128 _amount
    ) external onlyAgent {
        SafeERC20Upgradeable.safeTransfer(
            IERC20Upgradeable(_tokenAddr),
            _to,
            _amount
        );
    }
}
```

## Security Considerations

We have considered and used several security measures to our contract standard like access control with different roles along with multi-sig functionality. 

## Copyright
