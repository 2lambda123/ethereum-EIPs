---
eip: 7331
title: Private Equity
description: A private equity fund Contract distributes dividends of a private equity fund in stable coins or in fund tokens as per the user's choice.
author: Oasis Pro Markets (@tokenizeassets)
discussions-to: https://ethereum-magicians.org/t/a-proposal-for-private-equity-and-funds-smart-contract/14681
status: Draft
type: Standards Track
category: ERC
created: 2023-07-04
requires: 20, 3643
---

## Abstract

A private equity fund is a type of investment fund that pools together capital from high-net-worth individuals, institutional investors, and sometimes, pension funds to make investments in private companies. These funds are managed by private equity firms, which specialize in acquiring ownership stakes in companies and actively managing them to generate returns.

## Motivation

The existing investment landscape faces multiple challenges, including high investment barriers, limited liquidity, lengthy settlement processes, regulatory compliance issues, counterparty risks, and concerns over custodial control. These barriers prevent individuals from taking control of their investments, diversifying their portfolios, and accessing the benefits of a secure and efficient investment ecosystem. There is a pressing need for a comprehensive solution that addresses these challenges, providing a tokenization platform that sidesteps investment barriers, establishes an unceasing liquid marketplace with the instant settlement, ensures regulatory compliance, eliminates counterparty risks, and enables self-custody, empowering users to make informed investment decisions, access diverse opportunities, and maintain full control over their assets.

Management Fee
When it comes to compensation, private equity funds typically charge a management fee, which is a percentage of the committed capital, to cover operational expenses. In addition, they also receive a share of the profits generated by the investments, known as carried interest. Carried interest is usually calculated as a percentage of the fund's profits above a certain threshold, often referred to as the "hurdle rate."

Dividend Distribution
During the life of the fund, the general partner may occasionally distribute interim dividends to the limited partners, who are the investors in the fund. These interim dividends are typically funded by profits generated from the portfolio companies or from the sale of certain investments. However, the primary focus remains on generating capital gains rather than distributing regular dividends. These dividend distributions can be via stable coin transfer, token minting, or via fiat currency. These distributions are handled within the smart contract itself.

Waterfall Distributions
The waterfall distribution is a common method used in private equity and venture capital funds to allocate profits among the fund's investors, particularly the general partner (GP) and limited partners (LPs). The term "waterfall" refers to the sequential manner in which profits are distributed. Once the GP has caught up to its specified share, the remaining profits are typically shared between the GP and LPs based on a pre-determined split ratio. Common ratios include the 80/20 or 70/30 splits, favoring the LPs.

It's important to note that the specific terms of the waterfall distribution, including the preferred return rate, GP catch-up threshold, and profit-sharing ratios, are negotiated and documented in the fund's partnership agreement. Different funds may have different structures and variations in their waterfall distributions.

The waterfall distribution model ensures that LPs receive a return on their investment and that the GP's share of profits is aligned with their performance and the success of the investments made by the fund.

## Specification

```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

interface IFund {

    function init(address _token, string calldata _fundName, address fmAddress, 
                uint8 _assetType, 
                string calldata _issuerName, 
                uint256 _targetAUM,
                uint128 _NAVLaunchPrice, string calldata _NAVEndPoint) external;

    /**
    * @dev Adds management fees for multiple addresses.
    * @param _address An array of addresses for which management fees will be set.
    * @param _fee An array of corresponding management fees.
    * onlyAgent modifier ensures that only authorized agents can call this function.
    * Checks if the length of _address is equal to the length of _fee, indicating valid input.
    * Iterates over each address and sets the corresponding management fee.
    * Assumes that managementFee mapping is already initialized.
    */
    function addUserManagementFee(address[] calldata _address, uint256[] calldata _fee) external;

    /**
    @dev Internal function to add dividends for a specific address.
    @param _address The address for which dividends will be added.
    @param _dividend The amount of dividends to be added.
    @param _key The key indicating the type of dividends: 0 for Token, 1 for StableCoin, and any other value for Fiat.
    Checks the value of _key to determine the type of dividends to add.
    If _key is 0, sets the Token dividends for the address.
    If _key is 1, sets the StableCoin dividends for the address.
    If _key is any other value, sets the Fiat dividends for the address.
    Assumes that the dividend mapping is already initialized.
    This function is internal and can only be called within the contract.
    */
    function _addUserDividend(address _address, uint256 _dividend, uint8 _key) external;

    /**
    @dev Sets the APIConsumer contract address.
    @param _Consumer The address of the APIConsumer contract.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Sets the apiConsumer variable with the provided address.
    */
    function setConsumer(address _Consumer) external;

    /**
    @dev Retrieves the management fee for a specific user address.
    @param _userAddress The address of the user.
    @return The management fee associated with the user address.
    This function is callable externally and returns the management fee for the specified user address.
    */
    function getManagementFee(address _userAddress) external view returns(uint256);

    /**
    @dev Calculates and returns the Assets Under Management (AUM) of the fund.
    Multiplies the circulating supply by the latest Net Asset Value (NAV) price to calculate the AUM.
    Assumes that the NAVLatestPrice and token variables are already initialized.
    Returns the calculated AUM.
    This function is callable externally.
    */
    function getAUM() external returns (uint256);

    /**
    @dev Retrieves the latest Net Asset Value (NAV) price from the APIConsumer contract.
    Updates the NAVLatestPrice variable with the retrieved value.
    Returns the updated NAVLatestPrice.
    Assumes that the apiConsumer variable is already initialized.
    This function is callable externally.
    */
    function getNAV() external returns (uint256);

    /**
    @dev Updates the address of the fund manager.
    @param _newFundManager The new address of the fund manager.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Requires that the new fund manager address is not the zero address.
    Updates the fundManagerAddress variable with the new address.
    */
    function updateFundManager(address _newFundManager) external;

    /**
    @dev Updates the term of the fund.
    @param _newTerm The new term value for the fund.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Requires that the new term is greater than 0.
    Updates the termOfFund variable with the new term value.
    */
    function updateTerm(uint256 _newTerm) external;

    /**
    @dev Updates the currency of the fund.
    @param _newCurrency The new currency for the fund.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Updates the fundCurrency variable with the new currency value.
    */
    function updateFundCurrency(string calldata _newCurrency) external;

    /**
    @dev Updates the dividend cycle of the fund.
    @param _newCycle The new dividend cycle for the fund.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Requires that the new dividend cycle is greater than 0.
    Updates the dividendCycle variable with the new cycle value.
    */
    function updateDividendCycle(uint256 _newCycle) external;

    /**
    @dev Updates the Internal Rate of Return (IRR) of the fund.
    @param _newIRR The new IRR value for the fund.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Updates the iRR variable with the new IRR value.
    */
    function updateIRR(uint _newIRR) external;

    /**
    @dev Updates the management fees for a specific user address.
    @param _userAddress The address of the user for which the management fees will be updated.
    @param _updatedFees The new management fees for the user.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Requires that the user address is not the zero address.
    Updates the managementFee mapping for the specified user address with the new fees.
    */
    function updateManagementFees(address _userAddress, uint256 _updatedFees) external;

    /**
    @dev Updates the API endpoint for retrieving the Net Asset Value (NAV) data.
    @param _newEndPoint The new API endpoint for NAV data.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Calls the updateEndpoint() function of the APIConsumer contract to update the endpoint.
    Assumes that the apiConsumer variable is already initialized.
    */
    function updateNAVEndPoint(string calldata _newEndPoint) external;

    /**
    @dev Retrieves the address of the stablecoin at the specified index.
    @param coin The index of the stablecoin.
    @return stableCoin The address of the stablecoin at the specified index.
    Calls the getStableCoin() function of the ITokenFactory contract to get the stablecoin address.
    Assumes that the factory variable is already initialized.
    This function is callable externally and returns the address of the stablecoin.
    */
    function getStableCoin(uint8 coin) external view returns(address stableCoin);

    /**
    @dev Shares dividends with multiple addresses.
    @param _address An array of addresses to receive dividends.
    @param _dividend An array of corresponding dividend amounts.
    @param _from The address from which the dividends are sent.
    @param _key An array of keys indicating the type of dividends: 0 for Token, 1 for StableCoin, and any other value for Fiat.
    @param coin The index of the stablecoin to use.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Requires that the length of _address, _dividend, and _key arrays are the same.
    Retrieves the address of the stablecoin at the specified index.
    Iterates over each address and shares the corresponding dividends.
    If the key is 0, mints the token dividends to the address.
    If the key is 1, transfers the stablecoin dividends from _from address to the recipient address.
    Calls the _addUserDividend() function to add the dividends to the recipient's record.
    Assumes that the token, factory, and _addUserDividend() function are already initialized.
    */
    function shareDividend(address[] calldata _address, uint256[] calldata _dividend, address _from, uint8[] calldata _key, uint8 coin) external;

    /**
    @dev Distributes funds and burns tokens for multiple investors.
    @param _investors An array of investor addresses.
    @param _amount An array of corresponding fund amounts to distribute.
    @param _tokens An array of corresponding token amounts to burn.
    @param _from The address from which the funds are sent.
    @param coin The index of the stablecoin to use.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Requires that the length of _investors, _amount, and _tokens arrays are the same.
    Retrieves the address of the stablecoin at the specified index.
    Iterates over each investor and performs the distribution and token burning.
    Burns the specified amount of tokens from the investor's balance.
    Transfers the corresponding amount of funds from _from address to the investor's address.
    Assumes that the token, factory, and TransferHelper.safeTransferFrom() function are already initialized.
    */
    function distributeAndBurn(address[] calldata _investors, uint256[] calldata _amount, uint256[] calldata _tokens, address _from, uint8 coin) external;

    /**
    @dev Rescues any ERC20 tokens accidentally sent to the contract.
    @param _tokenAddr The address of the ERC20 token to be rescued.
    @param _to The address to which the rescued tokens will be transferred.
    @param _amount The amount of tokens to be rescued.
    onlyAgent modifier ensures that only authorized agents can call this function.
    Uses the SafeERC20Upgradeable library to safely transfer the specified amount of tokens to the specified address.
    Assumes that the _tokenAddr is a valid ERC20 token address.
    This function is callable externally.
    */
    function rescueAnyERC20Tokens(address _tokenAddr, address _to, uint128 _amount) external;
}
```

## Rationale

## Reference Implementation

```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

import 'contracts/interface/IFund.sol';
import 'contracts/periphery/roles/AgentRoleFund.sol';
import "contracts/periphery/storage/FundStorage.sol";
import "contracts/interface/IToken.sol";
import "contracts/interface/IAPIConsumer.sol";
import "contracts/periphery/APIConsumer.sol";
import "contracts/libraries/TransferHelper.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "contracts/interface/ITokenFactory.sol";


contract Fund is Initializable, IFund, AgentRoleFund, FundStorage {

    function init(address _token, string calldata _fundName, address fmAddress, 
                uint8 _assetType, 
                string calldata _issuerName, 
                uint256 _targetAUM,
                uint128 _NAVLaunchPrice, string calldata _NAVEndPoint) external initializer{
        _transferOwnership(msg.sender);
        addAgent(msg.sender);
        factory = address(msg.sender);

        fundName = _fundName;
        token = _token;
        fundManagerAddress = fmAddress;
        assetType = _assetType;
        issuerName = _issuerName;
        targetAUM = _targetAUM;
        NAVLaunchPrice = _NAVLaunchPrice;
        issueDate = block.timestamp;

        address _apiConsumer = address(new APIConsumer(_NAVEndPoint));
        setConsumer(_apiConsumer);
    }

    function addUserManagementFee(address[] calldata _address, uint256[] calldata _fee) public onlyAgent{
        require(_address.length == _fee.length, "Invalid Input");
        for(uint8 i =0; i < _address.length; i++){
            managementFee[_address[i]] = _fee[i];
        }
    }

    function _addUserDividend(address _address, uint256 _dividend, uint8 _key) internal{
            if(_key == 0){
                dividend[_address].Token = _dividend;
            }
            else if(_key == 1){
                dividend[_address].StableCoin = _dividend;
            }
            else {
                dividend[_address].Fiat = _dividend;
            }
    }

    function setConsumer(address _Consumer) public onlyAgent{
        apiConsumer =_Consumer;
    }
    function getNAV() external returns (uint256){
        IAPIConsumer api = IAPIConsumer(apiConsumer);
        NAVLatestPrice = api.getPrice();
        return NAVLatestPrice;
    }

    function getAUM() external returns (uint256){
        IToken mytoken = IToken(token);
        uint256 circulatingSupply = mytoken.circulationSupply();
        AssetUnderManagement = circulatingSupply * NAVLatestPrice;
        return AssetUnderManagement;
    }

    function getManagementFee(address _userAddress) external view returns(uint256){
        return managementFee[_userAddress];
    }

    function updateFundManager(address _newFundManager) public onlyAgent{
        require(_newFundManager != address(0), "Zero Address not Allowed");
        fundManagerAddress = _newFundManager;
    }

    function updateTerm(uint256 _newTerm) public onlyAgent{
        require(_newTerm > 0,"Invalid Term");
        termOfFund = _newTerm;
    }

    function updateFundCurrency(string calldata _newCurrency) public onlyAgent{
        fundCurrency = _newCurrency;
    }

    function updateDividendCycle(uint256 _newCycle) public onlyAgent{
        require(_newCycle > 0, "Invalid input");
        dividendCycle = _newCycle;
    }

    function updateIRR(uint _newIRR) public onlyAgent{
        iRR = _newIRR;
    }

    function updateManagementFees(address _userAddress, uint256 _updatedFees) public onlyAgent{
        require(_userAddress != address(0), "Invalid Address");
        managementFee[_userAddress] = _updatedFees;
    }

    function updateNAVEndPoint(string calldata _newEndPoint) public onlyAgent{
        IAPIConsumer api = IAPIConsumer(apiConsumer);
        api.updateEndpoint(_newEndPoint);
    }

    function getStableCoin(uint8 coin) external view returns(address stableCoin){
        ITokenFactory fcty = ITokenFactory(factory);
        stableCoin = fcty.getStableCoin(coin);
    }

    function shareDividend(address[] calldata _address, uint256[] calldata _dividend, address _from, uint8[] calldata _key, uint8 coin) public onlyAgent{
        require(_address.length == _dividend.length && _dividend.length == _key.length, "Invalid Input");
        
        ITokenFactory fcty = ITokenFactory(factory);
        stableCoin = fcty.getStableCoin(coin);
        for(uint i=0; i<_address.length; i++){
        if(_key[i] == 0 ){
            IToken(token).mint(_address[i], _dividend[i]);
        }
        else if(_key[i] == 1){
            TransferHelper.safeTransferFrom(stableCoin, _from, _address[i], _dividend[i]);
        }
        _addUserDividend(_address[i], _dividend[i], _key[i]);
        }
    }

    function distributeAndBurn(address[] calldata _investors, uint256[] calldata _amount, uint256[] calldata _tokens, address _from, uint8 coin) public onlyAgent{
        require(_investors.length == _amount.length && _amount.length == _tokens.length, "Invalid Input");

        IToken tkn = IToken(token);
        ITokenFactory fcty = ITokenFactory(factory);
        stableCoin = fcty.getStableCoin(coin);

        for(uint i = 0; i < _investors.length; i++){

            tkn.burn(_investors[i], _tokens[i]);

            TransferHelper.safeTransferFrom(stableCoin, _from, _investors[i], _amount[i]);
        }
    }

    function rescueAnyERC20Tokens(
        address _tokenAddr,
        address _to,
        uint128 _amount
    ) external onlyAgent {
        SafeERC20Upgradeable.safeTransfer(
            IERC20Upgradeable(_tokenAddr),
            _to,
            _amount
        );
    }
}
```

## Security Considerations

We have considered and used several security measures to our contract standard like access control with different roles along with multi-sig functionality. 

## Copyright
