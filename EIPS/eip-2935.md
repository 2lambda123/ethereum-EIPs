---
eip: 2935
title: Serve historical block hashes from state
description: Store and serve last 8192 block hashes as storage slots of a system contract to allow for stateless execution
author: Vitalik Buterin (@vbuterin), Tomasz Stanczak (@tkstanczak), Guillaume Ballet (@gballet), Gajinder Singh (@g11tech), Tanishq Jasoria (@tanishqjasoria), Ignacio Hagopian (@jsign), Jochem Brouwer (@jochem-brouwer)
discussions-to: https://ethereum-magicians.org/t/eip-2935-save-historical-block-hashes-in-state/4565
status: Draft
type: Standards Track
category: Core
created: 2020-09-03
---

## Abstract

Store last `HISTORY_SERVE_WINDOW` historical block hashes in a contract, and in a subsequent fork, modify the `BLOCKHASH (0x40)` opcode to read and serve from this contract storage.

## Motivation

Currently `BLOCKHASH` opcode accesses history to resolve hash of the block number in EVM. However a more stateless client friendly way is to maintain and serve these hashes from state.

Although this is possible even in Merkle trie state, but Verkle trie state further allows bundling the `BLOCKHASH` witnesses (along with other witnesses) in an efficient manner making it worthwhile to have these in state.

A side benefit of this approach could be that it allows building/validating proofs related to last `HISTORY_SERVE_WINDOW` ancestors directly against the current state.

## Specification

| Parameter                 | Value                                        |
| ------------------------- | -------------------------------------------- |
| `FORK_TIMESTAMP`          | TBD                                          |
| `VERKLE_FORK_TIMESTAMP`   | TBD                                          |
| `HISTORY_STORAGE_ADDRESS` | `0x25a219378dad9b3503c8268c9ca836a52427a4fb` |
| `HISTORY_SERVE_WINDOW`    | `8192`                                       |
| `BLOCKHASH_OLD_WINDOW`    | `256`                                        |

This EIP specifies for storing last `HISTORY_SERVE_WINDOW` block hashes in a ring buffer storage of `HISTORY_SERVE_WINDOW` length.

At the start of processing any block where `block.timestamp >= FORK_TIMESTAMP` (ie. before processing any transactions), begin storing the blockhashes in the following way:

```python
def process_block_hash_history(block: Block, state: State):
    if block.timestamp >= FORK_TIMESTAMP:
        state.insert_slot(HISTORY_STORAGE_ADDRESS, (block.number-1) % HISTORY_SERVE_WINDOW , block.parent.hash)
```

Note that from the `fork_block` (first block where `block.timestamp >= FORK_TIMESTAMP`), the implementation of `BLOCKHASH` does not change. The blockhashes of the last `BLOCKHASH_OLD_WINDOW` blocks can be retrieved as they previously were. `BLOCKHASH` will return `0` for blocks preceding the `BLOCKHASH_OLD_WINDOW`.

Blockhashes from the `HISTORY_SERVE_WINDOW` can be retrieved directly from storage for blocks whose `block.number + 1 >= fork_block`.

From the `verkle_fork_block` (first block where `block.timestamp >= VERKLE_FORK_TIMESTAMP`), the `BLOCKHASH` instruction should be updated to retrieve the requested blockhash from the contract storage.

From the `verkle_fork_block`, switch the `BLOCKHASH` logic to:

```python
def resolve_blockhash(block: Block, state: State, arg: uint64):
  # check the wrap around range
  if arg >= block.number or (arg + HISTORY_SERVE_WINDOW) < block.number
    return 0

  return state.load_slot(HISTORY_STORAGE_ADDRESS, arg % HISTORY_SERVE_WINDOW)
```

<!-- TODO: Do we need to update the implementation because there is not history backfilling? -->

### Contract Implementation

Exact evm assembly that can be used for the contract to resolve `BLOCKHASH` from verkle_block_fork

```
// check if input > 8 byte value and revert if this isn't the case
// the check is performed by comparing the biggest 8 byte number with
// the call data, which is a right-padded 32 byte number.
push8 0xffffffffffffffff
push0
calldataload
gt
push1 0x39
jumpi

// check if input > blocknumber-1 then return 0
push1 0x1
number
sub
push0
calldataload
gt
push1 0x31
jumpi

// check if blocknumber > input + 8192 then return 0, no overflow expected for input of 8 bytes
push0
calldataload
push2 0x2000
add
number
gt
push1 0x31
jumpi

// mod 8192 and sload
push2 0x1FFF
push0
calldataload
and
sload

// load into mem and return 32 bytes
push0
mstore
push1 0x20
push0
return

// return 0
jumpdest
push0
push0
mstore
push1 0x20
push0
return

// revert
jumpdest
push0
push0
revert

stop
```

Note that the input contract read `32` bytes input as `calldataload`. Users and clients doing EVM call to this contract should left pad the `arg` correctly.

<!-- TODO: bytecode is based off on first version and will be updated once assembley is locked down as it changes contract sender and address -->

Corresponding bytecode:
`60203611603157600143035f35116029575f356120000143116029576120005f3506545f5260205ff35b5f5f5260205ff35b5f5ffd00`

#### Deployment

A special synthetic address is generated by working backwards from the desired deployment transaction:

```json
{
  "type": "0x0",
  "nonce": "0x0",
  "to": null,
  "gas": "0x3d090",
  "gasPrice": "0xe8d4a51000",
  "maxPriorityFeePerGas": null,
  "maxFeePerGas": null,
  "value": "0x0",
  "input": "0x60368060095f395ff360203611603157600143035f35116029575f356120000143116029576120005f3506545f5260205ff35b5f5f5260205ff35b5f5ffd00",
  "v": "0x1b",
  "r": "0x539",
  "s": "0x1b9b6eb1f0",
  "hash": "7ba81426bfa88a2cf4ea5c9abbbe83619505acd1173bc8450f93cf17cde3784b"
}
```

Note, the input in the transaction has a simple constructor prefixing the desired runtime code.

The sender of the transaction can be calculated as `0xa4690f0ed0d089faa1e0ad94c8f1b4a2fd4b0734`. The address of the first contract deployed from the account is `rlp([sender, 0])` which equals `0x25a219378dad9b3503c8268c9ca836a52427a4fb`. This is how `HISTORY_STORAGE_ADDRESS` is determined. Although this style of contract creation is not tied to any specific initcode like create2 is, the synthetic address is cryptographically bound to the input data of the transaction (e.g. the initcode).

Some fork (blocks where `block.timestamp >= FORK_TIMESTAMP`) activation scenarios:

- For the fork to be activated at genesis, no history is written to the genesis state, and at the start of block `1`, genesis hash will be written as a normal operation to slot `0`.
- for fork activation at block `1`, only genesis hash will be written at slot `0`.
- for fork activation at block `32`, block `31`'s hash will be written to slot `31`. Additional history for block `0..30` hashes will continue to be served, but will not be backfilled into storage.
- for fork activation at block `10000`, block `9999`'s hash will be written to slot `9999`. Additional history for the the `BLOCKHASH_OLD_WINDOW` (`9744..9998`) will continue to be served, but will not be backfilled into storage. History for the blocks preceding the `HISTORY_SERVE_WINDOW` (`1808..9998`) will not be served, and will not be backfilled into storage. At block `20000`, the BLOCKHASH opcode would continue serving history for the `BLOCKHASH_OLD_WINDOW` (`19744..19999`) and would return 0 for blocks before the `BLOCKHASH_OLD_WINDOW`. The blocks from `HISTORY_SERVE_WINDOW` would be served from state for blocks `11808..19999`. Blocks prior to the `HISTORY_SERVE_WINDOW` would return 0.

For verkle-fork (blocks where `block.timestamp >= VERKLE_FORK_TIMESTAMP`), we consider that the fork (`FORK_TIMESTAMP`) is already in effect for at least `HISTORY_SERVE_WINDOW` blocks (or from genesis if `verkle_fork_block < HISTORY_SERVE_WINDOW`). The following changes take effect:

- `BLOCKHASH` MUST retrieve blockhashes from the contract storage
- The gas cost of the `BLOCKHASH` opcode is updated as per specification
- The storage access is provided in the verkle execution witness.

### [EIP-158](./eip-158.md) handling

This address is currently exempt from [EIP-158](./eip-158.md) cleanup in Kaustinen Verkle Testnet but we plan to address this in the following way:

- Deploy a contract Ã  la [EIP-4788](./eip-4788.md) which just supports `get` method to resolve the BLOCKHASH as per the logic defined in `resolve_blockhash` (and use the generated address as the BLOCKHASH contract address).
- While the clients are expected to directly read from state (or maintain and serve from memory) to resolve BLOCKHASH opcode, this contract's `get` could be invoked by transaction (via another contract or directly) leading to a normal contract execution (and gas consumption) as per the semantics of the contract call.

### Gas costs and witnesses

At FORK_TIMESTAMP, gas cost of `BLOCKHASH` remains unchanged. At VERKLE_FORK_TIMESTAMP, gas cost of `BLOCKHASH` is the existing cost of `BLOCKHASH`, in additional to the corresponding warm or cold `SLOAD` cost.

At VERKLE_FORK_TIMESTAMP, the corresponding storage access witness for the blockhash `SLOAD` lookups must also included in the execution witness, along with their access gas charges.

## Rationale

Very similar ideas were proposed before in [EIP-210](./eip-210.md) et al. This EIP is a simplification, removing three sources of needless complexity:

1. Having a tree-like structure with multiple layers as opposed to a single list
2. Writing the EIP in EVM code
3. Serial unbounded storage of hashes for a deep access to the history

However after weighing pros and cons, we decided to go with just a limited ring buffer to only serve the requisite `HISTORY_SERVE_WINDOW` as [EIP-4788](./eip-4788.md) and beacon state accumulators allow (albeit a bit more complex) proof against any ancestor since merge.

Second concern was how to best transition the BLOCKHASH resolution logic post fork by:

1. Either waiting for `HISTORY_SERVE_WINDOW` blocks for the entire relevant history to persist
2. Storing of all last `HISTORY_SERVE_WINDOW` block hashes on the fork block.

<!-- TODO: Explain why we are choosing the former -->

## Backwards Compatibility

The behavior of `BLOCKHASH` opcode gets extended in a backward compatible manner as its functionality, and its gas cost, remains the same from `FORK_TIMESTAMP`. The blockhashes from `BLOCKHASH_OLD_WINDOW` can still be retrieve with `BLOCKHASH`. The additional history can be directly retrieve from the contract storage. From `VERKLE_FORK_TIMESTAMP`, `BLOCKHASH` will serve history for all blocks from `HISTORY_SERVE_WINDOW` from the contract storage address at the updated gas cost.

## Test Cases

TBD

## Reference Implementation

- PR 28878 of go-ethereum
- Active on verkle-gen-devnet-5 for its verkle implementation

## Security Considerations

Having contracts (system or otherwise) with hot update paths (branches) poses a risk of "branch" poisioning attacks where attacker could sprinkle trivial amounts of eth around these hot paths (branches). But it has been deemed that cost of attack would escalate significantly to cause any meaningful slow down of state root updates.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
