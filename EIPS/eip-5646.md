---
eip: 5646
title: Token state fingerprint
description: Define a way how to distinguish between different states of the same token without implementation details.
author: Naim Ashhab (@ashhanai)
discussions-to: todo
status: Draft
type: Standards Track
category: ERC
created: 2022-09-11
requires: 165, 721
---

## Abstract
Extend ERC721 standard with new function `getStateFingerprint`, which returns a unique 32 bytes fingerprint of a token state. This enables distinguishing between different states of the same token and referencing a specific token state without knowing anything about its state structure. It does not define *how* should be state fingerprint computed or stored.

## Motivation
More and more non-fungible tokens are starting to be "dynamic" in a sense, that the owner can change tokens state, which could affect tokens intrinsic value. A lot of marketplaces have to start taking this into account when managing users offers to buy or accept a particular token as a collateral.

Currently there is no UX friendly way to prevent cases, where a lender makes an offer to a dynamic NFT and borrower withdraws most of its value before accepting the offer. One solution is to use wrapper / bundler, to disable owners' right to modify tokens state, but this brings additional inconveniences. It costs unnecessary gas and users cannot use tokens utility, that doesn't change tokens state (voting rights, NFT gate access, airdrops).

Instead of using wrappers, marketplaces can use state fingerprints as a part of an offer. In that case, an offer that was made to a token in one state, would be invalid for the same token (same token id) in a different state.

Some attempts to standardize token state already existed in the past, for example [Non-Fungible Token State Verification](https://github.com/ethereum/EIPs/issues/1180) and some tokens already implemented similar functions in their contracts, see [MokensDelegate](https://etherscan.io/address/0x8e332fe4df2876cce3b9e6cab160c61ef4c31f77#code)s function `getStateHash(uint256 _tokenId) public view returns (bytes32 stateHash)`. Unfortunately, no ERC standard of this kind has been adopted to this day.

###  Type of dynamic tokens
- tokenized LP positions (Uniswap v3)
- gaming assets (CryptoKitties)
- dynamic wrappers / bundlers

### Use cases
- NFT marketplace orders / offers
- on-chain metadata uri updates
- front running

## Specification
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The standard defines one view function.
```solidity
pragma solidity ^0.8.0;

interface ERC5646 is IERC721 {

	/// @notice Function to return current token state fingerprint.
	/// @param tokenId Id of a token state in question.
	/// @return Current token state fingerprint.
	function getStateFingerprint(uint256 tokenId) external view returns (bytes32);
}
```

This standard doesn't define *how* should be the `getStateFingerprint` function implemented.

State fingerprint MUST be different for a different token state.
State fingerprint MUST be the same for the same token state.
State fingerprint MUST include all parameters that change the intrinsic value of a token.
Two state fingerprints of two different token contracts MUST NOT be compared between each other.
State fingerprint MUST NOT be used as a sole token identifier and MUST be used with at least token contract address and token id, to identify a token.
Function `supportsInterface(bytes4)` MUST return `true` for input `0xf5112315`.
Token uri MAY be included in a state fingerprint, but it's rather encouraged to implement [EIP-4906](./eip-4906.md) for that purpose.

## Rationale
To be as flexible as possible, this standard doesn't define *how* should be the `getStateFingerprint` function implemented. Simple hash of an abi encoded state parameters is expected to be enough as a state fingerprint, though some tokens could implement a more gas efficient way for their specific state. Some implementations could compute the fingerprint on the fly, where another can store it and update its value with every state-mutating call.

It is not necessary to prevent state fingerprint collision between two different token contracts as state fingerprints should be compared in a context of one token contract. Because of that, implementation could be more light-weight than, for example, [EIP-712](./eip-712.md), which has to define domain separator to prevent this case. It is encouraged to use state fingerprints as a part of EIP-712 type struct though.

This standard, contrary to [EIP-1948](./eip-1948.md), doesn't define a function for directly updating state fingerprints. The intention is to update state fingerprints only via state-mutating calls.

In comparison to [Non-Fungible Token State Verification](https://github.com/ethereum/EIPs/issues/1180), this standard leaves the decision, which state parameters should be included in a state fingerprint, to token developers. This should lead to easier adoption of the standard as marketplaces don't have to compose the state fingerprint themselves.

On the other hand, this standard requires token contracts to implement the `getStateFingerprint` function, which immutable deployed tokens cannot retrospectively do. (Here is definitely more space for research on how to enable state fingerprints for existing tokens).

## Backwards Compatibility
This ERC is extending the existing ERC721 token standard and is not introducing any backward incompatibilities.

It works well with other standards extending ERC721. Take [ERC4400](./eip-4400.md) as an example. Consumer address can be included in a state fingerprint and every time a new consumer is set, state fingerprint would be updated too, enabling other contracts to identify token state updates without any knowledge of a token implementation.

## Reference Implementation
Example implementation of a LP token with stored state fingerprint.
```solidity
pragma solidity ^0.8.0;

/// @title Example of a token with stored state fingerprint.
contract LPTokenStored is ERC721, ERC5646 {

	uint256 lastTokenId;

	/// @dev Stored token states (token id => state).
	mapping (uint256 => State) internal states;
	/// @dev Stored state fingerprints (token id => state fingerprint).
	mapping (uint256 => bytes32) internal stateFingerprint;

	struct State {
		address asset1;
		address asset2;
		uint256 amount1;
		uint256 amount2;
		uint256 fee;
		address operator;
	}


	constructor() ERC721("LPTokenStored", "LPTS") {}


	function mint(State calldata state) external {
		uint256 tokenId = ++lastTokenId;

		states[tokenId] = state;
		bytes32 fingerprint = _computeStateFingerprint(states[tokenId]);
		stateFingerprint[tokenId] = fingerprint;

		_mint(msg.sender, tokenId);
	}

	/// @dev State mutable function.
	/// @param tokenId Id of a token that should change operator.
	/// @param newOperator Address of a new operator.
	function changeOperator(uint256 tokenId, address newOperator) external {
		require(ownerOf(tokenId) == msg.sender);

		states[tokenId].operator = newOperator;
		bytes32 fingerprint = _computeStateFingerprint(states[tokenId]);
		stateFingerprint[tokenId] = fingerprint;
	}


	/// @dev State fingerprint getter.
	/// @param tokenId Id of a token state in question.
	/// @return Current token state fingerprint.
	function getStateFingerprint(uint256 tokenId) override external view returns (bytes32) {
		return stateFingerprint[tokenId];
	}


	/// @dev Compute state fingerprint.
	/// @param state Struct with necessary state data.
	/// @return Computed fingerprint of a given state.
	function _computeStateFingerprint(State storage state) internal view returns (bytes32) {
		return keccak256(
			abi.encode(
				state.asset1,
				state.asset2,
				state.amount1,
				state.amount2,
				state.fee,
				state.operator
			)
		);
	}

	function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {
		return super.supportsInterface(interfaceId) ||
			interfaceId == type(ERC5646).interfaceId;
	}

}

```

Example implementation of a LP token with computed state fingerprint.
```solidity
pragma solidity ^0.8.0;

/// @title Example of a token with computed state fingerprint.
contract LPTokenComputed is ERC721, ERC5646 {

	uint256 lastTokenId;

	/// @dev Stored token states (token id => state).
	mapping (uint256 => State) internal states;

	struct State {
		address asset1;
		address asset2;
		uint256 amount1;
		uint256 amount2;
		uint256 fee;
		address operator;
		uint256 expiration; // Parameter dependent on a block.timestamp
	}


	constructor() ERC721("LPTokenComputed", "LPTC") {}


	function mint(State calldata state) external {
		uint256 tokenId = ++lastTokenId;

		states[tokenId] = state;

		_mint(msg.sender, tokenId);
	}

	/// @dev State mutable function.
	/// @param tokenId Id of a token that should change operator.
	/// @param newOperator Address of a new operator.
	function changeOperator(uint256 tokenId, address newOperator) external {
		require(ownerOf(tokenId) == msg.sender);

		states[tokenId].operator = newOperator;
	}


	/// @dev State fingerprint getter.
	/// @param tokenId Id of a token state in question.
	/// @return Current token state fingerprint.
	function getStateFingerprint(uint256 tokenId) override public view returns (bytes32) {
		State storage state = states[tokenId];

		return keccak256(
			abi.encode(
				state.asset1,
				state.asset2,
				state.amount1,
				state.amount2,
				state.fee,
				state.operator,
				block.timestamp < state.expiration ? false : true
			)
		);
	}

	function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {
		return super.supportsInterface(interfaceId) ||
			interfaceId == type(ERC5646).interfaceId;
	}

}
```

## Security Considerations
Security assumptions are based on a token implementation of a `getStateFingerprint` function. In cases where a token doesn't include all parameters that could change the intrinsic value of a token, there is still a possibility for a token owner to accept an offer / order after decreasing token value.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).
