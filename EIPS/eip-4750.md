---
eip: 4750
title: EOF - Functions
description: Individual sections for functions with `CALLF` and `RETF` instructions
author: Andrei Maiboroda (@gumb0), Alex Beregszaszi (@axic), Paweł Bylica (@chfast), Greg Colvin (@gcolvin), Brooklyn Zelenka (@expede)
discussions-to: https://ethereum-magicians.org/t/eip-4750-eof-functions/8195
status: Draft
type: Standards Track
category: Core
created: 2022-01-10
requires: 3540, 3670
---

## Abstract

Introduce the ability to have several code sections in EOF-formatted ([EIP-3540](./eip-3540.md)) bytecode, each one representing a separate subroutine/function. Two new opcodes,`CALLF` and `RETF`, are introduced to call and return from such a function.

## Motivation

Currently in the EVM everything is a dynamic jump. Languages like Solidity generate most jumps in a static manner (i.e. the destination is pushed to the stack right before, `PUSHn .. JUMP`). Unfortunately however this cannot be used by most EVM interpreters, because of added requirement of validation/analysis. This also restricts them from making optimisations and potentially reducing the cost of jumps.

[EIP-4200](./eip-4200.md) introduces static jump instructions, which remove the need for *most* dynamic jump use cases, but not everything can be solved with them.

This EIP aims to remove the need for dynamic jumps as it offers the most important feature those are used for: calling into and returning from functions. While it removes the need, it does not disallow those instructions.

Furthermore it aims to improve analysis opportunities by encoding the number of inputs and outputs for each given function, and isolating the stack of each function (i.e. a function cannot read the stack of the caller/callee).

## Specification

### EOF container changes

1. The requirement of [EIP-3540](./eip-3540.md) "Exactly one code section MUST be present." is relaxed to "At least one code section MUST be present.", i.e. multiple code sections (`kind = 1`) are allowed.
2. Total number of code sections MUST NOT exceed 1024.
3. All code sections MUST precede a data section, if data section is present.
4. New section with `kind = 3` is introduced called the *type section*.
5. Exactly one type section MUST be present.
6. The type section MUST directly precede all code sections.
7. The type section contains a sequence of pairs of bytes: first byte in a pair encodes number of inputs, and second byte encodes number of outputs of the code section with the same index. *Note:* This implies that there is a limit of 256 stack for the input and in the output.
8. Therefore type section size MUST be `n * 2` bytes, where `n` is the number of code sections.
9. First code section MUST have 0 inputs and 0 outputs. 

To summarize, a well-formed EOF bytecode will have the following format:
```
bytecode := format, magic, version, type_section_header, (code_section_header)+, [data_section_header], 0, type_section_contents, (code_section_contents)+, [data_section_contents]

type_section_header := 3, number_of_code_sections * 2 # section kind and size
type_section_contents := 0, 0, code_section_1_inputs, code_section_1_outputs, code_section_2_inputs, code_section_2_outputs, ..., code_section_n_inputs, code_section_n_outputs
```

### New execution state in EVM

A return stack is introduced, separate from the data stack. It is a stack of items representing execution state to return to after function execution is finished. Each item is comprised of: code section index, offset in the code section (PC value), calling function stack height.

Note: Implementations are free to choose particular encoding for a stack item. In the specification below we assume that representation is three unsigned integers: `code_section_index`, `offset`, `stack_height`.

The return stack is limited to a maximum 1024 items.

Additionally, EVM keeps track of the index of currently executing section - `current_section_index`.

### New instructions

We introduce two new instructions:

1. `CALLF` (`0x5e`)
2. `RETF` (`0x5f`)

If the code is legacy bytecode, both of these instructions result in an *exceptional halt*. (*Note: This means no change to behaviour.*)

First we define several helper values:
- `caller_stack_height = return_stack.top().stack_height` - stack height value saved in the top item of return stack
- `type[i].inputs = type_section_contents[i * 2]` - number of inputs of ith section
- `type[i].outputs = type_section_contents[i * 2 + 1]` - number of outputs of ith section

If the code is valid EOF1, the following execution rules apply:

#### `CALLF` 

1. Has one immediate argument,`code_section_index`, encoded as a 16-bit unsigned big-endian value.
2. If return stack already has `1024` items, execution results in exceptional halt.
3. Pops nothing and pushes nothing to data stack.
4. Pushes to return stack an item:
```
(code_section_index = current_section_index, 
offset = PC_post_instruction,
stack_height = data_stack.height - types[code_section_index].inputs)
```

Under `PC_post_instruction` we mean the PC position after the entire immediate argument of `CALLF`. Data stack height is saved as it was before function inputs were pushed.

*Note:* Code validation rules of EIP-3670 guarantee there is always an instruction following `CALLF` (since terminating instruction is required to be final one in the section), therefore `PC_post_instruction` always points to an instruction inside section bounds.

6. Sets `current_section_index` to `code_section_index` and `PC` to `0`, and execution continues in the called section.

#### `RETF`

1. Does not have immediate arguments.
2. Pops nothing and pushes nothing to data stack.
3. Pops an item from return stack and sets `current_section_index` and `PC` to values from this item.
    4.1. If return stack is empty after this, execution halts with success.

### Code Validation

If the execution of an instruction would violate a condition, then the execution is in an exceptional halting state. The [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) defines five such states.
1. Insufficient gas
2. More than 1024 stack items
3. Insufficient stack items
4. Invalid jump destination
5. Invalid instruction

We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state.  In practice, we must test at runtime for conditions 1 and 2 —- sufficient gas and sufficient stack.  We don’t know how much gas there will be, we don’t know how deep a recursion may go, and analysis of stack depth even for non-recursive programs is nontrivial.  All of the remaining conditions MUST be validated statically, in time and space linear in the size of the code.

In addition to container format validation rules above, we extend code section validation rules (as defined in [EIP-3670](./eip-3670.md)).

1. Code validation rules of EIP-3670 are applied to every code section.
2. List of allowed *terminating instructions* in EIP-3670 is extended to include `RETF`. (*Note that `CALLF`, like other instructions with immediates, cannot be truncated.*)
3. Code section is invalid in case an immediate argument of any `CALLF` is greater than or equal to the total number of code sections.
4. `RJUMP` and `RJUMPI` immediate argument value (jump destination relative offset) validation:
   * 4.1. Code section is invalid in case offset points to a position outside of section bounds.
   * 4.2. Code section is invalid in case offset points to one of two bytes directly following `CALLF` instruction.
5. Before a `CALLF` the frame size is at least the `n_args` of that specified in the header.
6. Before a `RETURN` the frame size has changed by `n_results - n_args since the corresponding CALLF.
7. For every offset in the code the frame size is constant and greater than zero.

Rules 1 through 4 can be validated with a simple scan of the bytecode.

Rules 5, 6, and 7 require a symbolic execution of the code -- a Reference Implentation is given below.

### Execution

1. Execution starts at the first byte of the first code section, and PC is set to 0.
2. Return stack is initialized to contain one item: `(code_section_index = 0, offset = 0, stack_height = 0)`
3. Destinations of jumps are allowed only to be inside current code section. `JUMP` and `JUMPI` result in exceptional halt when destination is outside of current section bounds.
4. If any instruction would access a data stack item below `caller_stack_height`, execution results in exceptional halt. This rule replaces the old stack underflow check.

#### Implications on the JUMPDEST analysis

- Analysis is done separately for each section, i.e. output of entire analysis is `number_of_code_sections` lists of possible jump destinations.
- Analysis is extended to consider 2 bytes directly following `CALLF` to be invalid jump destination

## Rationale

### `RETF` in the top frame ends execution vs exceptionally halts

Alternative logic for executing `RETF` in the top frame could be to exceptionally halt execution, because there is arguably no caller for the starting function. This would mean that the return stack is initialized as empty, and `RETF` exceptionally aborts when the return stack is empty.

We have decided in favor of always having at least one item in the return stack, because it allows to avoid having a special case for empty stack in the interpreter loop stack underflow check. We keep the stack underflow rule general by having `caller_stack_height = 0` in the top frame.

## Backwards Compatibility

This change poses no risk to backwards compatibility, as it is introduced only for EOF1 contracts, for which deploying undefined instructions is not allowed, therefore there are no existing contracts using these instructions. The new instructions are not introduced for legacy bytecode (code which is not EOF formatted).

The new execution state and multi-section control flow pose no risk to backwards compatibility, because it is a generalization of executing a single code section. Executing existing contracts (both legacy and EOF1) has no user-observable changes.

## Reference Implementation

The following pseudo-C function lays out an algorithm for validating that EVM code satisfies rule 5, 6, and 7 above, assuming that all preceding rules are followed.  It is a symbolic execution of the `bytecode` that is linear in time and space.  This algorithm does not consider the code’s data and computations, only its control flow and stack use.  This means we will reject programs with invalid code paths, even if those paths are not reachable.  This algorithm is an acyclic traversal of the directed graph formed by calls, returns, and jumps.  Cycles are broken when a vertex which has already been visited is reached.  The complexity of this traversal is `O(|E|+|V|)`: The sum of the number of edges and number of vertices in the graph.

A call to `validate_subroutine(0, 0, 0)`, will traverse all of the reachable `bytecode`, recursing when `CALLF`, `JUMP` and `JUMPI` instructions are encountered  and returning when it reaches a destination that has been visited before.  It returns true if the subroutine is valid, false otherwise.

```
    bytecode[code_size]     // contains EVM bytecode to validate
    frame_size[code_size ]  // is filled with -1

    // * PC is the offset in the code to start validating at
    // * return_pc is the top PC on return stack that RETURNSUB returns to
    validate_subroutine(PC, return_pc, SP)
    {
        // traverse code sequentially, recurse for jumps
        while true
        {
            instruction = bytecode[PC]

            // if frame size set we have been here before
            if frame_size[PC] >= 0
            {
                // check for constant frame size
                if SP != frame_size[PC]
                    return false

                // return to break cycle
                return true
            }
            frame_size[PC] = SP

            // effect of instruction on stack size
            n_removed = removed_items(instruction)
            n_added = added_items(instruction)

            // apply net effect of removing and adding stack items
            SP -= n_removed
            if SP < 0
                return false             // stack underflow
            SP += n_added
            if SP >= 1024                // stack overflow (not all will be caught)
                return false

            switch (instruction)
            {
            case STOP, RETURN, SUICIDE:
                return true
            case RETURNF:                // return to top or from recursion
                return true
            case CALLF:                  // check for enough arguments
                sub_pc = sub_target(PC)
                if SP < n_args(sub_pc)
                    return false
                return_pc = next_PC(PC)
                if not
                    validate_subroutine(sub_pc, return_pc, SP)
                        return false
            case RJUMP:                  // reset PC to destination of jump
                PC = jump_target(PC)
                continue
            case RJUMPI:                 // recurse to jump to code to validate
                jmp_pc = jmp_pc(PC)
                if SP < n_args(sub_pc)
                    return false
                return_pc = next_PC(PC)
                  if not
                      validate_subroutine(jmp_pc, return_pc, SP)
                          return false
            }
            
            // advance PC according to instruction and immediates
            PC = advance_pc(PC)
        }

        // check for right number of results
        if (SP != n_results(return_pc)
            return false
        return true
    }
```

 _Note: Python translation welcomed with gratitude._

## Security Considerations

For our purposes we define a safe EVM contract as one that cannot encounter an exceptional halting state. From the standpoint of security it would be best if unsafe contracts were never placed on the blockchain. Unsafe code can attempt to overflow stack, underflow stack, execute invalid instructions, and jump to invalid locations.  Unsafe code is an exploit waiting to happen.  We cannot guarantee that all valid code is safe, but we can guarantee that valid code will not jump to invalid locations, execute invalid instructions, or underflow stack. Further, valid code will always call and return with the specified frame size.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
