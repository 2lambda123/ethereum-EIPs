---
eip: 3369
title: Apply minor modifications to the Ethash algorithm to break current ASIC implementations
status: Draft
type: Standards Track
category: Core
author: mineruniter969 (@mineruniter969), mineruniter969 <mineruniter969@tutanota.com>
created: 2021-03-13
---

# Simple Summary

This EIP proposes minor modifications to the current Ethash PoW algorithm to kick ASICs out of the network.

# Abstract

This EIP is to kick current ASIC implementations out of the network to keep the Ethereum network secure and healthy.

# Motivation

ASICs provide a severe centralization risk for the Ethereum network. If we do not get rid of them, small GPU miners will be forced to exit the Ethereum mining because EIP-1559 will make them mining at a loss. Furthermore, ASIC production will be concentrated only at one or two parties, which will make the Ethereum hashrate centralized. Also, it is worth noting that Ethash ASIC machines cost 10k+ USD, while GPUs are priced less than 1000 USD.

With GPUs, miners can switch to other mining algorithms, but with ASICs, it is impossible. Leaving everything as-is will almost certainly a very tough (from the side of miners) integration of the Ethereum 2.0.

In short, this EIP is required to keep the Ethereum network stable and decentralized by keeping the ASIC business away.

# Specification

If `block.number >= ETHASH11_BLKNUM`, activate the `ethash1.1` algorithm version.

## ethash1.1

The changes done are minor yet effective to break ASIC implementations.

Right now, `fnv` hash function is used throughout the `hashimoto` function. `fnv` is identical for all steps, `ethash1.1` will introduce additional `fnvA`, `fnvB`, `fnvC`, `fnvD`, and `fnvE` functions. All those functions will have different FNV constants.

```c
// Previously used FNV prime
#define FNV_PRIME_0 0x1000193

// New FNV primes
#define FNV_PRIME_A 0x10001a7
#define FNV_PRIME_B 0x10001ab
#define FNV_PRIME_C 0x10001cf
#define FNV_PRIME_D 0x10001e3
#define FNV_PRIME_E 0x10001f9
```

The FNV prime selection is based on David Stanfill's work on EIP-969.

Right now, all parts of Ethash are using the `fnv` (hereinafter referenced as `fnv0`) function. This EIP proposes a change in this area. `fnvA` replaces fnv in the DAG item selection step; `fnvB` replaces `fnv0` in the DAG item mix step; `fnvC(fnvD(fnvE` replaces `fnv0(fnv0(fnv0(` in the compress mix step. `fnv0` in the DAG generation step should remain unchanged to keep previous DAGs valid.

# Backwards compatibility

This EIP is not backward-compatible. Ethereum users and Mining Pools will be required to upgrade their software to support `ethash1.1`.

## Reference Implementation

```go
// This implementation is based on the github.com/ethereum/go-ethereum code and is licensed under the Lesser GNU General Public License v3

func fnv0(a, b uint32) uint32 {
    return a*0x01000193 ^ b
}

func fnvA(a, b uint32) uint32 {
    return a*0x10001a7 ^ b
}

func fnvB(a, b uint32) uint32 {
    return a*0x10001ab ^ b
}

func fnvC(a, b uint32) uint32 {
    return a*0x10001cf ^ b
}

func fnvD(a, b uint32) uint32 {
    return a*0x10001e3 ^ b
}

func fnvE(a, b uint32) uint32 {
    return a*0x10001f9 ^ b
}

// fnvHash mixes in data into mix using the ethash fnv method.
func fnvHash(mix []uint32, data []uint32, fnvFunc func(a, b uint32) uint32) {
    for i := 0; i < len(mix); i++ {
        mix[i] = fnvFunc(mix[i], data[i])
    }
}


// generateDatasetItem combines data from 256 pseudorandomly selected cache nodes,
// and hashes that to compute a single dataset node.
func generateDatasetItem(cache []uint32, index uint32, keccak512 hasher) []byte {
    // Calculate the number of theoretical rows (we use one buffer nonetheless)
    rows := uint32(len(cache) / hashWords)

    // Initialize the mix
    mix := make([]byte, hashBytes)

    binary.LittleEndian.PutUint32(mix, cache[(index%rows)*hashWords]^index)
    for i := 1; i < hashWords; i++ {
        binary.LittleEndian.PutUint32(mix[i*4:], cache[(index%rows)*hashWords+uint32(i)])
    }
    keccak512(mix, mix)

    // Convert the mix to uint32s to avoid constant bit shifting
    intMix := make([]uint32, hashWords)
    for i := 0; i < len(intMix); i++ {
        intMix[i] = binary.LittleEndian.Uint32(mix[i*4:])
    }
    // fnv it with a lot of random cache nodes based on index
    for i := uint32(0); i < datasetParents; i++ {
        parent := fnv0(index^i, intMix[i%16]) % rows
        fnvHash(intMix, cache[parent*hashWords:], fnv0)
    }
    // Flatten the uint32 mix into a binary one and return
    for i, val := range intMix {
        binary.LittleEndian.PutUint32(mix[i*4:], val)
    }
    keccak512(mix, mix)
    return mix
}

// hashimoto aggregates data from the full dataset in order to produce our final
// value for a particular header hash and nonce.
func hashimoto(hash []byte, nonce uint64, size uint64, lookup func(index uint32) []uint32) ([]byte, []byte) {
    // Calculate the number of theoretical rows (we use one buffer nonetheless)
    rows := uint32(size / mixBytes)

    // Combine header+nonce into a 64 byte seed
    seed := make([]byte, 40)
    copy(seed, hash)
    binary.LittleEndian.PutUint64(seed[32:], nonce)

    seed = crypto.Keccak512(seed)
    seedHead := binary.LittleEndian.Uint32(seed)

    // Start the mix with replicated seed
    mix := make([]uint32, mixBytes/4)
    for i := 0; i < len(mix); i++ {
        mix[i] = binary.LittleEndian.Uint32(seed[i%16*4:])
    }
    // Mix in random dataset nodes
    temp := make([]uint32, len(mix))

    for i := 0; i < loopAccesses; i++ {
        parent := fnvA(uint32(i)^seedHead, mix[i%len(mix)]) % rows
        for j := uint32(0); j < mixBytes/hashBytes; j++ {
            copy(temp[j*hashWords:], lookup(2*parent+j))
        }
        fnvHash(mix, temp, fnvB)
    }
    // Compress mix
    for i := 0; i < len(mix); i += 4 {
        mix[i/4] = fnvC(fnvD(fnvE(mix[i], mix[i+1]), mix[i+2]), mix[i+3])
    }
    mix = mix[:len(mix)/4]

    digest := make([]byte, common.HashLength)
    for i, val := range mix {
        binary.LittleEndian.PutUint32(digest[i*4:], val)
    }
    return digest, crypto.Keccak256(append(seed, digest...))
}
```


# Implementations

- [Go](https://github.com/mineruniter969/ethash1.1-go)
- [C (Python/JS wrapped)](https://github.com/mineruniter969/ethash1.1-c)
- Ethminer - TBD

# Test Vectors

See [mineruniter969/ethash1.1-tests](https://github.com/mineruniter969/ethash1.1-tests)

# Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
