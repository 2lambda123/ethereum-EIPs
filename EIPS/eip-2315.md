---
eip: 2315
title: Simple Subroutines for the EVM
status: Draft
type: Standards Track
category: Core
author: Greg Colvin
discussions-to: https://ethereum-magicians.org/t/eip-2315-simple-subroutines-for-the-evm/3941
created: 2019-10-17
---
## Abstract

This proposal introduces two opcodes to support subroutines:  `JUMPSUB` and `RETSUB`.

## Motivation

The EVM does not provide subroutines as a primitive.  Instead, calls must be synthesized by fetching and pushing the current program counter on the data stack and jumping to the subroutine address; returns must be synthesized by getting the return address to the top of stack and jumping back to it.

## Specification

##### `JUMPSUB`
Jumps to the address on top of the stack, which must be a `JUMPDEST`.

##### `RETSUB`
Returns to the most recently executed `JUMPSUB` instruction.

## Rationale

This is the smallest possible change that provides native subroutines without breaking backwards compatibility.

This proposal does not enforce validity like [EIP-615](https://eips.ethereum.org/EIPS/eip-615) 
 - having very little to enforce - but code that
* pushes a constant argument before every `JUMP`, `JUMPI` and `JUMPSUB`,
* ensures that the _data stack_ is the same size at every execution of each `JUMP`, `JUMPI`, `JUMPSUB` or `JUMPDEST` operation,
* and meets some other obvious conditions

will meet all of the [EIP-615](https://eips.ethereum.org/EIPS/eip-615) safety conditions.

## Backwards Compatibility

These changes do not affect the semantics of existing EVM code.

## Test Cases
```
0: PUSH 3     // before jumpsub: PC = 1; SP = 1
1: JUMPSUB    // after jumpsub:  PC = 3; SP = 0
2 PUSH 5      // after push: PC =3; SP =1
3: JUMPDEST   // before retsub:  PC = 3; SP = 0
4: RETSUB     // after retsub:   PC = 1; SP = 0
5: STOP
```
## Implementations

No clients have implemented this proposal as of yet.

The new operators proposed here are implemented by the following pseudocode, which adds cases for `JUMPSUB` and `RETSUB` to a simple loop-and-switch interpreter.
```
bytecode[code_size]
data_stack[1024]
return_stack[1024]
while PC < code_size {
   switch opcode = bytecode[PC] {
   ...
   case JUMPSUB:
       push(return_stack, PC)
       PC = pop(data_stack)
   case RETSUB:
       PC = pop(return_stack)
   ...
   }
   ++PC
}
```
Execution of EVM bytecode begins with one value on the return stackâ€”the size of the bytecode. The virtual byte of 0 at this offset is the EVM `STOP` opcode, so executing a `RETSUB` with no prior `JUMPSUB` executes a `STOP`.  A `STOP` or `RETURN` ends the execution of the subroutine and the program.

We suggest the cost of `JUMPSUB` should be _low_, and `RETSUB` should be _verylow_. 
 Measurement will tell.  We suggest the following opcodes:
```
0xbe JUMPSUB
0xbf RETSUB
```
## Security Considerations

This proposal introduces no new security considerations to the EVM.

**Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).**
