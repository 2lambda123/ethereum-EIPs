---
eip: 2315
title: Simple Subroutines for the EVM
status: Draft
type: Standards Track
category: Core
author: Greg Colvin
discussions-to: https://github.com/ethereum/EIPs/issues/2315
created: 2019-10-17
---
## Abstract

This proposal introduces two opcodes to support subroutines:  `JUMPSUB` and `RETSUB`.

## Motivation

The EVM does not provide subroutines as a primitive.  Instead, calls must be synthesized by fetching and pushing the current program counter on the data stack and jumping to the subroutine address; returns must be synthesized by getting the return address to the top of stack and jumping back to it.

## Specification

**_JUMPSUB_**

* Jumps to the address on top of the stack.  This must be a `JUMPDEST`.

**_RETSUB_**

* Returns to the most recently executed `JUMPSUB` instruction.

## Rationale

This is the smallest possible change that provides native subroutines without breaking backwards compatibility.  It does not enforce validity like [EIP-615](https://eips.ethereum.org/EIPS/eip-615), but code that
* pushes a constant argument before every `JUMP`, `JUMPI` and `JUMPSUB`
* ensures that the _data stack_ is the same size at every execution of each `JUMP`, `JUMPI`, `JUMPSUB` or `JUMPDEST` operation.

is valid and will meet all of the [EIP-615](https://eips.ethereum.org/EIPS/eip-615) safety conditions.  In particular, the Yellow paper defines five exceptional halting states.  
1. Insufficient gas
2. More than 1024 stack items
3. Insufficient stack items
4. Invalid jump destination
5. Invalid instruction

Valid code cannot violate states 3, 4, or 5.

## Backwards Compatibility

These changes do not affect existing EVM code.

## Test Cases
```
PUSH 4     // before jumpsub: PC = 3
JUMPSUB    // after jumpsub:  PC = 4
JUMPDEST   // before retsub:  PC = 4
RETSUB     // after retsub:   PC = 3
```
## Implementations

No clients have implemented this proposal as of yet.  Constraints on all implementation are given here.

Jumps to and returns from subroutines are described here in terms of
* The EVM _bytecode array_ and _data stack_, (as defined in the [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)).
* The EVM  _program counter_ `PC` which is the byte offset of the currently executing instruction in the _bytecode_array_.
* A new _return stack_ of up to 1024  _program counters_.

The new execution semantics proposed her are implemented by the following pseudocode, which adds cases for `JUMPSUB` and `RETSUB` to a simple loop-and-switch interpreter.
```
  while PC < size(bytecode) {
       switch opcode = bytecode[PC] {
       ...
       case JUMPSUB:
           push(return_stack, PC)
           PC = pop(data_stack)
       case RETSUB:
           PC = pop(return_stack)
       ...
       }
       ++PC
   }
```
Execution of EVM bytecode begins with one value on the return stackâ€”the size of the bytecode. The virtual byte of 0 at this offsetis the EVM to `STOP` opcode.  Thus executing a `RETSUB` with no prior `JUMPSUB` executes a `STOP`.  A `STOP` or `RETURN` ends the execution of the subroutine and the program.

We suggest the cost of `JUMPSUB` should be _low_, and `RETSUB` should be _verylow_. 
 Measurement will tell.  We suggest the following opcodes:
```
0xbe JUMPSUB
0xbf RETSUB
```
## Security Considerations

This proposal introduces no new security considerations to the EVM.

**Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).**
