---
eip: 3155
title: EVM trace specification
author: Martin Holst Swende (@holiman), Marius van der Wijden (@MariusVanDerWijden)
discussions-to: https://ethereum-magicians.org/t/eip-3155-create-evm-trace-specification/5007
status: Draft
type: Standards Track
category (*only required for Standard Track): Interface
created: 2020-12-07
---

<!--You can leave these HTML comments in your merged EIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new EIPs. Note that an EIP number will be assigned by an editor. When opening a pull request to submit your EIP, please use an abbreviated title in the filename, `eip-draft_title_abbrev.md`. The title should be 44 characters or less.-->

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Provide a simplified and layman-accessible explanation of the EIP.-->
This EIP introduces a new JSON standard for EVM traces. There has been a de-facto standard which is used by go-ethereum, OpenEthereum, Besu and Nethermind. This document shall document this standard as well as provide stricter guidelines to make new implementations easier.

## Motivation
<!--The motivation is critical for EIPs that want to change the Ethereum protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the EIP solves. EIP submissions without sufficient motivation may be rejected outright.-->
The Ethereum Virtual Machine executes all smart contract code on ethereum. In order to easier debug smart contracts and state tests, a de-facto standard was introduced to log every execution step of the EVM. This standard was implemented by go-ethereum, parity and nethermind and Besu. Since the de-facto standard was not well defined, the implementations differed slightly making it hard to develop adequate tooling.
This EIP has multiple objectives:
- Move the specification to a more visible place to encourage new clients to implement it
- Strictly define corner cases that were not addressed in the previous version
- Allow for updates to the specification in case new fields are introduced during execution
- Provide sample output

Implementing this EIP in all major clients allows us to create meaningful differential fuzzers that fuzz EVM implementations for the mainnet and all upcoming hardforks.
It also helps finding differences in execution quickly in the case of a chain split.

Due to the slight differences in output the following fields currently need to be dropped when comparing tracing outputs: $GasCost$, $MemorySize$, $RefundCounter$, $ReturnStack$, and $ReturnData$. This reduces the usefulness of tracing significantly. Creating a common standard would allow to add these fields thus increasing the surface that can be tested by a fuzzer.

## Specification
<!--The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Ethereum platforms (go-ethereum, parity, cpp-ethereum, ethereumj, ethereumjs, and [others](https://github.com/ethereum/wiki/wiki/Clients)).-->
Clients should be able to execute simple transactions as well as code and return traces. In the following, we will call this client CUT (client under test) and use go-ethereums `evm` binary for code examples. 

### Inputs

The CUT MUST be able to execute a statetest as described [here](https://www.ethdocs.org/en/latest/contracts-and-transactions/ethereum-tests/state_tests/index.html).
Example :
``` 
evm --json --nomemory statetest foobar.json 
```
The CUT MUST spit out jsonl as defined below, and it MUST also report the final `stateRoot` hash after executing the test. The CUT SHOULD report whether the tests succeeded or failed.

If the statetest contains a Fork identifier (e.g. `Berlin` or `Istanbul`) the CUT MUST run the statetest under the chain rules of this fork.

The CUT SHOULD executed statetests if the filenames are written to STDIN. This allows to execute multiple tests on the same instance without having to set up and tear down the client.

### Output

The CUT MUST output a `json` object for EACH operation. The output SHOULD to be printed to STDERR.

Required Fields: 
- `pc` Program Counter
- `op` OpCode
- `gas` Gas left before executing this operation
- `gasCost` Gas cost of this operation
- `stack` Array of all values on the stack
- `depth` Depth of the call stack
- `returnStack` Array of values, Stack of the called function
- `returnData` Data returned by function call
- `refund` Amount of **global** gas refunded
- `memSize` Size of memory array

Optional Fields: 
- `opName` Name of the operation
- `error` Description of an error 
- `memory` Array of all allocated values
- `storage` Array of all stored values

*Example:* 
```
{"pc":0,"op":96,"gas":"0x2540be400","gasCost":"0x3","memory":"0x","memSize":0,"stack":[],"depth":1,"error":null,"opName":"PUSH1"}
```

The `stack`, `memory` and `memSize` are the values _before_ execution of the op. 
All array attributes (`stack`, `returnStack`, `memory`) MUST be initialized to empty arrays ("stack":[],) NOT to null.
If `--nomemory` is passed to the CUT, the `memory` field is omitted (but the `memSize` field has to be printed).
Clients SHOULD implement a way to disable recording the storage as the stateroot includes all storage updates anyway.

The CUT MUST NOT output a line for the `STOP` operation if an error occured:
*Example:* 
```
{"pc":2,"op":0,"gas":"0x2540be3fd","gasCost":"0x0","memory":"0x","memSize":0,"stack":["0x40"],"depth":1,"error":null,"opName":"STOP"}
```

### Summary and error handling

At the end of execution, the CUT MUST print some summerical info, this info SHOULD have the following fields. The summary SHOULD be printed to STDOUT.

Required Fields: 
- `stateRoot` Root of the state trie after executing the transaction
- `output` Return values of the function
- `gasUsed` All gas used by the transaction
- `successful` Bool whether transaction was executed successfully

OptionalFields:
- `time` Time needed to execute the transaction
```
{"stateRoot":"0xd4c577737f5d20207d338c360c42d3af78de54812720e3339f7b27293ef195b7","output":"","gasUsed":"0x3","successful":"true","time":141485}
```

The state test format allows for multiple `postStates` for different forks.
If different `postStates` are present the CUT MUST execute the test according to the rules of the fork sequentially.
It MUST print a trace for each execution as well as an individual summary for each test.


## Rationale
<!--The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->
This EIP is created to enable easier testing of EVM implementations to create a safer ecosystem. It is largely based on the previous non-official documentation for EVM tracing. It tries to cover as many corner cases as possible to enable true client compatibility.
This proposal is heavily influenced by the requirements for [goevmlab](https://github.com/holiman/goevmlab) and our effort to create differential fuzzers for the EVM.

## Backwards Compatibility
<!--All EIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The EIP must explain how the author proposes to deal with these incompatibilities. EIP submissions without a sufficient backwards compatibility treatise may be rejected outright.-->
This EIP is fully backward compatible with ethereum as it only introduces a better tracing infrastructure that is optional for clients to implement.

### Clients
This EIP is fully backward compatible with go-ethereum. OpenEthereum, Besu and Nethermind clients would have to change their JSON output of `openethereum-evm` `evmtool` and `nethtest` slightly do adhere to the new and stricter specs. New clients would need to implement this change if they want to be part of the differential fuzzing group.

## Test Cases
<!--Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.-->
<details><summary>Test cases</summary>

```bash
$evm --code 6040 --json run
{"pc":0,"op":96,"gas":"0x2540be400","gasCost":"0x3","memory":"0x","memSize":0,"stack":[],"depth":1,"error":null,"opName":"PUSH1"}
{"pc":2,"op":0,"gas":"0x2540be3fd","gasCost":"0x0","memory":"0x","memSize":0,"stack":["0x40"],"depth":1,"error":null,"opName":"STOP"}
{"output":"","gasUsed":"0x3","time":141485}
``` 

```json
{
 "TraceTest": {
  "env": {
   "currentCoinbase": "b94f5374fce5edbc8e2a8697c15331677e6ebf0b",
   "currentDifficulty": "0x20000",
   "currentGasLimit": "0x26e1f476fe1e22",
   "currentNumber": "0x1",
   "currentTimestamp": "0x3e8",
   "previousHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
  },
  "pre": {
   "0x00000000000000000000000000000ca1100b1a7e": {
    "code": "0x6040",
    "storage": {},
    "balance": "0x0",
    "nonce": "0x0"
   },
   "0xa94f5374fce5edbc8e2a8697c15331677e6ebf0b": {
    "code": "0x",
    "storage": {},
    "balance": "0xffffffff",
    "nonce": "0x0"
   }
  },
  "transaction": {
   "gasPrice": "0x1",
   "nonce": "0x0",
   "to": "0x00000000000000000000000000000Ca1100b1A7E",
   "data": [
    "0x80e3193e421154d1de1cd3a0b425cc21eaa184eb2ec89a756a8e4624"
   ],
   "gasLimit": [
    "0x7a1200"
   ],
   "value": [
    "0x4862"
   ],
   "secretKey": "0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8"
  },
  "out": "0x",
  "post": {
   "Istanbul": [
    {
     "hash": "3f7878bb9cd21378f7eb0a2d26e24f11abca4709482cc92e31c1a8a9e4aeeed5",
     "logs": "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
     "indexes": {
      "data": 0,
      "gas": 0,
      "value": 0
     }
    }
   ], 
   "Berlin": [
    {
     "hash": "3f7878bb9cd21378f7eb0a2d26e24f11abca4709482cc92e31c1a8a9e4aeeed5",
     "logs": "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
     "indexes": {
      "data": 0,
      "gas": 0,
      "value": 0
     }
    }
   ]
  }
 }
}
```

```bash
$evm --nomemory --json statetest test.json
{"pc":0,"op":96,"gas":"0x79be38","gasCost":"0x3","memory":"0x","memSize":0,"stack":[],"returnStack":[],"returnData":"0x","depth":1,"refund":0,"opName":"PUSH1","error":""}
{"pc":2,"op":0,"gas":"0x79be35","gasCost":"0x0","memory":"0x","memSize":0,"stack":["0x40"],"returnStack":[],"returnData":"0x","depth":1,"refund":0,"opName":"STOP","error":""}
{"output":"","gasUsed":"0x3","time":166351}
{"stateRoot": "3f7878bb9cd21378f7eb0a2d26e24f11abca4709482cc92e31c1a8a9e4aeeed5"}
{"pc":0,"op":96,"gas":"0x79be38","gasCost":"0x3","memory":"0x","memSize":0,"stack":[],"returnStack":[],"returnData":"0x","depth":1,"refund":0,"opName":"PUSH1","error":""}
{"pc":2,"op":0,"gas":"0x79be35","gasCost":"0x0","memory":"0x","memSize":0,"stack":["0x40"],"returnStack":[],"returnData":"0x","depth":1,"refund":0,"opName":"STOP","error":""}
{"output":"","gasUsed":"0x3","time":50655}
{"stateRoot": "3f7878bb9cd21378f7eb0a2d26e24f11abca4709482cc92e31c1a8a9e4aeeed5"}
[
  {
    "name": "TraceTest",
    "pass": true,
    "fork": "Istanbul"
  },
  {
    "name": "TraceTest",
    "pass": true,
    "fork": "Berlin"
  }
]
```

</details>


## Implementation
<!--The implementations must be completed before any EIP is given status "Final", but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of "rough consensus and running code" is still useful when it comes to resolving many discussions of API details.-->
Implementation in [go-ethereum](https://github.com/ethereum/go-ethereum/tree/master/cmd/evm)
Implementation in [OpenEthereum](https://github.com/openethereum/openethereum/tree/master/evmbin)
Implementation in [Besu](https://github.com/hyperledger/besu/tree/master/ethereum/evmtool)
Implementation in [Nethermind](https://github.com/NethermindEth/nethermind/tree/master/src/Nethermind/Nethermind.State.Test.Runner)


## Security Considerations
<!--All EIPs must contain a section that discusses the security implications/considerations relevant to the proposed change. Include information that might be important for security discussions, surfaces risks and can be used throughout the life cycle of the proposal. E.g. include security-relevant design decisions, concerns, important discussions, implementation-specific guidance and pitfalls, an outline of threats and risks and how they are being addressed. EIP submissions missing the "Security Considerations" section will be rejected. An EIP cannot proceed to status "Final" without a Security Considerations discussion deemed sufficient by the reviewers.-->
This EIP will enable users to create better differential fuzzing infrastructure to compare the EVM implementations of all major Ethereum clients against each other. This could help to find new unforseen bugs that are currently present in the client implementations. 
Creating better infrastructure might also enable attackers to find consensus issues easier.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
