---
eip: 3549
title: ERC-721 Metadata Signature Standard
author: Clay Graham <claytantor@gmail.com>
type: Standards Track
category: ERC
status: Proposed
created: 2020-04-26
requires: 165
---

## Simple Summary
Add signing to the metadata standard and required fields.

## Abstract

Recently Tim Schneider, from Artnet posted a great story about how a whitehat hacker managed to trick the blockchain into forging tokens that would forge the Provenance of the originator of the NFT to look as though it was the originating artist.

[NFT Theft](https://news.artnet.com/opinion/sleepminting-nftheft-monsieur-personne-1960744)

I have added a proposal outlined in the article [Solving For Sleepminting](https://claytantor.wordpress.com/2021/04/22/solving-for-sleepminting/)

* Add md5 hash to metadata as verifiable
* Metadata has must be unique for any specific token
* sha256 sig as base64 field 
* Artist must publish public key for public verification

## Motivation

A standard interface allows wallet/broker/auction applications to work with any NFT on Ethereum. Allowing a wallet to create a signature for a metadata payload prior to publishing of the metadata would allow the creator to prove provenance by publishing a public key that is independently verifiable.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.


### **Minting Tokens**

Minting tokens is the act of producing new tokens.
[ERC-721] intentionally does not define specific functions to mint tokens.
This intent comes from the wish not to limit the use of the [ERC-777] standard
as the minting process is generally specific for every token to support verifiable 
signatures.

Nonetheless, the rules below MUST be respected when minting for verifiable signatures:

* Tokens MUST be minted using with a token URL that refers to the published metadata.

* The minter must generate a MD5 hash of the metadata payload prior to signing.

* The MD5 hash is REQUIRED to be unique for every token that requires individual, verifiable Provenance.

* The minter has the ability to use a private key which is RECOMMENDED to come from the wallet to create a signature of the MD5 hash.


The **metadata extension** is REQUIRED for ERC-721 smart contracts that require verification using this standard. This allows your smart contract to be interrogated for its name and for details about the assets which your NFTs represent.

```solidity
/// @title ERC-721 Non-Fungible Token Standard, REQUIRED metadata extension
/// @dev See https://eips.ethereum.org/EIPS/eip-721
///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.
interface ERC721Metadata /* is ERC721 */ {
    /// @notice A descriptive name for a collection of NFTs in this contract
    function name() external view returns (string _name);

    /// @notice An abbreviated name for NFTs in this contract
    function symbol() external view returns (string _symbol);

    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
    ///  3986. The URI may point to a JSON file that conforms to the "ERC721
    ///  Metadata JSON Schema".
    function tokenURI(uint256 _tokenId) external view returns (string);

}
```

This is the "ERC721 Metadata JSON Schema" referenced above.

```json
{
    "title": "Asset Metadata",
    "type": "object",
    "properties": {
        "name": {
            "type": "string",
            "description": "Identifies the asset to which this NFT represents"
        },
        "description": {
            "type": "string",
            "description": "Describes the asset to which this NFT represents"
        },
        "image": {
            "type": "string",
            "description": "A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive."
        },
        "md5": {
            "type": "string",
            "description": "An md5 has of the entire minified json contents of the metadata (minus the m5 and signature fields) this has must be unique from all other tokens under the contract"
        },
        "sig": {
            "type": "string",
            "description": "The sha256 RSA signature of the md5 hash made at time of minting. Requires published public key."
        },      
    }
}
```

### Caveats
It *could* be possible to provide state and signature tracking in the contract implementation but that would probably not scale under many use cases where one contract is being used by many different sources of provenance.

### Possible Implementations

Given an unsigned metadata payload:

```json
{"name":"CryptoLoa 70418a47","description":"Agents that live on the blockchain.","external_url":"http://cryptoloa.com/nfts/2","image":"ipfs://QmQEdpKHxit5zvUpXtVcs5EVha241CTYRhrdp6qSRcuMGL","attributes":[{"display_type":"number","trait_type":"Generation","value":3}],"model":"ipfs://QmUpF2He1Df2kJYq3kUX9mTrvYd9Gmw9yBeTP13BJdR2S1"}
```

during metadata publishing

```javascript 
// using web3 and truffle

metadata.md5 = md5(metadataPayload);
// use the wallet's private key to sign
let sig = web3.eth.sign(metadata.md5, "0x11f4d0A3c12e86B4b5F39B213F7E19D048276DAe")
metadata.sig = sig;

metadataHash = await pinata.pinJSONToIPFS(scriptConfig, metadata);

let nft = await CryptoLoa.deployed();
let mintTx = await nft.mint(toAddress, metadataHash.IpfsHash); 

```

## Rationale

There are many proposed uses of Ethereum smart contracts that depend on tracking distinguishable assets. It is critical in each of these cases that these items are not "lumped together" as numbers in a ledger, but instead each asset must have its ownership individually and atomically tracked *as well as the ability to verifiably trust authorship. Regardless of the nature of these assets, the ecosystem will be stronger if we have a standardized interface that allows for cross-functional asset management and sales platforms that is verifiable.


**Provenance**

Wallets/brokers/auctioneers identified in the motivation section have a strong need to identify which NFTs an owner owns.

It is also identified in the motivation section that being able to identify origin in a manner that provides trust is valuable to the standard. Verified provenance can prove the authenticity of a piece and greatly increase its value.


**Metadata Choices** (metadata extension)

We have required `md5` and `sig` fields in the metadata extension.

Metadata is returned as a string value. Currently this is only usable as calling from `web3`, not from other contracts. This is acceptable because we have not considered a use case where an on-blockchain application would query such information.



## Implementations

0xcert ERC721 -- a reference implementation

- MIT licensed, so you can freely use it for your projects
- Includes test cases
- Active bug bounty, you will be paid if you find errors



## References

**Standards**

1. [ERC-20](./eip-721.md) NFT Token Standard.


**NFT Implementations and Other Projects**

1. CryptoKitties. https://www.cryptokitties.co
1. 0xcert ERC-721 Token. https://github.com/0xcert/ethereum-erc721
1. Su Squares. https://tenthousandsu.com
1. Decentraland. https://decentraland.org
1. CryptoPunks. https://www.larvalabs.com/cryptopunks
1. DMarket. https://www.dmarket.io
1. Enjin Coin. https://enjincoin.io
1. Ubitquity. https://www.ubitquity.io
1. Propy. https://tokensale.propy.com
1. CryptoKitties Deployed Contract. https://etherscan.io/address/0x06012c8cf97bead5deae237070f9587f8e7a266d#code
1. Su Squares Bug Bounty Program. https://github.com/fulldecent/su-squares-bounty
1. XXXXERC721. https://github.com/fulldecent/erc721-example
1. ERC721ExampleDeed. https://github.com/nastassiasachs/ERC721ExampleDeed
1. Curio Cards. https://mycuriocards.com
1. Rare Pepe. https://rarepepewallet.com
1. Auctionhouse Asset Interface. https://github.com/dob/auctionhouse/blob/master/contracts/Asset.sol
1. OpenZeppelin SafeERC20.sol Implementation. https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/SafeERC20.sol

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
