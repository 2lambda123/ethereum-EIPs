---
title: HTTP requests
description: A network implimentation of specialised HTTP requests.
author: Simon James (@JKincorperated)
discussions-to: https://ethereum-magicians.org/t/draft-eip-http-requests-though-smart-contracts/14153
status: Draft
type: Standards Track
category: Core
created: 2023-04-25
---

## Abstract

This EIP allows for smart contracts to make HTTP requests without creating the worlds largest DDOS machine. HTTP endpoints must conform to the specification to prevent forgery.

## Motivation

This EIP allows HTTP requests which should allow for an smoother transition from web2 to web3. While it might seem counter-intuitive to defeat the "true decentralization" of ethereum it should prove to have some major advantages like polling external data sources or creating random data.

## Specification

### Opcode

Opcode: 0xa5
Gas cost: 15000 (minimum)
Inputs:

- Body (string): A selection of data.
- Signature (bytes): The signature of the data
- Domain (string): The domain where the location of the ```_contractkey``` is that signed the data.

Output:

- Verified (bool): True if the data is correctly signed.

Description:
This Opcode must encode the data to bytes using utf-8 and then must hash the Body field with the SHA256. Then, the server must make a DNS query to a TXT located in the domain field at the subdomain ```_contractkey```. This TXT record must contain an ECC P-256 public key which should be used to verify the signature against the data using the fips-186-3 DSS signing algorithm.

Stack Transition:
(before) [Body, Signature, domain]
(after)  [... Verified]

 
### Webserver behaviour
  
To host a webserver supporting this EIP, you must host a TXT DNS record at the "_contractkey" subdomain of the Domain Name that will be hosting the webserver. This record must contain a P-256 ECC public key with all occurances of a newline character replaced with "\\n".

The webserver must firstly encode what it is was going to send to the client and encode it with base64. This encoded data must be encoded to a byte array with utf-8 and then hashed using the SHA-256 hashing algorithm. This hash must be signed using the DSS fips-186-3 algorithm with the private key for the domain, where as the public key is stored in the "_contractkey" DNS record. This signature must be encoded to base64. The webserver should return the following data is JSON format.

  ```
{
  "signature": *The Base64 encoded signature*,
  "body": *the base64 encoded body*
 }
  ```

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

## Rationale

TBD

## Backwards Compatibility

No backward compatibility issues found.

## Test Cases

Opcode : 0xa5

(before) ["Hello World", 0x1234567890, "example.com"]
(after)  [... , true]

In this sense the server should have made a DNS query to the subdomain "\_domainkey.example.com".

## Reference Implementation

Python Flask based server implementation

```

  from flask import Flask
  from Crypto.Hash import SHA256
  from Crypto.PublicKey import ECC
  from Crypto.Signature import DSS
  from flask.json import jsonify
  import base64

  app = Flask(__name__)

  f = open('private-key.pem','rt')
  key = ECC.import_key(f.read())

  def sign(message):
      h = SHA256.new(message.encode("utf-8"))
      signer = DSS.new(key, 'fips-186-3')
      signature = signer.sign(h)
      return jsonify({"signature": base64.b64encode(signature).decode("utf-8"), "body": message})

  @app.route("/")
  def hello_world():
      return sign("Hello World!")

  app.run(debug=True)
  
```
  
Python simple client implementation (with error checking)

```

  import dns.resolver
  import requests
  import json
  from Crypto.Hash import SHA256
  from Crypto.PublicKey import ECC
  from Crypto.Signature import DSS
  import base64
  
  URL = "https://example.com/path"
  
  # Load key from DNS record
  key = ECC.import_key(dns.resolver.resolve("_contractkey." + URL.replace("https://", "").split("/")[0], "TXT")
                       [0].strings[0].decode('utf-8').replace("\\n", "\n").encode('utf-8'))
  
  
  # Make HTTP request
  requests.get(URL)

  # Decode response
  try:
      response = json.loads(request.text)
      signature = base64.b64decode(response["signature"].encode("utf-8"))
      body = response["body"]
  except:
      print("(502, \"\")")

  # Verify signature
  h = SHA256.new(body.encode('utf-8'))
  verifier = DSS.new(key, 'fips-186-3')
  try:
      verifier.verify(h, signature)
      print()
  except ValueError:
      print("(502, \"\")")
      
```

## Security Considerations
  
Making so many DNS queries is inefficient.

Needs discussion.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
