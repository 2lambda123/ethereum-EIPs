---
title: HTTP requests
description: A network implimentation of specialised HTTP requests.
author: Simon James (@JKincorperated)
discussions-to: [<URL>](https://ethereum-magicians.org/t/draft-eip-http-requests-though-smart-contracts/14153)
status: Draft
type: Standards Track
category: Core
created: 2023-04-25
---

## Abstract

This EIP allows for smart contracts to make HTTP requests without creating the worlds largest DDOS machine. HTTP endpoints must conform to the specification to prevent forgery.

## Motivation

This EIP allows HTTP requests which should allow for an smoother transition from web2 to web3. While it might seem counter-intuitive to defeat the "true decentralization" of ethereum it should prove to have some major advantages like polling external data sources or creating random data.

## Specification

### Opcode

Opcode: 0xa5
Gas cost: 15000 (minimum)
Inputs:

- URL (string): The URL of the HTTP request to be made.
- POST (bool): A flag indicating whether the request should be made using the HTTP POST method. If false, the request will be made using the HTTP GET method.
- Headers (string): The headers to be included in the HTTP request.
- BODY (optional) (string): The request body to be included in the HTTP request. This input is optional and should be omitted if no body is required.

Output:

- status (int): The HTTP status code returned by the server.
- data (string): The body of the HTTP response returned by the server.

Description:
Makes an HTTP request to the specified URL with the given headers and request body (if provided), using either the HTTP GET or POST method as specified. The response from the server is pushed onto the stack as two items: the HTTP status code as an int, and the body of the response as a string.

Stack Transition:
(before) [url, post, headers, body (optional)]
(after)  [... status, data]

### Node behaviour
  
Once the opcode is called the following steps must be taken on the node proposing the block.

1. The node must make a DNS request for a TXT record located at the "_contractkey" subdomain of the domain, if no record is found the opcode must return (400, ""). For example if the HTTP request was to example.com\api then a TXT record should be found at the domain _contractkey.example.com.
2. All occurances of "\\n" found in the TXT record must be replaced by a newline character ("\n").
3. This key must be loaded as a P-256 ECC key.
4. The protocol must be HTTPS, if it is not HTTPS then the opcode should return (400, "").
5. The node must make the HTTPS request, if the request does not return in 500ms then the opcode must return (504, "")
6. The HTTPS response body must have a JSON body this JSON body must be decoded, if it does not then the opcode must return (502, "")
7. That decoded object must have the "signature" parameter which is a base64 encoded fips-186-3 DSS signature. If it does not has this parameter then the opcode must return (502, "")
8. The "body" parameter must be hashed using SHA256 and the "utf-8" encoding format.
9. The signature and hash must be verified against the previously loaded key from the DNS record. If the verification failed then the opcode must return (502, "")
10. After the verification of the data has been completed, the "body" parameter of the response should be decoded from base64.
11. On completion on all of these steps the opcode shall return the status code 200 and must return the "body" parameter from the request should be passed as a string. This must be in the format (status, body).
12. The node must store the decoded signature and the encoded body along with the transaction.
  
To verify the block you must :
  
1. The node must make a DNS request for a TXT record located at the "_contractkey" subdomain of the domain, if no record is found the opcode must return (400, ""). For example if the HTTP request was to example.com\api then a TXT record should be found at the domain _contractkey.example.com.
2. All occurances of "\\n" found in the TXT record must be replaced by a newline character ("\n").
3. This key must be loaded as a P-256 ECC key.
4. The "signature" parameter which is a fips-186-3 DSS signature must be loaded from the transaction. If this signature is missing then the proposing node must be striked for proposing an incorrect block.
5. The "body" parameter must be loaded from the transaction and must be hashed using SHA256 and the "utf-8" encoding format. If this field is missing then the proposing node must be striked for proposing an incorrect block.
6. The signature and hash must be verified against the previously loaded key from the DNS record. If the verification failed then the proposing node must be striked for proposing an incorrect block.
7. After the verification of the data has been completed, the "body" parameter of the response should be decoded from base64.
8. On completion on all of these steps the opcode shall return the status code 200 and the decoded "body" parameter from the request should be passed as a string. This must be in the format (status, body).
 
### Webserver behaviour
  
To host a webserver supporting this EIP, you must host a TXT DNS record at the "_contractkey" subdomain of the Domain Name that will be hosting the webserver. This record must contain a P-256 ECC public key with all occurances of a newline character replaced with "\\n".

The webserver must firstly encode what it is was going to send to the client and encode it with base64. This encoded data must be encoded to a byte array with utf-8 and then hashed using the SHA-256 hashing algorithm. This hash must be signed using the DSS fips-186-3 algorithm with the private key for the domain, where as the public key is stored in the "_contractkey" DNS record. This signature must be encoded to base64. The webserver should return the following data is JSON format.

  ```
{
  "signature": *The Base64 encoded signature*,
  "body": *the base64 encoded body*
 }
  ```

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

## Rationale

TBD

## Backwards Compatibility

No backward compatibility issues found.

## Test Cases

Inputs: ("https://example.com/api", true, "Authorization: Bearer xxx", '{"name": "John"}')
Stack transition: ["https://example.com/api", true, "Authorization: Bearer xxx", '{"name": "John"}']
(after)  [... 200, '{"message": "Success"}']

## Reference Implementation

Python Flask based server implementation
```
  from flask import Flask
  from Crypto.Hash import SHA256
  from Crypto.PublicKey import ECC
  from Crypto.Signature import DSS
  from flask.json import jsonify
  import base64

  app = Flask(__name__)

  f = open('private-key.pem','rt')
  key = ECC.import_key(f.read())

  def sign(message):
      h = SHA256.new(message.encode("utf-8"))
      signer = DSS.new(key, 'fips-186-3')
      signature = signer.sign(h)
      return jsonify({"signature": base64.b64encode(signature).decode("utf-8"), "body": message})

  @app.route("/")
  def hello_world():
      return sign("Hello World!")

  app.run(debug=True)
  
```
  
Python simple client implementation (with error checking)
```
  import dns.resolver
  import requests
  import json
  from Crypto.Hash import SHA256
  from Crypto.PublicKey import ECC
  from Crypto.Signature import DSS
  import base64
  
  URL = "https://example.com/path"
  
  # Load key from DNS record
  key = ECC.import_key(dns.resolver.resolve("_contractkey." + URL.replace("https://", "").split("/")[0], "TXT")
                       [0].strings[0].decode('utf-8').replace("\\n", "\n").encode('utf-8'))
  
  
  if not "https://" in URL:
      print("(400, \"\")")
  
  # Make HTTPS request
  try:
      request = requests.get(URL, timeout=0.5)
  except requests.exceptions.Timeout:
      print("(504, \"\")")

  # Decode response
  try:
      response = json.loads(request.text)
      signature = base64.b64decode(response["signature"].encode("utf-8"))
      body = response["body"]
  except:
      print("(502, \"\")")

  # Verify signature
  h = SHA256.new(body.encode('utf-8'))
  verifier = DSS.new(key, 'fips-186-3')
  try:
      verifier.verify(h, signature)
      print()
  except ValueError:
      print("(502, \"\")")
```

## Security Considerations
  
Making so many DNS queries is inefficient.

Needs discussion.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
