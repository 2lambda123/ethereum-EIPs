---
eip: 7092
title: Financial Bonds
description: This interface defines a specification for debt issued by corporations, goverments or other entities to investors in order to raise funds.
author: Samuel Gwlanold Edoumou (@Edoumou)
discussions-to: https://ethereum-magicians.org/t/financial-bonds/14461
status: Review
type: Standards Track
category: ERC
created: 2023-05-28
---

## Abstract

This proposal introduces fixed income financial bonds. Important bond characteristics such as the International Securities Identification Number (ISIN),
the issue volume, the issue date, the maturity date, the coupon rate, the coupon frequency, the principal, or the day count basis are defined to allow issuing
bonds in the primary market (origination), and different transfer functions allow to buy or sell bonds in the secondary market. The standard also provides a
functionality to allow bonds to be approved by owners in order to be spent by third party, and cross-chain functionalities that allow bond tokens to be
managed accross several blockchains.

## Motivation

Fixed income instruments are one of the asset classes widely used by corporations and other entities to raise funds. Bonds are considered more secure than equity because the issuer is obligated to repay the principal at maturity, in addition to the coupons paid to investors.

This standard interface allows fixed income instruments to be represented as on-chain tokens, making it possible for them to be managed through wallets and utilized by applications, such as decentralized exchanges and digital platforms for investment banks.

The existing standard, [ERC-3475](./eip-3475), which is used to create abstract storage bonds, deviates from traditional bond standards. It introduces concepts such as classes and nonces, which are not commonly used in traditional bonds, making it challenging for traditional entities to transition to tokenized bonds. Moreover, the use of on-chain metadata, such as classMetadata, nonceMetadata, and classValues in ERC-3475, results in unnecessary gas consumption. The absence of named variables like coupon, maturity date, principal, etc., complicates the implementation of ERC-3475, as developers must remember which metadata is associated with each parameter.

By adhering to the same standards as traditional bonds, [ERC-7092](./eip-7092.md) enables the creation of new tokens for bonds with identical characteristics to traditional bonds, simplifying the migration to tokenized bonds.

Tokenizing bonds offers several advantages compared to traditional bond issuance and trading, including:

1. Fractional Ownership: Token standards do not impose a minimum denomination requirement, unlike traditional bonds, which typically have denominations of $100 or $1,000.
2. Accessibility: By allowing lower investment thresholds, tokenized bonds aim to attract retail investors who were previously unable to participate in traditional markets due to high minimum investment requirements.
3. Increased Liquidity: Fractional ownership will introduce new investors to the bond market, increasing liquidity.
4. Cost Savings: By replacing intermediaries with smart contracts, bond tokenization reduces costs associated with bond issuance and management.
5. Easy Accessibility and 24/7 Trading: Tokenized bonds are expected to be traded on digital platforms, including decentralized exchanges, making them more accessible compared to traditional bond markets.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

**Every contract compliant with the [ERC-7092](./eip-7092.md) MUST implement the following interface**

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.0;

/**
* @title ERC-7092 Financial Bonds tandard
*/
interface IERC7092 {
    /**
    *  @notice Returns the bond isin
    */
    function isin() external view returns(string memory);

    /**
    * @notice Returns the bond name
    */
    function name() external view returns(string memory);

    /**
    * @notice Returns the bond symbol
    *         It is RECOMMENDED to represent the symbol as a combination of the issuer issuer's shorter name and the maturity date
    *         Ex: If a company named Green Energy issues bonds that will mature on october 25, 2030, the bond symbol could be `GE30` or `GE2030` or `GE102530`
    */
    function symbol() external view returns(string memory);

    /**
    * @notice Returns the bond currency. This is the contract address of the token used to make payments and return the bond principal
    */
    function currency() external view returns(address);

    /**
    * @notice Returns the bond denomination. This is the minimum amount in which the bonds may be issued. It MUST be expressed in units of the principal currency.
    *         ex: If the denomination is set at 1,000, and the currency is USDC, then the bond denomination is equivalent to 1,000 USDC.
    */
    function denomination() external view returns(uint256);

    /**
    * @notice Returns the issue volume, which represents the total debt amount. It is RECOMMENDED to express the issue volume in terms of the denomination unit.
    */
    function issueVolume() external view returns(uint256);

    /**
    * @notice Returns the bond interest rate. It is RECOMMENDED to express the interest rate in basis points (bps).
    *         1 basis point = 0.01% = 0.0001
    *         ex: if interest rate = 5%, then coupon() => 500 basis points
    */
    function couponRate() external view returns(uint256);

    /**
    * @notice Returns the date when bonds were issued to investors. This is a Unix Timestamp similar the one returned by block.timestamp
    */
    function issueDate() external view returns(uint256);

    /**
    * @notice Returns the bond maturity date, i.e, the date when the principal is repaid. This is a Unix Timestamp similar the one returned by block.timestamp
    *         The maturity date MUST be greater than the issue date
    */
    function maturityDate() external view returns(uint256);

    /**
    * @notice Returns the principal of an account. It is RECOMMENDED to express the principal in the bond currency unit (e.g., USDC, DAI, etc)
    * @param _account account address
    */
    function principalOf(address _account) external view returns(uint256);

    /**
    * @notice Returns the number of tokens that the `_spender` account has been authorized by the `_owner` to manage
    * @param _owner the bondholder address
    * @param _spender the address that has been authorized by the bondholder
    */
    function allowance(address _owner, address _spender) external view returns(uint256);

    /**
    * @notice Authorizes `_spender` account to manage  a specified `_amount`of the bondholder's tokens
    * @param _spender the account to be authorized by the bondholder
    * @param _amount amount of bond tokens to approve
    */
    function approve(address _spender, uint256 _amount) external returns(bool);

    /**
    * @notice Decreases the allowance granted to `_spender` by `_amount`
    * @param _spender the address to be authorized by the bondholder
    * @param _amount amount of bond tokens to remove from allowance
    */
    function decreaseAllowance(address _spender, uint256 _amount) external;

    /**
    * @notice Transfers `_amount` bonds to the address `_to`. Additionally, this method enables to attach data to the token being transferred
    * @param _to the address to send bonds to
    * @param _amount amount of bond tokens to transfer
    * @param _data additional information provided by the token holder
    */
    function transfer(address _to, uint256 _amount, bytes calldata _data) external returns(bool);

    /**
    * @notice Transfers `_amount` bonds from an account that has previously authorized the caller through the `approve` function
    *         This methods also allows to attach data to the token that is being transferred
    * @param _from the bondholder address
    * @param _to the address to transfer bonds to
    * @param _amount amount of bond tokens to transfer.
    * @param _data additional information provided by the token holder
    */
    function transferFrom(address _from, address _to, uint256 _amount, bytes calldata _data) external returns(bool);

    /**
    * @notice MUST be emitted when bond tokens are transferred, issued or redeemed, with the exception being during contract creation
    * @param _from bondholder account
    * @param _to account to transfer bonds to
    * @param _amount amount of bond tokens to be transferred
    */
    event Transfer(address _from, address _to, uint256 _amount);

    /**
    * @notice MUST be emitted when an account is approved to spend tokens or when the allowance is decreased
    * @param _owner bondholder account
    * @param _spender the account to be allowed to spend bonds
    * @param _amount amount of bond tokens allowed by _owner to be spent by `_spender`
    *        Or amount of bond tokens to decrease allowance from `_spender`
    */
    event Approval(address _owner, address _spender, uint256 _amount);
}
```

### Optional Functions

The following functions are OPTIONAL. They MAY be used to improve the standard usability.

- The `currencyOfCoupon` SHOULD be implemented only if the currency used for coupon payment is different from the currency used to repay the principal
- The `couponType` MAY be employed to signify the interest rate that the issuer has committed to paying to investors, which may take various forms such as zero coupon, fixed rate, floating rate, and more.
- The `couponFrequency` refers to how often the bond pays interest to its bondholders, and is typically expressed in terms of time periods, such as: Annual, Semi-Annual, Quarterly, or Monthly.
- The `dayCountBasis` is used to calculate the accrued interest on a bond between two coupon payment dates or other specific periods. Some of the day count basis are: Actual/Actual, 30/360, Actual/360, Actual/365, or 30/365
- Batch functions like `batchApprove`, `batchTransfer`, and others are used to optimize and consolidate multiple operations into a single function call. This provides atomicity and optimizes gas usage

```solidity
    /**
    * @notice Returns the number of decimals used by the bond. For example, if it returns `10`, it means that the token amount MUST be multiplied by 10000000000 to get the standard representation.
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect these values to be present. The method is used to improve usability.
    */
    function decimals() external view returns(uint8);

    /**
    * @notice Rreturns the coupon currency, which is represented by the contract address of the token used to pay coupons. It can be the same as the one used for the principal
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect these values to be present. The method is used to improve usability.
    */
    function currencyOfCoupon() external view returns(address);

    /**
    * @notice Returns the coupon type
    *         For example, 0 can denote Zero coupon, 1 can denote Fixed Rate, 2 can denote Floating Rate, and so on
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect these values to be present. The method is used to improve usability.
    */
    function couponType() external view returns(uint8);

    /**
    * @notice Returns the coupon frequency, i.e. the number of times coupons are paid in a year.
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect these values to be present. The method is used to improve usability.
    */
    function couponFrequency() external view returns(uint256);

    /**
    * @notice Returns the day count basis
    *         For example, 0 can denote actual/actual, 1 can denote actual/360, and so on
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect these values to be present. The method is used to improve usability.
    */
    function dayCountBasis() external view returns(uint8);

    /**
    * @notice Authorizes multiple spender accounts to manage a specified `_amount` of the bondholder tokens
    * @param _spender array of accounts to be authorized by the bondholder
    * @param _amount array of amounts of bond tokens to approve
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect these values to be present. The method is used to improve usability.
    */
    function batchApprove(address[] calldata _spender, uint256[] calldata _amount) external returns(bool);

    /**
    * @notice Decreases the allowance of multiple spenders by corresponding amounts in `_amount`
    * @param _spender array of accounts to be authorized by the bondholder
    * @param _amount array of amounts of bond tokens to decrease the allowance from
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present. The method is used to decrease token allowance.
    */
    function batchDecreaseAllowance(address[] calldata _spender, uint256[] calldata _amount) external;

    /**
    * @notice Transfers multiple bonds with amounts specified in the array `_amount` to the corresponding accounts in the array `_to`, with the option to attach additional data
    * @param _to array of accounts to send the bonds to
    * @param _amount array of amounts of bond tokens to transfer
    * @param _data array of additional information provided by the token holder
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present.
    */
    function batchTransfer(address[] calldata _to, uint256[] calldata _amount, bytes[] calldata _data) external returns(bool);

    /**
    * @notice Transfers multiple bonds with amounts specified in the array `_amount` to the corresponding accounts in the array `_to` from an account that have been authorized by the `_from` account
    *         This method also allows to attach data to tokens that are being transferred
    * @param _from array of bondholder accounts
    * @param _to array of accounts to transfer bond tokens to
    * @param _amount array of amounts of bond tokens to transfer.
    * @param _data array of additional information provided by the token holder
    *
    ** OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present.
    */
    function batchTransferFrom(address[] calldata _from, address[] calldata _to, uint256[] calldata _amount, bytes[] calldata _data) external returns(bool);

    /**
    * @notice MUST be emitted when multiple bond tokens are transferred, issued or redeemed, with the exception being during contract creation
    * @param _from bondholder account
    * @param _to array of accounts to transfer bonds to
    * @param _amount array of amounts of bond tokens to be transferred
    *
    ** OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present. MUST be emitted in `batchTransfer` and `batchTransferFrom` functions
    */
    event TransferBatch(address _from, address[] _to, uint256[] _amount);

    /**
    * @notice MUST be emitted when multiple accounts are approved or when the allowance is decreased from multiple accounts
    * @param _owner bondholder account
    * @param _spender array of accounts to be allowed to spend bonds, or to decrase the allowance from
    * @param _amount array of amounts of bond tokens allowed by `_owner` to be spent by multiple accounts in `_spender`.
    *
    ** OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present. MUST be emitted in `batchApprove` and `batchDecreaseAllowance` functions
    */
    event ApprovalBatch(address _owner, address[] _spender, uint256[] _amount);
```

### Required functions for Interoperability

Interoperability is crucial for ERC standards that tokenize financial securities for several reasons:

- Liquidity and Market Access: Interoperability enables bonds issued on a blockchain to be traded on various decentralized and centralized exchanges.
- Compliance and Regulatory Considerations: Different jurisdictions may have specific regulations and compliance requirements for financial bonds. Interoperability allows for the creation of bond tokens that can be compliant with various regulatory regimes.
- Cross-Asset and Cross-Chain Transfers: Interoperability can enable the movement of bonds between different blockchains. This is important because not all bonds or financial instruments may be tokenized on one blockchain alone. Interoperability allows for cross-chain transfers, making it possible to move bonds between different blockchain networks and ecosystems.
- Innovation and Collaboration: The ability for different projects, platforms, and ecosystems to work together fosters innovation and collaboration in the blockchain and financial technology space. Interoperability encourages developers and organizations to create complementary tools and services that enhance the bond token ecosystem.

The following functions are REQUIRED to enable the management of bond tokens of the same issuance across multiple blockchain networks. The standard presumes that any function initiating a cross-chain transaction must explicitly define the destination chain identifier `destinationChainID` and specify the target smart contract with which to interact on the destination blockchain, `destinationContract`. 
The destination chain identifier should be the one specified by the cross-chain protocol in use. One such protocol that can facilitate the implementation of cross-chain capabilities is the ChainLink Cross-Chain Interoperability Protocol (CCIP).

```solidity
    /**
    * @notice Authorizes the `_spender` account to manage a specified `_amount`of the bondholder bond tokens on the destination Chain
    * @param _spender account to be authorized by the bondholder
    * @param _amount amount of bond tokens to approve
    * @param _destinationChainID The unique ID that identifies the destination Chain.
    * @param _destinationContract The smart contract to interact with in the destination Chain
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present. The method is used to approve tokens in a different chain than the current chain
    */
    function crossChainApprove(address _spender, uint256 _amount, uint64 _destinationChainID, address _destinationContract) external returns(bool);

    /**
    * @notice Authorizes multiple spender accounts in `_spender` to manage specified amounts in `_amount` of the bondholder tokens on the destination chain
    * @param _spender array of accounts to be authorized by the bondholder
    * @param _amount array of amounts of bond tokens to approve
    * @param _destinationChainID array of unique IDs that identifies the destination Chain.
    * @param _destinationContract array of smart contracts to interact with in the destination Chain in order to Deposit or Mint tokens that are transferred.
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present.
    */
    function crossChainBatchApprove(address[] calldata _spender, uint256[] calldata _amount, uint64[] calldata _destinationChainID, address[] calldata _destinationContract) external returns(bool);

    /**
    * @notice Decreases the allowance of `_spender` by a specified `_amount` on the destination Chain
    * @param _spender the address to be authorized by the bondholder
    * @param _amount amount of bond tokens to remove from allowance
    * @param _destinationChainID The unique ID that identifies the destination Chain.
    * @param _destinationContract The smart contract to interact with in the destination Chain in order to Deposit or Mint tokens that are transferred.
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present.
    */
    function crossChainDecreaseAllowance(address _spender, uint256 _amount, uint64 _destinationChainID, address _destinationContract) external;

    /**
 the array    * @notice Decreases the allowance of multiple spenders in `_spender` by corresponding amounts specified in the array `_amount` on the destination chain
    * @param _spender array of accounts to be authorized by the bondholder
    * @param _amount array of amounts of bond tokens to decrease the allowance from
    * @param _destinationChainID array of unique IDs that identifies the destination Chain.
    * @param _destinationContract array of smart contracts to interact with in the destination Chain in order to Deposit or Mint tokens that are transferred.
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present.
    */
    function crossChainBatchDecreaseAllowance(address[] calldata _spender, uint256[] calldata _amount, uint64[] calldata _destinationChainID, address[] calldata _destinationContract) external;

    /**
    * @notice Moves `_amount` bond tokens to the address `_to` from the current chain to another chain (e.g., moving tokens from Ethereum to Polygon).
    *         This methods also allows to attach data to the token that is being transferred
    * @param _to account to send bond tokens to
    * @param _amount amount of bond tokens to transfer
    * @param _data additional information provided by the bondholder
    * @param _destinationChainID The unique ID that identifies the destination Chain.
    * @param _destinationContract The smart contract to interact with in the destination Chain in order to Deposit or Mint bond tokens that are transferred.
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present.
    */
    function crossChainTransfer(address _to, uint256 _amount, bytes calldata _data, uint64 _destinationChainID, address _destinationContract) external returns(bool);

    /**
    * @notice Transfers multiple bond tokens with amounts specified in the array `_amount` to the corresponding accounts in the array `_to` from the current chain to another chain (e.g., moving tokens from Ethereum to Polygon).
    *         This methods also allows to attach data to the token that is being transferred
    * @param _to array of accounts to send the bonds to
    * @param _amount array of amounts of bond tokens to transfer
    * @param _data array of additional information provided by the bondholder
    * @param _destinationChainID array of unique IDs that identify the destination Chains.
    * @param _destinationContract array of smart contracts to interact with in the destination Chains in order to Deposit or Mint bond tokens that are transferred.
    *
    * OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present.
    */
    function crossChainBatchTransfer(address[] calldata _to, uint256[] calldata _amount, bytes[] calldata _data, uint64[] calldata _destinationChainID, address[] calldata _destinationContract) external returns(bool);

    /**
    * @notice Transfers `_amount` bond tokens from the `_from`account to the `_to` account from the current chain to another chain. The caller must be approved by the `_from` address.
    *         This methods also allows to attach data to the token that is being transferred
    * @param _from the bondholder address
    * @param _to the account to transfer bonds to
    * @param _amount amount of bond tokens to transfer
    * @param _data additional information provided by the token holder
    * @param _destinationChainID The unique ID that identifies the destination Chain.
    * @param _destinationContract The smart contract to interact with in the destination Chain in order to Deposit or Mint tokens that are transferred.
    *
    ** OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present
    */
    function crossChainTransferFrom(address _from, address _to, uint256 _amount, bytes calldata _data, uint64 _destinationChainID, address _destinationContract) external returns(bool);

    /**
    * @notice Transfers several bond tokens with amounts specified in the array `_amount` from accounts in the array `_from` to accounts in the array `_to` from the current chain to another chain.
    *         The caller must be approved by the `_from` accounts to spend the corresponding amounts specified in the array `_amount`
    *         This methods also allows to attach data to the token that is being transferred
    * @param _from array of bondholder addresses
    * @param _to array of accounts to transfer bonds to
    * @param _amount array of amounts of bond tokens to transfer
    * @param _data array of additional information provided by the token holder
    * @param _destinationChainID array of unique IDs that identifies the destination Chain.
    * @param _destinationContract array of smart contracts to interact with in the destination Chain in order to Deposit or Mint tokens that are transferred.
    *
    ** OPTIONAL - interfaces and other contracts MUST NOT expect this function to be present
    */
    function crossChainBatchTransferFrom(address[] calldata _from, address[] calldata _to, uint256[] calldata _amount, bytes[] calldata _data, uint64[] calldata _destinationChainID, address[] calldata _destinationContract) external returns(bool);

    /**
    * @notice MUST be emitted when bond tokens are transferred or redeemed in a cross-chain transaction
    * @param _from bondholder account
    * @param _to account the transfer bond tokens to
    * @param _amount amount of bond tokens to be transferred
    * @param _destinationChainID The unique ID that identifies the destination Chain
    */
    event CrossChainTransfer(address _from, address _to, uint256 _amount, uint64 _destinationChainID);

    /**
    * @notice MUST be emitted when several bond tokens are transferred or redeemed in a cross-chain transaction
    * @param _from the bond token's owner
    * @param _to array of accounts that receive the bond
    * @param _amount array of amount of bond tokens to be transferred
    * @param _destinationChainID array of unique IDs that identify the destination Chain
    */
    event CrossChainTransferBatch(address _from, address[] _to, uint256[] _amount, uint64[] _destinationChainID);

    /**
    * @notice MUST be emitted when an account is approved to spend the bondholder's tokens in a different chain than the current chain
    * @param _owner the bondholder account
    * @param _spender the account to be allowed to spend bonds
    * @param _amount amount of bond tokens allowed by `_owner` to be spent by `_spender`
    * @param _destinationChainID The unique ID that identifies the destination Chain
    */
    event CrossChainApproval(address _owner, address _spender, uint256 _amount, uint64 _destinationChainID);

    /**
    * @notice MUST be emitted when multiple accounts in the array `_spender` are approved or when the allowances of multiple accounts in the array `_spender` are reduced on the destination chain which MUST be different than the current chain
    * @param _owner bond token's owner
    * @param _spender array of accounts to be allowed to spend bonds
    * @param _amount array of amount of bond tokens allowed by _owner to be spent by _spender
    * @param _destinationChainID array of unique IDs that identify the destination Chain
    */
    event CrossChainApprovalBatch(address _owner, address[] _spender, uint256[] _amount, uint64[] _destinationChainID);
```

## Rationale

The financial bond standard is specifically designed to represent fixed income assets, which essentially represent a loan provided by an investor to a borrower. The motivation behind this design stems from the need to tokenize fixed income assets and present the bond tokens with characteristics mirroring those found in traditional finance. Maintaining these familiar properties is essential for both issuers and investors, as it eases the transition to tokenized bonds without significant hurdles.

The conventional finance structure, involving an issuer, an investment bank, and investors, can be seamlessly translated into the bond standard. In this context, smart contracts have the potential to replace the role of the investment bank intermediary. In cases of institutional issuance, the management of these smart contracts may be overseen by the investment bank. Additionally, decentralized exchanges can leverage the bond standard to list bonds, with the responsibility of managing the associated smart contracts falling on these decentralized exchange platforms.

Furthermore, various other entities can utilize this financial bond interface to create tokenized bonds, integrating this standard into their operations. This adaptability and flexibility empower a wide range of participants within the financial ecosystem to benefit from the advantages of tokenized bonds while retaining the structure and processes they are familiar with from traditional finance.

The choice of terminology, such as `issueVolume` and `principalOf` instead of `totalSupply` and `balanceOf` as found in other standards like [ERC-20](./eip-20), is deliberate and stems from the aim of aligning with the terminology commonly used in traditional bonds. This approach ensures consistency with traditional financial terminology, making it easier for users to relate to and understand the tokenized bonds.

Moreover, the inclusion of a data input parameter in all transfer functions, which enables the transfer of additional data, makes the ERC-7092 not fully compatible with the ERC-20 standard.

Another important motivation for not extending other standards like ERC-20 with ERC-7092 is to enable token explorer platforms like Etherscan to represent ERC-7092 tokens as distinct entities with unique characteristics. By doing so, these platforms can provide additional information beyond just token balances. This added information might include essential bond characteristics such as the `interest rate` or `coupon rate`, as well as the `maturity date`.

The inclusion of these bond-specific details in token representations is highly valuable for bondholders and investors. It allows them to assess the return on their capital investment and make more informed decisions about their holdings. This level of transparency and specificity is crucial in the context of tokenized bonds, where investors rely on these details to evaluate the performance and risk associated with their investments.

### Total Supply

The decision not to explicitly define the `totalSupply` function in the ERC-7092 standard while providing a recommendation to implement it is a thoughtful approach. This choice acknowledges that the total supply of tokens in ERC-7092 can be derived from the `issueVolume` and the `denomination`, offering flexibility to developers.

While the standard doesn't mandate the inclusion of the `totalSupply` function, it strongly recommends its implementation. When developers choose to include it, they should ensure that the total supply accurately represents the ratio of the issueVolume and the denomination.

```javascript
    totalSupply = issueVolume / denomination
```

### Account Token Balance

The ERC-7092 does not to explicitly define the balanceOf function, as the token balance can be calculated from both the `principal` and the `denomination`. However, it is strongly RECOMMENDED to consider including the `balanceOf` function when implementing this standard. When the `balanceOf` function is implemented, it should accurately reflect the token balance of an account as the ratio of the `principal` of that account and the `denomination`.

```javascript
    balanceOf(account) = principalOf(account) / denomination
```

## Backwards Compatibility

The ERC-7092 standard deliberately avoids extending existing standards, such as [ERC-20](./eip-20) or [ERC-1155](./eip-1155). This decision is motivated by the fact that some fundamental functions, like `totalSupply` or `balanceOf` are not explicitly implemented in ERC-7092.

Instead, the ERC-7092 standard is designed to stand on its own as a distinct representation of a new token specifically tailored for bonds. It encompasses all the essential bond characteristics and functionalities directly within its structure.

**_For the reasons mentioned above, we recommend a pure implementation of the standard_** for issuing tokenized bonds, as any hybrid solution involving the other standards mentioned SHOULD deviate from this standard.

## Reference Implementation

The reference implementation of the [ERC-7092](./eip-7092.md) can be found [here](../assets/eip-7092/ERC7092.sol).

Certain bonds come with embedded options that enhance their flexibility and offer unique features. As an illustration:

- Callable bonds: These bonds grant the issuer the right, but not the obligation, to redeem or retire the bonds before their scheduled maturity date. This embedded call option provides issuers with the flexibility to reduce their debt obligations or take advantage of lower interest rates in the market by calling in and retiring the bonds when it becomes financially advantageous to do so.
- Puttable bonds: These bonds provide investors with the right, but not the obligation, to sell the bonds back to the issuer or another specified entity before their scheduled maturity date. This embedded put option offers investors a degree of protection, allowing them to potentially receive their principal back before the maturity date if certain conditions are met.
- Convertible bonds: They are a type of bond that comes with an embedded option, giving investors the right to convert their bonds into a specified number of common shares or equity securities of the issuer. This feature provides investors with the opportunity to participate in the potential future growth of the company issuing the bonds.

Bonds featuring embedded options can be generated by inheriting from the foundational ERC-7092 standard, which incorporates the ERC-7092 interface. This inheritance approach allows developers to build upon the base functionality of ERC-7092 while incorporating the specific features and logic required for bonds with embedded options. By extending the standard in this manner, developers can create specialized tokenized bond contracts that include the desired embedded option features, such as call options or put options.

### CALLABLE BONDS:

```solidity
pragma solidity ^0.8.0;

import 'ERC7092.sol';

contract ERC7092Callable is ERC7092 {
    // WRITE THE LOGIC TO ALLOW THE ISSUER TO CALL BONDS
    // STATE VARIABLES AND FUNCTIONS NEEDED

    address public issuerAddress;
    
    /**
    * @notice call bonds owned by `_investor`
    *         MUST be called by the issuer only
    */
    function call(address _investor) public {
        require(msg.sender === issuerAddress, "ERC7092Callable: ONLY_ISSUER");
        require(_principals[_investor] > 0, "ERC7092Callable: NO_BOND_FOUND");
        require(block.timestamp < _bond[bondISIN].maturityDate, "ERC7092Callable: BOND_MATURED");
        
        uint256 principal =  _principals[_investor];
        _principals[_investor] = 0;
        
        // ADD LOGIC HERE
    }
}
```

### PUTTABLE BONDS:

```solidity
pragma solidity ^0.8.0;

import 'ERC7092.sol';

contract ERC7092Puttable is ERC7092 {
    // WRITE THE LOGIC TO ALLOW INVESTORS TO PUT BONDS
    // STATE VARIABLES AND FUNCTIONS NEEDED
    
    /**
    * @notice put bonds
    *         MUST be called by investors who own bonds
    */
    function put() public {
        require(_principals[msg.sender] > 0, "ERC7092Puttable: NO_BOND_FOUND");
        require(block.timestamp < _bond[bondISIN].maturityDate, "ERC7092Puttable: BOND_MATURED");
        
        uint256 principal =  _principals[msg.sender];
        _principals[msg.sender] = 0;
        
        // ADD LOGIC
    }
}
```

### CONVERTIBLE BONDS:

```solidity
pragma solidity ^0.8.0;

import 'ERC7092.sol';

contract ERC7092Convertible is ERC7092 {
    // WRITE THE LOGIC TO ALLOW INVESTOR OR ISSUER TO CONVERT BONDS TO EQUITY
    // STATE VARIABLES AND FUNCTIONS NEEDED
    
    /**
    * @notice convert bonds to equity. Here we assumed that the investors must convert their bonds to equity
    *         Issuer can also convert invetsors bonds to equity.
    */
    function convert() public {
        require(_principals[msg.sender] > 0, "ERC7092Convertible: NO_BOND_FOUND");
        require(block.timestamp < _bond[bondISIN].maturityDate, "ERC7092Convertible: BOND_MATURED");
        
        uint256 principal =  _principals[msg.sender];
        _principals[msg.sender] = 0;
        
        // ADD LOGIC HERE
    }
}
```

### Identity Registry

The ERC-7092 standard, designed specifically for tokenizing bonds, focuses on functionalities related to bond origination and ownership transfer. It does not inherently manage information pertaining to bondholders' identities. However, to enhance compliance with regulatory requirements and improve transparency, it is strongly RECOMMENDED to implement an identity registry to store the identity addresses of all authorized investors.

By maintaining an identity registry, issuers can ensure that bond tokens issued under the ERC-7092 standard are transferred only to registered and authorized entities. This practice aligns with regulatory compliance measures and provides a structured way to manage and verify the identity of bondholders. It also helps prevent unauthorized or non-compliant transfers of bond tokens.

## Security Considerations

When implementing the ERC-7092 standard, it's of utmost importance to prioritize security and consider the associated risks, especially concerning functions that grant approval to operators for managing an owner's bonds and functions that enable bond transfers. Any mishandling or malicious actions in these functions can potentially result in the loss of bonds. To mitigate these risks, strict access control and authorization mechanisms should be in place.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
