---
eip: 998
title: ERC-998 Composable Non-Fungible Token Standard
author: Matt Lockyer <mattdlockyer@gmail.com>, Nick Mudge <nick@perfectabstractions.com>
discussions-to: https://github.com/ethereum/EIPs/issues/998
type: Standards Track
category: ERC
status: Draft
created: 2018-07-07
requires: EIP 721
---

## Simple Summary

An extenstion of the [ERC721 standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md) to enable ERC721 tokens to own other ERC721 tokens and ERC20 tokens.

## Abstract

An ERC988 composable is an ERC721 token with additional functions and and functionality for owning other ERC721 tokens and ERC20 tokens.

A composable owns another token if the the ownership of the token has been transferred to the composable.

A composable can own any number of ERC721 tokens from any number of ERC721 contracts. A composable can own any amount of ERC20 tokens from any number of ERC20 contracts. It is possible for a composable to own other composables, thereby creating trees of connected composables and tokens. The owner address of the composable at the top of the tree owns all the composables and tokens under it.

Transferring a composable means transferring the entire hierarchy of tokens. For example, a cryptokitty may own a scratching post and a feeding dish; the dish may contain some amount of fungible "chow" tokens. It is possible to transfer a group of ERC721 and/or ERC720 tokens in one transfer by making a composable own them and tranferring the composable.

This standard specifies two different kinds of composables: top-down composables and bottom-up composables.

Top-down composables store and keep track of the child tokens that they own.

Bottom-up composables store and keep track of their parent ERC721 token.

Both approaches have their advantages and disadvantages which are explained in the Rational section. It is possible for a composable token to be one or both kinds of composables.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.
### Authentication

Authenticating whether a user or contract can execute some action works the same for both top-down and bottom-up composables.

A `rootOwner` refers to the owner address at the top of a tree of composables and tokens. An `immediateOwner` refers to an address that directly owns a composable with no composables between it and the composable it owns.

Authentication within any composable is done by finding the rootOwner and comparing it to `msg.sender`, the return result of `getApproved(tokenId)` and the return result of `isApprovedForAll(rootOwner, msg.sender)`. If no match is found then the immediateOwner of the composable is found and compared to `msg.sender` and the return result of `isApprovedForAll(immediateOwner, msg.sender)`. If a match is found then authentication passes, otherwise authentication fails and the contract throws.

Here is an example of authentication code:
```solidity
require(rootOwner == msg.sender || isApprovedForAll(rootOwner,msg.sender) ||
  getApproved(tokenId) == msg.sender || immediateOwner == msg.sender || 
  isApprovedForAll(immediateOwner,msg.sender);
```

The `approve(address _approved, uint256 _tokenId)` and `getApproved(uint256 _tokenId)` functions are implemented specifically for the rootOwner, not the immediateOwner. This enables a tree of composables to be transferred to a new rootOwner without worrying about which addresses have been approved in child composables, because any prior approves could only be used by the prior rootOwner.

Here are example implementations:
```solidity
function approve(address _approved, uint256 _tokenId) external {
  address immediateOwner = tokenIdToTokenOwner[_tokenId];
  require(immediateOwner != address(0));
  address rootOwner = ownerOf(_tokenId);	
  require(rootOwner == msg.sender || isApprovedForAll(rootOwner,msg.sender) ||
    immediateOwner == msg.sender  || isApprovedForAll(immediateOwner,msg.sender));

  rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] = _approved;
  emit Approval(rootOwner, _approved, _tokenId);
}

function getApproved(uint256 _tokenId) public view returns (address)  {
  address rootOwner = ownerOf(_tokenId);
  return rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];
}
```
### Traversal

In order to get the rootOwner a composable must traverse up the tree of composables to find the top-most parent composable and the owner address for it. Both the top-down and bottom-up composables must use the following function to traverse up the tree of composables:

```solidity
function tokenOwnerOf(uint256 _tokenId)
  external 
  view 
  returns (address immediateOwner, uint256 parentTokenId, uint256 isParent);
```

The first byte of `isParent` holds the value 1 or 0. If the value is 1 then `parentTokenId` is the parent tokenId of `_tokenId`. Otherwise there is no parent token. The next four bytes of `isParent` hold the magic value `0x89885a59` which is equal to `bytes4(keccak256("tokenOwnerOf(uint256)"))`. The magic value is used to verify that `tokenOwnerOf` was successfully called and the return values are valid, because this function may be called on contracts that do not have it. For example a bottom-up composable could be transferred to a regular ERC721 token. When traversing the tree `tokenOwnerOf(uint256 _tokenId)` is called on the ERC721 token and it should fail.




Every ERC-173 compliant contract must implement the `ERC173` interface. Contracts that inherit from OpenZeppelin's `Ownable` contract are compliant with ERC-173. However future contracts should also implement `ERC165` for the ERC-173 interface.

```solidity
pragma solidity ^0.4.24;

/// @title ERC-173 Contract Ownership Standard
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md
///  Note: the ERC-165 identifier for this interface is 0x7f5828d0
interface ERC173 /* is ERC165 */ {
    /// @dev This emits when ownership of a contract changes.    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /// @notice Get the address of the owner    
    /// @return The address of the owner.
    function owner() view external;
	
    /// @notice Set the address of the new owner of the contract   
    /// @param _newOwner The address of the new owner of the contract    
    function transferOwnership(address _newOwner) external;	
}

interface ERC165 {
    /// @notice Query if a contract implements an interface
    /// @param interfaceID The interface identifier, as specified in ERC-165
    /// @dev Interface identification is specified in ERC-165. This function
    ///  uses less than 30,000 gas.
    /// @return `true` if the contract implements `interfaceID` and
    ///  `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}
```

The `owner()` function may be implemented as `pure` or `view`.

The `transferOwnership(address _newOwner)` function may be implemented as `public` or `external`.

The OwnershipTransferred event does not have to be emitted when a contract is created.

## Rationale

Several ownership schemes were considered. The scheme chosen in this standard was chosen because of its simplicity, low gas cost and backwards compatibility with OpenZeppelin's implementation of the Ownable contract which is in active use.

Here are other schemes that were considered:
1. **Associating an Ethereum Name Service (ENS) domain name with a contract.** A contract's `owner()` function could look up the owner address of a particular ENS name and use that as the owning address of the contract. Using this scheme a contract could be transferred by transferring the ownership of the ENS domain name to a different address. Short comings to this approach are that it is not backwards compatible with existing contracts and requires gas to make external calls to ENS related contracts to get the owner address.
2. **Associating an ERC721-based non-fungible token (NFT) with a contract.** Ownership of a contract could be tied to the ownership of an NFT. The benefit of this approach is that the existing ERC721-based infrastructure could be used to sell/buy/auction contracts. Short comings to this approach are additional complexity and infrastructure required. A contract could be associated with a particular NFT but the NFT would not track that it had ownership of a contract unless it was programmed to track contracts. In addition handling ownership of contracts this way is not backwards compatible.

This standard does not exclude the above ownership schemes or other schemes from also being implemented in the same contract. For example a contract could implement this standard and also implement the other schemes so that ownership could be managed and transferred in multiple ways. This standard does provide a simple ownership scheme that is backwards compatible, is light-weight and simple to implement, and can be widely adopted and depended on.

## Backwards Compatibility

OpenZeppelin's Ownable contract is actively being used in contracts. Contracts that inherit Ownable are in compliance with this standard.

However future contracts should also implement `ERC165` for the ERC-173 interface.

## Implementations

OpenZeppelin's implementation is here: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).



