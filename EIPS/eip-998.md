---
eip: 998
title: ERC-998 Composable Non-Fungible Token Standard
author: Matt Lockyer <mattdlockyer@gmail.com>, Nick Mudge <nick@perfectabstractions.com>
discussions-to: https://github.com/ethereum/EIPs/issues/998
type: Standards Track
category: ERC
status: Draft
created: 2018-07-07
requires: EIP 721
---

## Simple Summary

An extenstion of the [ERC721 standard](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md) to enable ERC721 tokens to own other ERC721 tokens and ERC20 tokens.

## Abstract

An ERC988 composable is an ERC721 token with additional functions and and functionality for owning other ERC721 tokens and ERC20 tokens.

A composable owns another token if the the ownership of the token has been transferred to the composable.

A composable can own any number of ERC721 tokens from any number of ERC721 contracts. A composable can own any amount of ERC20 tokens from any number of ERC20 contracts. It is possible for a composable to own other composables, thereby creating trees of connected composables and tokens. The owner address of the composable at the top of the tree owns all the composables and tokens under it.

Transferring a composable means transferring the entire hierarchy of tokens. For example, a cryptokitty may own a scratching post and a feeding dish; the dish may contain some amount of fungible "chow" tokens. It is possible to transfer a group of ERC721 and/or ERC720 tokens in one transfer by making a composable own them and tranferring the composable.

This standard specifies two different kinds of composables: top-down composables and bottom-up composables.

Top-down composables store and keep track of the child tokens that they own.

Bottom-up composables store and keep track of their parent ERC721 token.

Both approaches have their advantages and disadvantages which are explained in the Rational section. It is possible for a composable token to be one or both kinds of composables.

## Specification

### ERC721

Both Top-Down and Bottom-Up composables must implement the [ERC721 interface](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md).

### Authentication

Authenticating whether a user or contract can execute some action works the same for both top-down and bottom-up composables.

A `rootOwner` refers to the owner address at the top of a tree of composables and tokens. An `immediateOwner` refers to an address that directly owns a composable with no composables between it and the composable it owns.

Authentication within any composable is done by finding the rootOwner and comparing it to `msg.sender`, the return result of `getApproved(tokenId)` and the return result of `isApprovedForAll(rootOwner, msg.sender)`. If no match is found then the immediateOwner of the composable is found and compared to `msg.sender` and the return result of `isApprovedForAll(immediateOwner, msg.sender)`. If a match is found then authentication passes, otherwise authentication fails and the contract throws.

Here is an example of authentication code:
```solidity
require(rootOwner == msg.sender || isApprovedForAll(rootOwner,msg.sender) ||
  getApproved(tokenId) == msg.sender || immediateOwner == msg.sender || 
  isApprovedForAll(immediateOwner,msg.sender);
```

The `approve(address _approved, uint256 _tokenId)` and `getApproved(uint256 _tokenId)` ERC721 functions are implemented specifically for the rootOwner, not the immediateOwner. This enables a tree of composables to be transferred to a new rootOwner without worrying about which addresses have been approved in child composables, because any prior approves can only be used by the prior rootOwner.

Here are example implementations:
```solidity
function approve(address _approved, uint256 _tokenId) external {
  address immediateOwner = tokenIdToTokenOwner[_tokenId];
  require(immediateOwner != address(0));
  address rootOwner = ownerOf(_tokenId);	
  require(rootOwner == msg.sender || isApprovedForAll(rootOwner,msg.sender) ||
    immediateOwner == msg.sender  || isApprovedForAll(immediateOwner,msg.sender));

  rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] = _approved;
  emit Approval(rootOwner, _approved, _tokenId);
}

function getApproved(uint256 _tokenId) public view returns (address)  {
  address rootOwner = ownerOf(_tokenId);
  return rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];
}
```
### Traversal

The rootOwner of a composable is gotten by calling `ownerOf(uint256 _tokenId)`. The `ownerOf` function is a standard function from ERC721, but it works differently in composables. Instead of returning the immediateOwner of a token it returns the rootOwner (the owning address at the top of a composable tree). It does this by calling the function `tokenOwnerOf(uint256 _tokenId)` repeatedly in a loop on each parent tokenId until the rootOwner is found. This is true for both top-down and bottom-up composables, making them interoperable with each other.

Tokens/contracts that implement the above authentication and traversal functionality are "composable aware".

Composables and "composable aware" contracts/tokens must call the `onERC998Removed` function in any/all their transferFrom/safeTransferFrom functions to notify owning/_from contracts that ERC721 tokens are removed.

### Top-Down Composable

There are two ways to transfer a ERC721 token to a top-down composable:
1. Use the `function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data)` function. The `_to` argument is the top-down composable contract address. The `bytes data` argument holds the integer value of the top-down composable tokenId that the ERC721 token is transferred to.
2. Call `approve` in the ERC721 token contract for the top-down composable contract. Then call `getChild` in the composable contract.

The first ways is for ERC721 contracts that have a `safeTransferFrom` function. The second way are for contracts that do not have this function such as cryptokitties.

Every ERC-998 Top-Down Composable compliant contract must implement the ERC998ERC721TopDown interface and/or the ERC998ERC20TopDown interface.

The ERC998ERC721TopDownEnumerable and ERC998ERC20TopDownEnumerable interfaces are optional.

```solidity
pragma solidity ^0.4.24;

/// @title ERC-998 Composable Non-Fungible Token Standard, Top-Down
/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md
///  Note: the ERC-165 identifier for this interface is 0x3c6618e9.
interface ERC998ERC721TopDown {
  /// @dev This emits when a token receives a child token.
  /// @param _from The prior owner of the token.
  /// @param _tokenId The token that receives the child token.
  event ReceivedChild(
    address indexed _from, 
    uint256 indexed _tokenId, 
    address indexed _childContract, 
    uint256 _childTokenId
  );
  
  /// @dev This emits when a child token is transferred from a token to an address.
  /// @param _tokenId The parent token that the child token is being transferred from.
  /// @param _to The new owner address of the child token.
  event TransferChild(
    uint256 indexed tokenId, 
    address indexed _to, 
    address indexed _childContract, 
    uint256 _childTokenId
  );

  /// @notice Get the address and parent tokenId that owns the supplied tokenId. 
  /// @param _tokenId The token to query for an owner address and owner token
  /// @return tokenOwner The owner address of _tokenId
  /// @return parentTokenId The parent tokenId of _tokenId
  /// @return isParent Determines if parentTokenId is a parent tokenId and 
  ///  contains a magic value to ensure return values are valid.
  function tokenOwnerOf(uint256 _tokenId) 
    external view 
    returns (address tokenOwner, uint256 parentTokenId, uint256 isParent);
  
  /// @notice Get the parent tokenId of a child token.
  /// @param _childContract The contract address of the child token.
  /// @param _childTokenId The tokenId of the child.
  /// @return parentTokenId The parent tokenId of _tokenId
  /// @return isParent Determines if parentTokenId is a parent tokenId and 
  ///  contains a magic value to ensure return values are valid.
  function ownerOfChild(address _childContract, uint256 _childTokenId) 
    external 
    view 
    returns (uint256 parentTokenId, uint256 isParent);
  
  /// @notice A token receives a child token
  /// @param _operator The address that caused the transfer.
  /// @param _from The owner of the child token.
  /// @param _childTokenId The token that is being transferred to the parent.
  /// @param _data Up to the first 32 bytes contains an integer which is the receiving parent tokenId.  
  function onERC721Received(address _operator, address _from, uint256 _childTokenId, bytes _data) 
    external 
    returns(bytes4);
  
  /// @notice Let's an owning contract know that a specified token is transferred out
  /// @param The address that caused the transfer.
  /// @param _toContract The contract that receives the child token
  /// @param _childTokenId The child tokenId that is being removed.
  /// @param _data Additional data with no specified format
  function onERC998Removed(address _operator, address _toContract, uint256 _childTokenId, bytes _data) external;
  
  /// @notice Transfer child token from top-down composable to address.
  /// @param _to The address that receives the child token
  /// @param _childContract The ERC721 contract of the child token.
  /// @param _childTokenId The tokenId of the token that is being transferred.
  function transferChild(address _to, address _childContract, uint256 _childTokenId) external;
  
  /// @notice Transfer child token from top-down composable to address.
  /// @param _to The address that receives the child token
  /// @param _childContract The ERC721 contract of the child token.
  /// @param _childTokenId The tokenId of the token that is being transferred.
  function safeTransferChild(address _to, address _childContract, uint256 _childTokenId) external;
  
  /// @notice Transfer child token from top-down composable to address.
  /// @param _to The address that receives the child token
  /// @param _childContract The ERC721 contract of the child token.
  /// @param _childTokenId The tokenId of the token that is being transferred.
  /// @param _data Additional data with no specified format
  function safeTransferChild(address _to, address _childContract, uint256 _childTokenId, bytes _data) external;
  
  /// @notice Get a child token from an ERC721 contract.
  /// @param _from The address that owns the child token.
  /// @param _tokenId The token that becomes the parent owner
  /// @param _childContract The ERC721 contract of the child token
  /// @param _childTokenId The tokenId of the child token
  function getChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) external;
}
```
#### tokenOwnerOf

```solidity
/// @notice Get the address and parent tokenId that owns the supplied tokenId. 
/// @param _tokenId The token to query for an owner address and owner token
/// @return tokenOwner The owner address of _tokenId
/// @return parentTokenId The parent tokenId of _tokenId
/// @return isParent Determines if parentTokenId is a parent tokenId and 
///  contains a magic value to ensure return values are valid.
function tokenOwnerOf(uint256 _tokenId)
  external 
  view 
  returns (address immediateOwner, uint256 parentTokenId, uint256 isParent);
```
Gets the immediateOwner address of _tokenId and the parent tokenId if there is one.

The first byte of `isParent` holds the value 1 or 0. If the value is 1 then `parentTokenId` is the parent tokenId of `_tokenId`, and the immediateAddress it the parent contract. Otherwise there is no parent token. The next four bytes of `isParent` hold the magic value `0x89885a59` which is equal to `bytes4(keccak256(abi.encodePacked("tokenOwnerOf(uint256)")))`. The magic value is used to verify that `tokenOwnerOf` was successfully called and the return values are valid. A magic value is used because this this function may be called on contracts that do not have it.

The magic value in `isParent` must be checked in external calls to ensure that return values are valid.

#### ownerOfChild

```solidity
/// @notice Get the parent tokenId of a child token.
/// @param _childContract The contract address of the child token.
/// @param _childTokenId The tokenId of the child.
/// @return parentTokenId The parent tokenId of _tokenId
/// @return isParent Determines if parentTokenId is a parent tokenId and contains a magic value to ensure return values are valid.
function ownerOfChild(address _childContract, uint256 _childTokenId) 
  external 
  view 
  returns (uint256 parentTokenId, uint256 isParent);
```

Given a parent contract address and child tokenId, returns the parent tokenId if there is one.

If the child token has a parent token then the first byte of isParent is 1, otherwise the first byte is 0. The next four bytes of isParent are the magic value 0xeadb80b8, which is equal to bytes4(keccak256(abi.encodePacked("ownerOfChild(address,uint256)"))). If a call to ownerOfChild throws or the magic value is not correct then the transaction does not have to revert. Instead the ownerOfChild function is considered to not be supported by the address it was called on and there is no parent token.

The magic value in `isParent` must be checked in external calls to ensure that return values are valid.

#### Example Implementation of `ownerOf(uint256 _tokenId)`

Here is an example implementation of `ownerOf(uint256 _tokenId)` that uses `tokenOwnerOf` and `ownerOfChild`:
```solidity
// returns the owner at the top of the tree of composables
function ownerOf(uint256 _tokenId) public view returns (address rootOwner) {
  rootOwner = tokenIdToTokenOwner[_tokenId];
  require(rootOwner != address(0));
  uint256 isParent = 1;
  bool callSuccess;
  bytes memory calldata;
  while(uint8(isParent) > 0) {
    if(rootOwner == address(this)) {
	  (_tokenId, isParent) = ownerOfChild(address(this), _tokenId);
	  if(uint8(isParent) > 0) {
	    rootOwner = tokenIdToTokenOwner[_tokenId];
	  }
    }
    else {
	  if(isContract(rootOwner)) {
	    //0x89885a59 == "tokenOwnerOf(uint256)"
	    calldata = abi.encodeWithSelector(0x89885a59, _tokenId);
	    assembly {
		  callSuccess := staticcall(gas, rootOwner, add(calldata, 0x20), mload(calldata), calldata, 0x60)
		  if callSuccess {
		    rootOwner := mload(calldata)
		    _tokenId := mload(add(calldata,0x20))
		    isParent := mload(add(calldata,0x40))
		  }
	    }
	    if(callSuccess == false || isParent >> 8 != TOKEN_OWNER_OF) {
		  //0x6352211e == "ownerOf(uint256)"
		  calldata = abi.encodeWithSelector(0x6352211e, _tokenId);
		  assembly {
		    callSuccess := staticcall(gas, rootOwner, add(calldata, 0x20), mload(calldata), calldata, 0x20)
		    if callSuccess {
		 	  rootOwner := mload(calldata)
		    }
		  }
		  require(callSuccess, "rootOwnerOf failed");
		  isParent = 0;
	    }
	  }
	  else {
	    isParent = 0;
	  }
    }
  }
  return rootOwner;
}
```

#### onERC721Received
```solidity
  /// @notice A token receives a child token
  /// @param _operator The address that caused the transfer.
  /// @param _from The owner of the child token.
  /// @param _childTokenId The token that is being transferred to the parent.
  /// @param _data Up to the first 32 bytes contains an integer which is the receiving parent tokenId.  
  function onERC721Received(address _operator, address _from, uint256 _childTokenId, bytes _data) 
    external 
    returns(bytes4);
```

This is a 







// getChild function enables older contracts like cryptokitties to be transferred into a composable
  // The _childContract must approve this contract. Then getChild can be called.
  
  
interface ERC998ERC721TopDownEnumerable {
  function totalChildContracts(uint256 _tokenId) external view returns(uint256);
  function childContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address childContract);
  function totalChildTokens(uint256 _tokenId, address _childContract) external view returns(uint256);
  function childTokenByIndex(uint256 _tokenId, address _childContract, uint256 _index) external view returns (uint256 childTokenId);
}

interface ERC998ERC20TopDown {
  event ReceivedERC20(address indexed _from, uint256 indexed _tokenId, address indexed _erc223Contract, uint256 _value);
  event TransferERC20(uint256 indexed _tokenId, address indexed _to, address indexed _erc223Contract, uint256 _value);

  function tokenOwnerOf(uint256 _tokenId) external view returns (address tokenOwner, uint256 parentTokenId, uint256 isParent);
  function tokenFallback(address _from, uint256 _value, bytes _data) external;
  function balanceOfERC20(uint256 _tokenId, address __erc223Contract) external view returns(uint256);
  function transferERC20(uint256 _tokenId, address _to, address _erc223Contract, uint256 _value) external;
  function transferERC223(uint256 _tokenId, address _to, address _erc223Contract, uint256 _value, bytes _data) external;
  function getERC20(address _from, uint256 _tokenId, address _erc223Contract, uint256 _value) external;

}

interface ERC998ERC20TopDownEnumerable {
  function totalERC20Contracts(uint256 _tokenId) external view returns(uint256);
  function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns(address);
}






## Rationale


## Backwards Compatibility


## Implementations


## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).



