---
eip: 4972
title: Name-Owned Account
description: Name-Owned Account for Social Identity
author: Qi Zhou (@qizhou), Shu Dong (@dongshu2013)
discussions-to: https://ethereum-magicians.org/t/eip-4972-name-owned-account/8822
status: Review
type: Standards Track
category: ERC
created: 2022-04-04
requires: 20, 721, 1155
---

## Abstract
This ERC proposes a new type of account - name-owned account (NOA) that is controlled by the owner of the name besides existing externally-owned account (EOA) and contract account (CA). With the new account type, users will be able to transfer/receive tokens using the name-derived address directly instead of the address of the name owner. A NOA can be as a social identity with all states on-chain even under 3rd-party or self custody. It also simplifies porting the social identity from one custody to another.

## Motivation
A popular way to onboard Web2 users to the Web3 world is custody. However, current custody models have severe drawbacks. Considering the following widely adopted custody models:
1. The custodian uses one EOA/CA to hold the assets of all users. This is not compatible with on-chain social protocols since all user activities are off-chain.
2. One EOA per user. The social identity is not portable, which means there is no way for users to migrate their social identity across different custody platforms.
3. One CA (e.g. Gnosis Safe) per user. The one time deployment cost is super high and the user experience is not good.

To solve all these problems, this ERC proposes a new type of account - name-owned account (NOA).  Using NOA as social identity instead of EOA/CA brings huge benefits for users:
- **Easy Web2 user onboarding**. We are providing standard Web2 user experiences with human readable names and 3rd-party custody. Every user of a centralized platform can immediately have a NOA by using the username as the name of NOA custodied by the platform.
- **On-chain states**. All user states are on-chain even under custody so itâ€™s 100% compatible with social protocols.
- **Portable Account**. A NOA can be easily ported to different custody platforms by changing the owner.
- **Flexible Account Management**. We can use one EOA/CA to control any number of NOAs.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

### Name-Owned Account
An NOA has
1. a name for social identity; and
2. an address derived from the name to receive tokens; and
3. owner(s) of the name that can transfer the token.

The name should be human-readable and can be easily recognized socially. An example is an username of a name service or an email address of a centralized platform such as Gmail. The name-derived address (NDA) is a normal Ethereum address that should not collide with the existing addresses of EOA/CA. Since we cannot use NDA as msg.sender, the right to transfer the tokens of the NDA is controlled by the owner/owners of the name. The name to owner/owners mapping is managed by an on-chain name service, and the owner/owners should be EOA/CA, which can be the addresses of 3-rd custodians (e.g., Facebook or Google) or self-custodian. By changing the owner of the name to the EOA of the user (can be done by requesting the custodian), the NDA becomes self-custodian, and no one should be able to transfer the assets unless the approved by the self-custodian user. 


### Name Representation

A name is represented by a bytes array which is ABI encoded. It **MAY** contain metadata of the name such as the name service the name belongs to.  Example of the name is "vitalik.eth" or "qizhou@quarkchain.org".

### Interface

#### INameOwnedAccount

```solidity
interface INameOwnedAccount {
    /// @notice This function resolves a name to NDA
    /// @dev The implementation SHOULD avoid collision between name 
    /// derived address and EOA/CA
    /// @dev Return address(0) if the name is not supported
    function addressOfName(bytes memory _name) public view returns(address);

    /// @notice This function returns true if and only if _nda represents a name
    /// and the _operator is the owner of the name
    /// @dev The ownership MAY be defined by a name service such as ENS
    function isNameOwner(address _nda, address _operator) public view returns(bool);
}
```

#### `IERC721NOA`

```solidity
interface IERC721NOA is IERC721, INameOwnedAccount { }
```

The existing `transferFrom` and `safeBatchTransferFrom` functions MUST assume caller is approved to manage tokens of `_from` if `_from` represents a name and the caller is the owner of the name.

```solidity
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;
function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
```

The existing `isApprovedForAll` function of `IERC721` MUST return true if the `_owner` represents a name and `_operator` is the owner of the name.

```solidity
function isApprovedForAll(address _owner, address _operator) external view returns (bool);
```

The existing `ownerOf` function at `IERC721` should return the NOA owning the token.

```solidity
function ownerOf(uint256 _tokenId) external view returns (address);
```

#### `IERC1155NOA`
```solidity
interface IERC1155NOA is IERC1155, INameOwnedAccount  {}
```

The existing `safeTransferFrom` and `safeBatchTransferFrom` functions MUST assume caller is approved to manage tokens of `_from` if `_from` represents a name and the caller is the owner of the name.

```solidity
function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;
function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;
```

The existing `isApprovedForAll` function of `IERC1155` MUST return true if the `_owner` represents a name and `_operator` is the owner of the name.

```solidity
function isApprovedForAll(address _owner, address _operator) external view returns (bool);
```

#### `IERC20NOA`

```solidity
interface IERC20NOA is IERC20, INameOwnedAccount {}
```

The existing `transferFrom` function MUST assume caller is approved to manage tokens of `_from` if `_from` represents a name and the caller is the owner of the name.

```solidity
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)
```

The existing `allowance ` function MUST return max value of uint256 if `_owner` represents a name and the `_spender` is the owner of the name.

```solidity
function allowance(address _owner, address _spender) public view returns (uint256 remaining)
```

## Rationale

The isNameOwner function is sufficient for authenticating the message sender. One can verify the owner by looking up the owner of an NDA from a name service.

The addressOfName interface decouples the implementation from specific NDA encoding algorithm. How to encode a name to an NDA is not defined by this standard, as long as the generated NDA does not collide with EOA/CA address space.

## Backwards Compatibility

The new account type is compatible with existing ERC token standards.

## Reference Implementation

### Name Derived Address (INameOwnedAccount.addressOfName())


Each token contract can decide how to encode the name to an NDA as long as the address space of NDAs does not overlap with existing EOA/CA spaces. We can follow the similar rule of CREATE2 opcode to compute the NDA from a name service and the hash of a username as 

```solidity
address(keccak256(0xff, keccak256("eip-4972.addressOfName"), nameServiceAddress, keccak256(username))).
```

This can ensure it will not collide with existing smart contract account addresses.

### Ownership of a Name (INameOwnedAccount.isNameOwner())

Given an NDA, we need to look up the owner from a name service and compare it with the message sender. Note that currently, ENS only supports namehash (32 bytes) to owner translation, and thus we may need an additional helper contract to map an NDA to a namehash for ENS.

## Security Considerations

No security considerations were found.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).
