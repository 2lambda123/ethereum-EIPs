---
eip: 5252
title: Account-bound Finance
description: An EIP-5114 extension that aids in preventing arbitrary loss of funds
author: Hyungsuk Kang (@hskang9), Viktor Pernjek (@smuxx)
discussions-to: https://ethereum-magicians.org/t/pr-5252-discussion-account-bound-finance/10027
status: Draft
type: Standards Track
category: ERC
created: 2022-06-29
requires: 20, 721, 1155, 5114
---

## Abstract
This EIP proposes a form of smart contract design pattern and a new type of account abstraction on how one's finance should be managed in web3.0, ensuring transparency of managing investments and protection with self-sovereignty even from its financial operators.

This EIP extends [EIP-5114](./eip-5114.md) to further enable transferring fund to other accounts for mobility between managing multiple wallets(i.e. private keys).

## Motivation

Finance in the crypto ecosystem is facing a huge trust issue. Smart contracts are often proxies, with the actual logic of the contract hidden away in a separate logic contract. Many projects include a multi-signature "wallet" with unnecessarily-powerful permissions. And it is not possible to independently verify that stablecoins have enough real-world assets to continue maintaining their peg, creating a large loss of funds (such as happened in the official bankruptcy announcement of Celsius and UST de-pegging and anchor protocol failure). One should not trust exchanges or other third parties with one's own investments with the operators' background, status, or cult of personality in web3.0.

The pattern empowers more self-sovereignty and gives more credentials(obviously with an Account-bound token) than locking financial data in the operating team's contract with a trustless way.

#### Offchain-identity vs Soul-bound token on credentials 

This EIP opposes the offchain-identity solution to take over the whole system, because their backend eventually relies on the trust of the operator, not the cryptographic proof of storing data(e.g. Proof-of-work, Proof-of-stake, etc). Offchain identity as credentials denies the whole premise of crypto's existence. Hence, Soul-bound token is the verifiable credential to stay, and offchain integration is just enough to show images.

## Specification
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The specification consists of two patterns for **Interaction** and **Governance**.

### Interaction

#### Interfaces

The interaction pattern consists of 4 components for interaction; manager, factory, finance, account-bound token, and extension.

Interaction contract pattern is defined with these contracts:
- A soul-bound or account bound token contract to give access to interact with a financial contract with credentials
- A manager contract that interacts first contact with an investor
- A factory contract that creates a financial contract for each user
- A finance contract that can interact with the investor

#### Requirements

A soul-bound or account bound token contract is defined with these properties:
1. It is non-fungible and MUST satisfy [EIP-721](./eip-721.md).
2. Credentials SHOULD be represented with its metadata with `tokenURI()` function.
3. It MUST only reference factory to verify its minting. 
4. If it is transferrable, it is account-bound. If not, it is soul-bound.

A manager contract is defined with these properties:
1. It MUST be the only kind of contract which calls factory to create.
2. It SHOULD store all related configurations for financial parameters.

A factory contract is defined with these properties:
1. It clones the finance contract with uniform implementation.
2. It MUST be the only contract that can mint account-bound token.
3. It MUST keep an recent id of account bound token.

A finance contract is defined with these properties:
1. A finance contract MUST only be initialized once from factory contract in constructor.
2. Funds in the contract SHALL NOT be transferred to other contracts nor accounts unless sender who owns soul-bound or account bound token signs to do so.
3. Every state-changing function of the smart contract MUST only accept sender who owns soul-bound or account bound-token except global function(e.g. liquidation).
4. Global function SHOULD be commented as `/* global */` to clarify the function is can be accessed with anyone.  
4. Each finance contract SHOULD be able to represent transaction that has happened only with those who had account-bound token. 
5. If soul-bound token is used for access, the finance contract MUST be able to represent transaction that has happened only between whom had the private key and the finance contract.

#### Contracts

<figure>
<img src="../assets/eip-5252/media/media.svg" alt="Diagram" style="width:100%">
<figcaption align = "center"><b>Fig 1 - Contract Diagram of EIP-5252</b></figcaption>
</figure>


**`Manager`**: **`Manager`** contract acts as an entry point to interact with the investor. The contract also stores parameters for **`Finance`** contract.

**`Factory`**: **`Factory`** contract manages contract bytecode to create for managing investor's fund and clones **`Finance`** contract on **`Manager`** contract's approval. It also mints account-bound tokens to interact with the `Finance` contract.

**`Finance`**: **`Finance`** contract specifies all rules on managing an investor's fund. The contract is only accessible with an account that has an Account-bound token. When an investor deposits a fund to **`Manager`** contract, the contract sends the fund to **`Finance`** contract account after separating fees for operation. 

**`Account-bound token`**: **`Account-bound token`** contract in this EIP can bring the **`Finance`** contract's data and add metadata. For example, if there is a money market lending 
**`Finance`** contract, its **`Account-bound token`** can show how much balance is in agreement using SVG.

**`Extension`**: **`Extension`** contract is another contract that can utilize locked funds in **`Finance`** contract. The contract can access with **`Finance`** contract on operator's approval managed in **`Manager`** contract. Example use case of `Extension` can be a membership.

**`Metadata`**: **`Metadata`** contract is the contract where it stores metadata related to account credentials. Credential related data are stored with specific key. Images are usually displayed as SVG, but offchain image is possible. 

---

### Governance

The governance pattern consists of 2 components; influencer and governor. 

#### Interfaces

#### Requirements

#### From Token Governance To Contribution Based Governance

|               | Token Governance                 | Credential-based Governance                      |
|---------------|----------------------------------|--------------------------------------------------|
| Enforcement   | More tokens, more power          | More contribution, More power                    |
| Incentives    | More tokens, more incentives     | More contribution, more incentives           |
| Penalty       | No penalty                       | Loss of power                  |
| Assignment | One who holds the token | One who has the most influence |

<figcaption align = "center"><b>Token Governance vs Credential Based Governance</b></figcaption>


Token governance is not sustainable in that it gives **more** power to "those who most want to rule". Any individual who gets more than 51% of token supply can change the rules to their favor.

For example, Terraform Labs kept approximately 70% of their tokens or they printed more if the founder wanted to. They could manipulate voting turnout and decisions. 

New governance that considers contributions to the protocol is needed because:

- **Rulers can be penalized on breaking the protocol**
- **Rulers can be more effectively incentivized on maintaining the protocol**

The power should be given to "those who are most responsible". Instead of locked or owned tokens, voting power is determined with contributions are marked in `Account Bound Token`(ABT). This EIP defines new voting power as **`Influence`**.

#### Calculating Influence

**`Influence`** is a multiplier on staked tokens that brings more voting power of a DAO to its contributors. To get **`Influence`**, a score is calculated on weighted contribution matrix. Then, the score is normalized to give a member's position in whole distribution. Finally, the multiplier is determined on the position in every community members. 

#### Calculating score
The weights represent relative importance on each factor. The total importance is the total sum of the factors. More factors that can be normalized at the time of submitting proposal can be added by community.

|    | Description                                         |
|----|------------------------------------------------|
| α  | Contribution value per each **`Finance`** contract from current proposal|
| β  | Time they maintained **`Finance`** per each contract from current timestamp of a proposal|
```
(score per each ABT) = α * (contribution value) + β * (time that abt was maintained from now)
```

#### Normalization

Normalization is applied for data integrity on user's contribution in a DAO.
Normalized score can be calculated from the state of submitting a proposal

```
(Normalized score per each ABT) = α * (contribution value)/(total contribution value at submitting tx) + β * (time that abt was maintained)/(time passed from genesis to proposal creation) 
```
and have a value between 0 and 1 (since α + β = 1).

#### Multiplier

Multiplier is determined linearly from base factor (b) and multiplier(m).

The equation for influence is :

```
(influence) = m * (sum(normalized_score))
```

#### Example


For example, if a user has 3 **`Account-bound tokens`** with normalized score of each 1.0, 0.5, 0.3 and the locked token is 100, and multiplier is 0.5 and base factor is 1.5. Then the total influence is


 0.5 * {(1.0 + 0.5 + 0.3) / 3} + 1.5 = 1.8

 The total voting power would be

 ```(voting power) = 1.8 * sqrt(100)  = 18```



#### Stakers vs Enforcers

|              | Stakers               | Enforcers                                                                               |
|--------------|-----------------------|-----------------------------------------------------------------------------------------|
| Role         | stake governance token for voting | Contributed on the system, can make proposal to change rule, more voting power like 1.5 |
| Populations  | many                  | small                                                                                   |
| Contribution | Less effect           | More effect                                                                             |
| Influence       | sqrt(locked token)    | Influence * sqrt(locked token)                                                                      |
<figcaption align = "center"><b>Fig 1 - Stakers vs Enforcers</b></figcaption>



**Stakers**:  Stakers are people who vote to enforcers' proposals and get dividend for staked tokens

**Enforcers**: Enforcers are people who takes risk on managing protocol and contributes to the protocol by making a proposal and change to it.


#### Contracts

**`Influencer`**: **`Influencer`** contract stores influence configurations and measures the contribution of a user from his activities done in registered **`Account Bound Token(ABT)`** contract. The contract puts lock on **`Account Bound Token(ABT)`** until proposal is finalized.


**`Governor`**: **`Governor`** contract is compatible with current governor contract in Openzeppelin. For its special use case, it configures factor where influencer manages and has access on changing parameter of **`Manager`** configs. Only `Enforcer` can propose new parameters.

## Rationale

#### No more proxy of multisigs
Smart contracts without one's full control is basically a proxy with multisig with smart contract operators. One of members can easily run away with the operating funds as 0xSifu from Magic Internet Money(MIM).

#### Gas saving for end user
Operating gas cost with one defi contract vs multiple contract was actually gas saving if clone factory pattern was applied. One defi contract storing m users' state globally means each user is actually paying for storage cost on other previous users after interacting with the contract. This makes MakerDAO's contract operating cost to be sometimes over 0.1 ETH, and sometimes limit user's minimum deposit for CDP to save gas cost. To solve inefficient n-times charging gas cost interaction for future users, one contract per user is needed.

#### Separation between investor's and operation fund
Separation between investor's fund and operation fee is clearly specified in the smart contract, so investors can ensure safety from arbitrary loss of funds by the operating team's control.


## Backwards Compatibility
This EIP has no known backward compatibility issues.

## Reference Implementation

[Reference implementation](../assets/eip-5252) is a simple deposit account contract as `Finance` contract and its contribution value α is measured with deposit amount with ETH.

## Security Considerations

- **`Factory`** contract must ensure that each **`Finance`** contract is registered in the factory and check **`Finance`** contract is sending transaction related to its bounded owner.

- Reentrancy attack guard should be applied or change state before delegatecall in each user function in **`Manager`** contract or **`Finance`** contract. Otherwise, **`Finance`** can be generated as double and ruin whole indices. 

- Once a user locks influence on a proposal's vote, **`Account Bound Token`** cannot be transferred to other wallet. Otherwise, double influence can happen. 

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).

