---
eip: 5773
title: Multi-Resource context-dependent tokens
description: An interface for Multi-Resource tokens with context dependent resource type output controlled by owner's preference.
author: Bruno Škvorc (@Swader), Cicada (@CicadaNCR), Steven Pineda (@steven2308), Stevan Bogosavljevic (@stevyhacker), Jan Turk (@ThunderDeliverer)
discussions-to: https://ethereum-magicians.org/t/multiresource-tokens/11326
status: Draft
type: Standards Track
category: ERC
created: 2022-10-10
requires: 165, 721
---

## Abstract

The Multi-Resource NFT standard allows for the construction of a new primitive: context-dependent output of multimedia information per single NFT.

The context-dependent output of multimedia information means that the resource in an appropriate format is displayed based on how the token is being accessed. I.e. if the token is being opened in an e-book reader, the PDF resource is displayed, if the token is opened in the marketplace, the PNG or the SVG resource is displayed and if the token is accessed from within a game, the 3D model resource is accessed.

An NFT can have multiple resources (outputs), which can be any kind of file to be served to the consumer, and orders them by priority. They do not have to match in mimetype or tokenURI, nor do they depend on one another. Resources are not standalone entities, but should be thought of as “namespaced tokenURIs” that can be ordered at will by the NFT owner, but only modified, updated, added, or removed if agreed on by both the owner of the token and the issuer of the token.

## Motivation

With NFTs being a widespread form of tokens in the Ethereum ecosystem and being used for a variety of use cases, it is time to standardize additional utility for them. Having multiple resources associated with a single NFT allows for greater utility, usability and forward compatibility.

In the four years since [EIP-721](./eip-721.md) was published, the need for additional functionality has resulted in countless extensions. This EIP improves upon EIP-721 in the following areas:

- [Cross-metaverse compatibility](#cross-metaverse-compatibility)
- [Multi-media output](#multi-media-output)
- [Media redundancy](#media-redundancy)
- [NFT evolution](#nft-evolution)

### Cross-metaverse compatibility

At the time of writing this proposal, the metaverse is still a fledgling, not full defined, term. No matter how the definition of metaverse evolves, the proposal can support any number of different implementations.

Cross-metaverse compatibility could also be referred to as cross-engine compatibility. An example of this is where a cosmetic item for game A is not available in game B because the frameworks are incompatible.

Such NFT can be given further utility by means of new additional resources: more games, more cosmetic items, appended to the same NFT. Thus, a game cosmetic item as an NFT becomes an ever-evolving NFT of infinite utility.

The following is a more concrete example. One resource is a cosmetic item for game A, a file containing the cosmetic assets. Another is a cosmetic asset file for game B. A third is a generic resource intended to be shown in catalogs, marketplaces, portfolio trackers, or other generalized NFT viewers, containing a representation, stylized thumbnail, and animated demo/trailer of the cosmetic item.

This EIP adds a layer of abstraction, allowing game developers to directly pull asset data from a user's NFTs instead of hard-coding it.

### Multi-media output

An NFT of an eBook can be represented as a PDF, MP3, or some other format, depending on what software loads it. If loaded into an eBook reader, a PDF should be displayed, and if loaded into an audiobook application, the MP3 representation should be used. Other metadata could be present in the NFT (perhaps the book's cover image) for identification on various marketplaces, Search Engine Result Pages (SERPs), or portfolio trackers.

### Media redundancy

Many NFTs are minted hastily without best practices in mind - specifically, many NFTs are minted with metadata centralized on a server somewhere or, in some cases, a hardcoded IPFS gateway which can also go down, instead of just an IPFS hash.

By adding the same metadata file as different resources, e.g., one resource of a metadata and its linked image on Arweave, one resource of this same combination on Sia, another of the same combination on IPFS, etc., the resilience of the metadata and its referenced media increases exponentially as the chances of all the protocols going down at once become less likely.

### NFT evolution

Many NFTs, particularly game related ones, require evolution. This is especially the case in modern metaverses where no metaverse is actually a metaverse - it is just a multiplayer game hosted on someone's server which replaces username/password logins with reading an account's NFT balance.

When the server goes down or the game shuts down, the player ends up with nothing (loss of experience) or something unrelated (resources or accessories unrelated to the game experience, spamming the wallet, incompatible with other “verses” - see [cross-metaverse](#cross-metaverse-compatibility) compatibility above).

With Multi-Resource NFTs, a minter or another pre-approved entity is allowed to suggest a new resource to the NFT owner who can then accept it or reject it. The resource can even target an existing resource which is to be replaced.

Replacing a resource could, to some extent, be similar to replacing an EIP-721 token's URI. When a resource is replaced a clear line of traceability remains; the old resource is still reachable and verifiable. Overwriting a resource's metadata URI obscures this lineage. It also gives more trust to the token owner if the issuer cannot replace the resource of the NFT at will. The propose-accept resource replacement mechanic of this proposal provides this assurance.

This allows level-up mechanics where, once enough experience has been collected, a user can accept the level-up. The level-up consists of a new resource being added to the NFT, and once accepted, this new resource replaces the old one.

As a concrete example, think of Pokemon™️ evolving - once enough experience has been attained, a trainer can choose to evolve their monster. With Multi-Resource NFTs, it is not necessary to have centralized control over metadata to replace it, nor is it necessary to airdrop another NFT into the user's wallet - instead, a new Raichu resource is minted onto Pikachu, and if accepted, the Pikachu resource is gone, replaced by Raichu, which now has its own attributes, values, etc.

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

````solidity
/// @title ERC-5773 Multi-Resource context-dependent tokens
/// @dev See https://eips.ethereum.org/EIPS/eip-5773
///  Note: the ERC-165 identifier for this interface is 0xb0ecc5ae.

pragma solidity ^0.8.16;

interface IMultiResource {
    /**
     * @notice Used to notify listeners that a resource object is initialized at `resourceId`.
     * @param resourceId ID of the resource that was initialized
     */
    event ResourceSet(uint64 resourceId);

    /**
     * @notice Used to notify listeners that a resource object at `resourceId` is added to token's pending resource
     *  array.
     * @param tokenId ID of the token that received a new pending resource
     * @param resourceId ID of the resource that has been added to the token's pending resources array
     * @param overwritesId ID of the resource that would be overwritten
     */
    event ResourceAddedToToken(
        uint256 indexed tokenId,
        uint64 indexed resourceId,
        uint64 indexed overwritesId
    );

    /**
     * @notice Used to notify listeners that a resource object at `resourceId` is accepted by the token and migrated
     *  from token's pending resources array to active resources array of the token.
     * @param tokenId ID of the token that had a new resource accepted
     * @param resourceId ID of the resource that was accepted
     * @param overwritesId ID of the resource that would be overwritten
     */
    event ResourceAccepted(
        uint256 indexed tokenId,
        uint64 indexed resourceId,
        uint64 indexed overwritesId
    );

    /**
     * @notice Used to notify listeners that a resource object at `resourceId` is rejected from token and is dropped
     *  from the pending resources array of the token.
     * @param tokenId ID of the token that had a resource rejected
     * @param resourceId ID of the resource that was rejected
     */
    event ResourceRejected(uint256 indexed tokenId, uint64 indexed resourceId);

    /**
     * @notice Used to notify listeners that token's prioritiy array is reordered.
     * @param tokenId ID of the token that had the resource priority array updated
     */
    event ResourcePrioritySet(uint256 indexed tokenId);

    /**
     * @notice Used to notify listeners that owner has granted an approval to the user to manage the resources of a
     *  given token.
     * @dev Approvals must be cleared on transfer
     * @param owner Address of the account that has granted the approval for all token's resources
     * @param approved Address of the account that has been granted approval to manage the token's resources
     * @param tokenId ID of the token on which the approval was granted
     */
    event ApprovalForResources(
        address indexed owner,
        address indexed approved,
        uint256 indexed tokenId
    );

    /**
     * @notice Used to notify listeners that owner has granted approval to the user to manage resources of all of their
     *  tokens.
     * @param owner Address of the account that has granted the approval for all resources on all of their tokens
     * @param operator Address of the account that has been granted the approval to manage the token's resources on all of the
     *  tokens
     * @param approved Boolean value signifying whether the permission has been granted (`true`) or revoked (`false`)
     */
    event ApprovalForAllForResources(
        address indexed owner,
        address indexed operator,
        bool approved
    );

    /**
     * @notice Accepts a resource at from the pending array of given token.
     * @dev Migrates the resource from the token's pending resource array to the token's active resource array.
     * @dev Active resources cannot be removed by anyone, but can be replaced by a new resource.
     * @dev Requirements:
     *
     *  - The caller must own the token or be approved to manage the token's resources
     *  - `tokenId` must exist.
     *  - `index` must be in range of the length of the pending resource array.
     * @dev Emits an {ResourceAccepted} event.
     * @param tokenId ID of the token for which to accept the pending resource
     * @param index Index of the resource in the pending array to accept
     * @param resourceId expected to be in the index
     */
    function acceptResource(
        uint256 tokenId,
        uint256 index,
        uint64 resourceId
    ) external;

    /**
     * @notice Rejects a resource from the pending array of given token.
     * @dev Removes the resource from the token's pending resource array.
     * @dev Requirements:
     *
     *  - The caller must own the token or be approved to manage the token's resources
     *  - `tokenId` must exist.
     *  - `index` must be in range of the length of the pending resource array.
     * @dev Emits a {ResourceRejected} event.
     * @param tokenId ID of the token that the resource is being rejected from
     * @param index Index of the resource in the pending array to be rejected
     * @param resourceId expected to be in the index
     */
    function rejectResource(
        uint256 tokenId,
        uint256 index,
        uint64 resourceId
    ) external;

    /**
     * @notice Rejects all resources from the pending array of a given token.
     * @dev Effecitvely deletes the pending array.
     * @dev Requirements:
     *
     *  - The caller must own the token or be approved to manage the token's resources
     *  - `tokenId` must exist.
     * @dev Emits a {ResourceRejected} event with resourceId = 0.
     * @param tokenId ID of the token of which to clear the pending array
     * @param maxRejections to prevent from rejecting resources which arrive just before this operation.
     */
    function rejectAllResources(uint256 tokenId, uint256 maxRejections)
        external;

    /**
     * @notice Sets a new priority array for a given token.
     * @dev The priority array is a non-sequential list of `uint16`s, where the lowest value is considered highest
     *  priority.
     * @dev Value `0` of a priority is a special case equivalent to unitialized.
     * @dev Requirements:
     *
     *  - The caller must own the token or be approved to manage the token's resources
     *  - `tokenId` must exist.
     *  - The length of `priorities` must be equal the length of the active resources array.
     * @dev Emits a {ResourcePrioritySet} event.
     * @param tokenId ID of the token to set the priorities for
     * @param priorities An array of priorities of active resources. The succesion of items in the priorities array
     *  matches that of the succesion of items in the active array
     */
    function setPriority(uint256 tokenId, uint16[] calldata priorities)
        external;

    /**
     * @notice Used to retrieve IDs of the active resources of given token.
     * @dev Resource data is stored by reference, in order to access the data corresponding to the ID, call
     *  `getResourceMetadata(tokenId, resourceId)`.
     * @dev You can safely get 10k
     * @param tokenId ID of the token to retrieve the IDs of the active resources
     * @return uint64[] An array of active resource IDs of the given token
     */
    function getActiveResources(uint256 tokenId)
        external
        view
        returns (uint64[] memory);

    /**
     * @notice Used to retrieve IDs of the pending resources of given token.
     * @dev Resource data is stored by reference, in order to access the data corresponding to the ID, call
     *  `getResourceMetadata(tokenId, resourceId)`.
     * @param tokenId ID of the token to retrieve the IDs of the pending resources
     * @return uint64[] An array of pending resource IDs of the given token
     */
    function getPendingResources(uint256 tokenId)
        external
        view
        returns (uint64[] memory);

    /**
     * @notice Used to retrieve the priorities of the active resoources of a given token.
     * @dev Resource priorities are a non-sequential array of uint16 values with an array size equal to active resource
     *  priorites.
     * @param tokenId ID of the token for which to retrieve the priorities of the active resources
     * @return uint16[] An array of priorities of the active resources of the given token
     */
    function getActiveResourcePriorities(uint256 tokenId)
        external
        view
        returns (uint16[] memory);

    /**
     * @notice Used to retrieve the resource that will be overriden if a given resource from the token's pending array
     *  is accepted.
     * @dev Resource data is stored by reference, in order to access the data corresponding to the ID, call
     *  `getResourceMetadata(tokenId, resourceId)`.
     * @param tokenId ID of the token to check
     * @param newResourceId ID of the pending resource which will be accepted
     * @return uint64 ID of the resource which will be replaced
     */
    function getResourceOverwrites(uint256 tokenId, uint64 newResourceId)
        external
        view
        returns (uint64);

    /**
     * @notice Used to fetch the resource metadata of the specified token's active resource with the given index.
     * @dev Can be overriden to implement enumerate, fallback or other custom logic.
     * @param tokenId ID of the token from which to retrieve the resource metadata
     * @param resourceId Resource Id, must be in the active resources array
     * @return string The metadata of the resource belonging to the specified index in the token's active resources
     *  array
     */
    function getResourceMetadata(uint256 tokenId, uint64 resourceId)
        external
        view
        returns (string memory);

    /**
     * @notice Used to grant permission to the user to manage token's resources.
     * @dev This differs from transfer approvals, as approvals are not cleared when the approved party accepts or
     *  rejects a resource, or sets resource priorities. This approval is cleared on token transfer.
     * @dev Only a single account can be approved at a time, so approving the `0x0` address clears previous approvals.
     * @dev Requirements:
     *
     *  - The caller must own the token or be an approved operator.
     *  - `tokenId` must exist.
     * @dev Emits an {ApprovalForResources} event.
     * @param to Address of the account to grant the approval to
     * @param tokenId ID of the token for which the approval to manage the resources is granted
     */
    function approveForResources(address to, uint256 tokenId) external;

    /**
     * @notice Used to retrieve the address of the account approved to manage resources of a given token.
     * @dev Requirements:
     *
     *  - `tokenId` must exist.
     * @param tokenId ID of the token for which to retrieve the approved address
     * @return address Address of the account that is approved to manage the specified token's resources
     */
    function getApprovedForResources(uint256 tokenId)
        external
        view
        returns (address);

    /**
     * @notice Used to add or remove an operator of resources for the caller.
     * @dev Operators can call {acceptResource}, {rejectResource}, {rejectAllResources} or {setPriority} for any token
     *  owned by the caller.
     * @dev Requirements:
     *
     *  - The `operator` cannot be the caller.
     * @dev Emits an {ApprovalForAllForResources} event.
     * @param operator Address of the account to which the operator role is granted or revoked from
     * @param approved The boolean value indicating whether the operator role is being granted (`true`) or revoked
     *  (`false`)
     */
    function setApprovalForAllForResources(address operator, bool approved)
        external;

    /**
     * @notice Used to check whether the address has been granted the operator role by a given address or not.
     * @dev See {setApprovalForAllForResources}.
     * @param owner Address of the account that we are checking for whether it has granted the operator role
     * @param operator Address of the account that we are checking whether it has the operator role or not
     * @return bool The boolean value indicating wehter the account we are checking has been granted the operator role
     */
    function isApprovedForAllForResources(address owner, address operator)
        external
        view
        returns (bool);
}
````

The metadata, to which the metadata URI of the resource points, MAY contain a JSON response with the following fields:

````json
{
  "title": "Asset Metadata",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "Identifies the name of the asset associated with the resource"
    },
    "description": {
      "type": "string",
      "description": "Identifies the general notes, abstracts, or summaries about the contents of the resource"
    },
    "type": {
      "type": "string",
      "description": "Identifies the definition of the type of content of the resource"
    },
    "locale": {
      "type": "string",
      "description": "Identifies metadata locale in ISO 639-1 format for translations and localisation of the resource"
    },
    "license": {
      "type": "string",
      "description": "Identifies the license attached to the resource"
    },
    "licenseUri": {
      "type": "string",
      "description": "Identifies the URI to the license statement of the license attached to the resource"
    },
    "mediaUri": {
      "type": "string",
      "description": "Identifies the URI of the main media file associated with the resource"
    },
    "thumbnailUri": {
      "type": "string",
      "description": "Identifies the URI of the thumbnail image associated with the resource to be used for preview of the resource in the wallets and client applications (the recommended maximum size is 350x350 px)"
    },
    "externalUri": {
      "type": "string",
      "description": "Identifies the URI to the additional information about the subject or content of the resource"
    },
    "properties": {
      "type": "object",
      "properties": "Identifies the optional custom attributes of the resource"
    }
  }
}
````

While this is the suggested JSON schema for the resource metadata, it is not enforced and MAY be stuctured completely differently based on implementer's preference.

The optional properties of the metadata JSON MAY include the following fields, or it MAY incorporate any number of custom fields, but MAY also not be included in the schema at all:

````json
    "properties": {
      "rarity": {
        "type": "string",
        "value": "epic"
      },
      "color": {
        "type": "string",
        "value": "red"
      },
      "height": {
        "type": "float",
        "value": 192.4
      },
      "tags": {
        "type": "array",
        "value": ["music", "2020", "best"]
      }
    }
````

## Rationale

Desinging the proposal, we considered the following questions:

1. **Why are EIP-712 permit-style signatures to manage approvals not used?**

For consistency. This proposal extends ERC-721 which already uses 1 transaction for approving operations with tokens. It would be inconsistent to have this and also support signing messages for operations with resources.

2. **Why use indexes?**

To reduce the gas consumption. If the resource ID was used to find which token to accept or reject, iteration over arrays would be required and the cost of the operation would depend on the size of the active or pending children arrays. With the index, the cost is fixed. A list of active and pending children arrays per token need to be maintained, since methods to get them are part of the proposed interface.

To avoid race conditions in which the index of a resource changes, the expected resource ID is included in operations requiring resource index, to verify that the resource being accessed using the index is the expected resource.

Implementation that whould internally keep track of indices using mapping was attemped. The average cost of adding a resource to a token increased by over 25%, costs of accepting and rejecting resources also increased 4.6% and 7.1% respeticvely. We concluded that it is not necessary for this proposal and can be implemented as an extension for use cases willing to accept this cost. In the sample implementation provided, there are several hooks which make this possible.

3. **Why is a method to get all the resources not included?**

Getting all resources might not be an operation necessary for all implementers. Additionally, it can be added either as an extension, doable with hooks, or can be emulated using an indexer.

4. **Why is pagination not included?**

Resource IDs use `uint64`, testing has confirmed that the limit of IDs you can read before reaching the gas limit is around 30.000. This is not expected to be a common use case so it is not a part of the interface. However, an implementer can create an extension for this use case if needed.

5. **How does this proposal differ from the other proposals trying to address a similar problem?**

After reviewing them, we concluded that each contains at least one of these limitations:

- Using a single URI which is replaced as new resources are needed, this introduces a trust issue for the token owner.
- Focusing only on a type of resource, while this proposal is resource type agnostic.
- Having a different token for each new use case, this means that the token is not forward-compatible.

### Multi-Resource Storage Schema

Resources are stored within a token as an array of `uint64` identifiers.

In order to reduce redundant on-chain string storage, multi resource tokens store resources by reference via inner storage. A resource entry on the storage is stored via a `uint64` mapping to resource data.

A resource array is an array of these `uint64` resource ID references.

Such a structure allows that, a generic resource can be added to the storage one time, and a reference to it can be added to the token contract as many times as we desire. Implementers can then use string concatenation to procedurally generate a link to a content-addressed archive based on the base *SRC* in the resource and the *token ID*. Storing the resource in a new token will only take 16 bytes of storage in the resource array per token for recurrent as well as `tokenId` dependent resources.

Structuring token's resources in such a way allows for URIs to be derived programmatically through concatenation, especially when they differ only by `tokenId`.

### Propose-Commit pattern for resource addition

Adding resources to an existing token MUST be done in the form of a propose-commit pattern to allow for limited mutability by a 3rd party. When adding a resource to a token, it is first placed in the *"Pending"* array, and MUST be migrated to the *"Active"* array by the token's owner. The *"Pending"* resources array SHOULD be limited to 128 slots to prevent spam and griefing.

### Resource management

Several functions for resource management are included. In addition to permissioned migration from "Pending" to "Active", the owner of a token MAY also drop resources from both the active and the pending array -- an emergency function to clear all entries from the pending array MUST also be included.

## Backwards Compatibility

The MultiResource token standard has been made compatible with [EIP-721](./eip-721.md) in order to take advantage of the robust tooling available for implementations of EIP-721 and to ensure compatibility with existing EIP-721 infrastructure.

## Test Cases

Tests are included in [`multiresource.ts`](../assets/eip-5773/test/multiresource.ts).

To run them in terminal, you can use the following commands:

```
cd ../assets/eip-5773
npm install
npx hardhat test
```

## Reference Implementation

See [`MultiResourceToken.sol`](../assets/eip-5773/contracts/MultiResourceToken.sol).

## Security Considerations

The same security considerations as with [EIP-721](./eip-721.md) apply: hidden logic may be present in any of the functions, including burn, add resource, accept resource, and more.

Caution is advised when dealing with non-audited contracts.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
