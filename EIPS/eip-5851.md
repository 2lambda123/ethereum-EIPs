---
eip: 5851
title: Zero-Knowledge KYC Certificates
description: Interface for assigning/validating identities using Zero Knowledge Proofs
author: Yu Liu (@yuliu-debond), Dhruv Malik (@dhruvmalik007), Junyi Zhong (@Jooeys)
discussions-to: https://ethereum-magicians.org/t/eip-5815-kyc-certification-issuer-and-verifier-standard/11513
status: Draft
type: Standards Track
category: ERC
created: 2022-10-18
requires: 721, 1155, 1167, 1967, 3643, 5114
---
## Abstract

This EIP standardizes an interface for KYC verification of entities using verifiable credentials with abstract on-chain conditions. This interface allows identity orchestrators to assign identity certificates (such as SBT tokens for Verifiable Credentials) to wallets. These certificates can then be verified by ZK schemes.

## Motivation

On-chain verification is increasingly important across web3 based DeFI protocols. Currently some of them implement this by having an allowlist of approved users (or a denylist of unapproved users) without sacrificing their anonymity (like stablecoin providers checking for blacklisted entities for the destination address, limited utility tokens for a DAO community, etc). Finally, existing proposals require a trusted entity to manage this list, thus creating single point of failure.

Also, existing standards for transferring regulated tokens within denylisted entities like [EIP-3643](./eip-3643.md) are insufficient to handle complex use cases where:

- The validation logic needs to be more complex than verification of the user identity wrt the blacklisted address that is defined off-chain, and is very gas inefficient due to excessive cross contract calls with the KYC contract for transaction validation.

- Privacy-enhanced/anonymous verification is an important need by crypto users in order to insure censorship-resistant and trustless networks. ZK (zero-knowledge) verification schemes are currently the only way to validate the assertion of the identity by the user while keeping aspects of the provider's identity completely private.

Thus we resolve the challenges not being addressed by other standards by defining the optimal functional interfaces that defines the identity issuer to validate the web2 based KYC onchain, along with immutability as shown by SBT throughout the whole lifecycle.

## Specification

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Definitions

- ZK: Zero-knowledge. Refers to a cryptographic system in which a characteristic of an entity can be proven without revealing which entity the proof refers to.

- SBT: Soulbound tokens, these are non-fungible and non transferrable tokens that is used for defining the identity of the users. they are defined by standard [eip-5192](./eip-5192.md).

- SBT Certificates: SBT that represent the ownerships of ID signatures corresponding to the requirements defined in `function standardRequirement()`.

- KYC standard: Know your customer standard are the set of minimum viable conditions that financial services providers (banks, investment providers and other intermediate financial intermediaries) have to satisfy in order to access the services. this in web3 consideration concerns not about the details about the user itself, but about its status (onchain usage, total balance by the anon wallet, etc) that can be used for whitelisting.

- ZK-ID NFT: NFT representing the self-sovereign federated identity for providing ZK based decentralized identity from trusted public certificates (e.g national identity cards, passport and eSIM).

- W3C DID specification: Its the specification defined by world-wide-web org in order to assign the identifier and the verification condition without determining the person/ organization Private identification information.

- Verifiable credentials (VC): these are temper evident credentials that allow the holders to prove that they posses certain characteristics (for example passport verification, constraints like value of tokens in your wallet, etc) as demanded by the verifier entity. here the holder doesnt have to share the encrypted credentials with verifier, but some strings (called as proof details) that verifier can understand and evaluate to verify the credentials of given wallet holding this details. its stored as a JSON with object details defining title of verifiable credential, credential values,  proof representation etc.

#### Diagram

![diagram](../assets/eip-5851/architecture-diagram-5851.png)

Here we show the example real-life implementation scenario of how the identity issuer contract following this standard can be used to access a particular DeFI protocol that includes a modifier to check the possession of the given certificate.

1. Firstly the administrator will be defining the standard requirement of the SBT certificate, based on the conditions defined by the given exchange.

2. On the side of protocol/aggregator protocol once the requirements for the given certificate id are defined, then the exchange defines the modifier conditions by importing the function `IERC5851(_KYCaddress).isVerified(address, SBTID)` before calling the specific functions.

3. Then administrator assigns the SBT to the given address wallet. for verifying the identity of the given user is compliant with the correct compliance requirements, they can use ZK schemes (as simple as checking the Merkle root of the commitments, or via the circuits on ZK rollup, etc)

4. Thus now the user can access the various DeFI services where the SBT with the given ID is accepted.

5. And eventually whenever needed, the admin can revoke the access to the given certificate identified by SBTID, and then emit an event that SHOULD be captured by the wallet application of the user to notify the status of the certificate.

### Functions

```solidity
pragma solidity ^0.8.0;

interface IERC5851 {
    // getter functions
 
    /// @notice function to validate if the address `verifying` is the holder of the SBT defined by the tokenId `SBTID`
    /// @dev it MUST be defining the logic corresponding to all the current possible requirements needed by the verifier(check out more details in the Metadata section).
    /// @param verifying is the EOA/smart contract wallet address that wants to validate the SBT issued to it by the KYC. 
    /// @param SBTID is the Id of the SBT the user is the claimer.
    /// @return true if the assertion is valid, else false
    /**
    example isVerified(0xfoo, 1) --> true will mean that 0xfoo is the holder of the SBT identity token defined by tokenId '1' of the given ERC5851 contract. 
    */

    function isVerified(address verifying, uint256 SBTID) external view returns (bool);

    /// @notice getter function to fetch the onchain identification logic for the given identity holder.
    /// @dev it MUST not be defined for address(0). 
    /// @param SBTID is the Id of the SBT that the user is the claimer.
    /// @return the struct array of all the descriptions of condition metadata that is defined by the administrator for the given KYC provider.
    /**
    ex: standardRequirement(1) --> {
    { "title":"DepositRequirement",
        "type": "number",
        "description": "defines the minimum deposit in USDC for the investor along with the credit score",
        },
       "logic": "and",
    "values":{"30000", "5"}
}
This defines the condition encoded for the identity index 1, defining the identity condition that the holder must have 30000 USDC along with a credit score of at least 5.*/

    function standardRequirement(uint256 SBTID) external view returns (Requirement[] memory);
   
// setter functions

    /// @notice function for setting the requirement logic (defined by Requirements metadata) details for the given identity token defined by SBTID.
    /// @dev it should only be called by the admin address.
    /// @param SBTID is the Id of the SBT-based identity certificate for which the admin wants to define the Requirements.
    /// @param `requirements` is the struct array of all the descriptions of condition metadata that is defined by the administrator. check metadata section for more information.
/**
example: changeStandardRequirement(1, { "title":"DepositRequirement",
    "type": "number",
    "description": "defines the minimum deposit in USDC for the investor along with the credit score",
    },
    "logic": "and",
    "values":{"30000", "5"}
}); 
will correspond to the functionality that admin needs to adjust the standard requirement for the identification SBT with tokenId = 1, based on the conditions described in the Requirements array struct details.
**/
    function changeStandardRequirement(uint256 SBTID, Requirement[] memory requirements) external returns (bool);

    /// @notice function which uses the ZKProof protocol to validate the identity based on the given 
    /// @dev it should only be called by the admin address.
    /// @param SBTID is the Id of the SBT-based identity certificate for which admin wants to define the Requirements.
    /// @param certifying is the address that needs to be proven as the owner of the SBT defined by the tokenID.
    /**
example: certify(0xA....., 10) means that admin assigns the DID badge with id 10 to the address defined by the `0xA....` wallet.
    */
    function certify(address certifying, uint256 SBTID) external returns (bool);


    /// @notice function which uses the ZKProof protocol to validate the identity based on the given 
    /// @dev it should only be called by the admin address.
    /// @param SBTID is the Id of the SBT-based identity certificate for which the admin wants to define the Requirements.
    /// @param certifying is the address that needs to be proven as the owner of the SBT defined by the tokenID.
    // eg: revoke(0xfoo,1): means that KYC admin revokes the SBT certificate number 1 for the address '0xfoo'.

    function revoke(address certifying, uint256 SBTID) external returns (bool);


// Events
    /** 
    * standardChanged
    * @notice standardChanged MUST be triggered when requirements are changed by the admin. 
    * @dev standardChanged MUST also be triggered for the creation of a new SBTID.
    e.g : emit StandardChanged(1, Requirement(Metadata('depositRequirement','number', 'defines the max deposited that user can have in the denomination of USDC' ), "<=", "30000");
    is emitted when  the Requirement condition is changed  which allows the certificate holder to call the functions with the modifier, only after the deposit in the address is not greater than 30000 USDC.
    */
    event StandardChanged(uint256 SBTID, Requirement[] _requirement);
    
    /** 
    * certified
    * @notice certified MUST be triggered when the SBT certificate is given to the certifying address. 
    * eg: Certified(0xfoo,2); means that wallet holder address 0xfoo is certified to hold a certificate issued with id 2, and thus can satisfy all the conditions defined by the required interface.
    */
    event Certified(address certifying, uint256 SBTID);
    
    /** 
    * revoked
    * @notice revoked MUST be triggered when the SBT certificate is revoked. 
    * eg: Revoked( 0xfoo,1); means that entity user 0xfoo has been revoked to all the function access defined by the SBT ID 1.
    */
    event Revoked(address certifying, uint256 SBTID);
}



}


### Metadata structure

The structure of on-chain metadata storage follows a similar pattern as that of [EIP-3475](./eip-3475.md) and is described as the following type:

```solidity
    /**
    * @dev metadata that describes the Values structure on the given requirement. 
    * @notice it can be further optimized by using efficient encoding schemes (like TLV etc) and there can be a tradeoff in the gas costs of storing large strings vs encoding/decoding costs while describing the standard.
     */
    struct Metadata {
        string title;
        string _type;
        string description;
    }
    /**
     * @dev Values here can be read and written by smart contract and front-end, cited from [EIP-3475].
     */
    struct Values { 
        string stringValue;
        uint uintValue;
        address addressValue;
        bool boolValue;
        bytes bytesValue;
    }
```

```suggestion
#### Requirement structure:
This will be stored in each of the SBT certificates that will define the conditions that need to be satisfied by the owner of the certificate when any verifier (of the DeFI protocol functions) calling the `isVerified()` function, to be validated to run the function, this will be defined for each onchain `Values` separately.
```

```solidity
    /**
     * @dev structure that Defines the parameters for specific requirements of the SBT certificate
     * @notice this structure is used for the verification process, it contains the metadata, logic, and expectation
     * @logic given here MUST be one of ("⊄", "⊂", "<", "<=", "==", "!=", ">=",">")
     */
    
struct Requirement {
        Metadata metadata;
        string logic;
        Values expectation;
    }

```

#### Example

Considering an example verifiable credential :

```JSON
[
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "type": ["KYCVerification"],
  "credentialSchema": {
    "id": "did:Debond:cdf:....",
    "type": "did:debond:schema:...."
  },
  "issuer": "did:Debond:Wz4eUg7SetGfaUVCn8U9d62oDYrUJLuUtcy619",
  "credentialSubject": {
    "age": "18",
    "jurisdiction": "CH",
  },
  "proof": {
    "type": "CLSignature2019",
    "issuerData": "5NQ4TgzNfSQxoLzf2d5AV3JNiCdMaTgm...BXiX5UggB381QU7ZCgqWivUmy4D",
    "signature": "8eGWSiTiWtEA8WnBwX4T259STpxpRKuk...kpFnikqqSP3GMW7mVxC4chxFhVs",
    "signatureCorrectnessProof": "SNQbW3u1QV5q89qhxA1xyVqFa6jCrKwv...dsRypyuGGK3RhhBUvH1tPEL8orH"
  }
}
]
```

the corresponding information will be stored as SBT by the holder with following details:

1. Metadata Information:

```json
[
{
   "title":"context",
   "_type": "string[]",
   "description":"stores the URL's where the standard is stored"
},

{
   "title":"Type",
   "_type": "string[]",
   "description":"Stores the type of verification that SBT supports"
},

{
   "title":"issuer",
   "_type": "string",
   "description":"DID version of the format represented as the DID format"
},
{
   "title":"credentialSubject",
   "_type": "string[]",
   "description":"stores the URL's where the standard is stored"
},

{
   "title":"proof",
   "_type": "string[]",
   "description":"Object that stores the metadata about the proof attributes (type, attributes, signature, conditioal description ....)"
},
]
```

2.Values  will be stored as follows:

```solidity

string[]  contextDetails = [Values.stringValues("https://www.w3.org/2018/credentials/v1"),Values.stringValues("https://www.w3.org/2018/")];

```

## Rationale

### Metadata generation

In order to represent any identity based on W3C DID documentation(context,id,authentication) and then combine them, we followed the metadata definition similar to that defined in [EIP-3475](./eip-3475.md) ,so as for smart contracts to have better details.


## Backwards Compatibility

- This EIP is backward compliant for the contracts that keep intact the metadata structure of previous issued SBT's with their ID and requirement details.
  - For e.g if the DeFI provider (using the modifiers to validate the ownership of required SBT by owner) wants the admin to change the logic of verification or remove certain requirement structure, the previous holders of the certificates that are affected by this changes.

## Test Cases

Test cases for the minimal reference implementation can be found [here](../assets/eip-5851/contracts/test.sol) for using transaction verification regarding whether the users hold the tokens or not. Use Remix IDE to compile and test the contracts.

## Reference Implementation

The interface standard is divided into two separate implementations:

- [verifier_modifier](../assets/eip-5851/contracts/verification_modifier.sol) is a simple modifier that needs to be imported by functions that are to be only called by holders of the SBT certificates. This is a wrapper contract of this EIP's `verify()` method and can be implemented for arbitrary types of contract.

- [SBT_certification](../assets/eip-5851/contracts/SBT_certification.sol) is an example of an identity certificate that can be assigned by a KYC controller contract. This is a full implementation of the standard interface.

There is also an [example script](../assets/eip-5851/script/createProof.js) that allows the creation of Merkle root off-chain (or all the hashes of the given user details) and thereafter stored on the ERC-5851 contract so that `function verify(address owner, uint SBTID)` compares the regenerated Merkle root from user inputs to be similar to this one.

## Security Considerations

1. Implementation of functional interfaces for creating KYC on SBT (i.e `changeStandardRequirement()`, `certify()` and `revoke()`) are dependent on the admin role.thus the developer must insure security of admin role and rotation of this role to the entity entrusted by the KYC attestation service provider and DeFI protocols that are using this attestation service.

2. The modifiers SHOULD not be deployed for the verifier contract that is upgradable (either via proxy patterns defined by [eip-1167](./eip-1167.md), [eip-1967](./eip-1967.md)). if the requirement is deemed important, there need to be appropriate roles(usually by the admin) to insure that secured interface.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).