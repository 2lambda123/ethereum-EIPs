---
eip: 5851
title: Issuance of onchain verifiable claims as SBT.
description: Interface for contracts that manage lifecycle of verifiable claims and identifiers as Soulbound tokens.
author: Yu Liu (@yuliu-debond), Dhruv Malik (@dhruvmalik007), Junyi Zhong (@Jooeys)
discussions-to: https://ethereum-magicians.org/t/eip-5815-kyc-certification-issuer-and-verifier-standard/11513
status: Draft
type: Standards Track
category: ERC
created: 2022-10-18
requires: 721, 1155, 1167, 1967, 3643, 5114
---
## Abstract

This EIP defines the interface for building smart contracts that issues the Verifiable claims to wallets (as soulbound token), and how third party verifiers/ system integrators can parse these details for whitelisting services with more granular controls.  

### Definitions

- ZK: Zero-knowledge. Refers to a cryptographic system in which a characteristic of an entity can be proven without revealing which entity the proof refers to.

- SBT: Soulbound tokens, these are non-fungible and non transferrable tokens that is used for defining the identity of the users. they are defined by standard [eip-5192](./eip-5192.md).

- SBT Certificates: SBT that represent the ownerships of ID signatures corresponding to the requirements defined in `function standardRequirement()`.

- KYC standard: Know your customer standards are the set of minimum viable conditions that financial services providers (banks, investment providers and other intermediate financial intermediaries) have to satisfy in order to access the services. In web3, this is not about the details about the user itself, but about its status (onchain usage, total balance by the anon wallet, etc) that can be used for whitelisting.

- ZK-ID NFT: NFT representing the self-sovereign federated identity for providing ZK based decentralized identity from trusted public certificates (e.g national identity cards, passport and eSIM).

- W3C DID specification: Its the specification defined by world-wide-web org in order to assign the identifier and the verification condition without to any entity which is owner to the given wallet (eg: person/ organization Private identification information). its defined as a JSON document with the DID string, schema details, etc.

- Verifiable credentials (VC): these are temper evident credentials that allow the holders to prove that they posses certain characteristics (for example passport verification, constraints like value of tokens in your wallet, etc) as demanded by the verifier entity. it consist of primarily three details: 
  - DID specification details
  - Details about the claims
  - The proof details(that provides the cryptographic material that verifier will use to verify the claims).

## Motivation

On-chain issuance of verifiable claims for unique identities are essential for use-case like:
    - Avoiding sybil attacks with one person one vote.
    - Participation in certain events as credentials.
    - Compliance to the government financial regulations etc.

Currently W3C specifications define the format of DID components (like URI, document details) along with claims that given identity provides for the user (verifier credentials), the counterparts that operate or store the data (ie controller, Issuer, wallet and Verifiable Data Registry) and the methods by which the DID and associated document lifecycle operations (issuance, resolution by the given data registry, revocation). We want to define the smart contract interface functions that allow onchain issuance of DID inside Verifiable Credentials by third parties. 

Also current standards for verifying onchain credential verifications for specific usecases like security tokens ([EIP-3643](./eip-3643.md)) are not interoperable with W3C standard and also not optimized in terms of gas operations.

Also given that current wallet infrastructure are compliant with rendering the NFT's along with their corresponding metadata, thus we defined the interfaces that allow issuance of the verifiable claims as a SBT.

- Also given the increased adoption of ZK verification schemes for credential claims onchain, we wanted to define the standard which allows third party entity to verify the claims of user by reading the details from documents, which define the proving string, public parameters and cryptography schemes use for the issuance of the claims, without ever  leaking information about personal identifiable details.

## Specification

The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Entities

1. Controller: Is the entity that has "capability to make changes in the document". this role Should be only allowed with the issuer (or the third party custodian contracts).

2. Holder: this corresponds to the wallet that is issued the  unique verifier credential by the issuer. they can now present this SBT to the verifiers in order to validate  their KYC to access the services 

3. Verifier: this corresponds to the contract that verifies the proof details present in the SBT of the holder, and then based on the credential scheme, will either refer to the registry in order to verify the claims, or will return the status to the holder defining whether their KYC is verified or not. this part will be implemented by the side of services that want to verify the users (DeFI protocols, DAO member access,etc).

4. Registry: This is the decentralized storage that keeps the current status of the verifiable credentials corresponding to the each credential issued to the holder (as an SBT). the value corresponding to the credentials will be referred by the URI stored in the SBT.only the issuer (or controller in terms of DID issuance) will be able to update the current status of the credentials by generating new Verifiable credential details. 
 

### Metadata Standard

We will be storing the following structures to store the credentials: 

### 1. DID document

We will store the details regarding the DID:

```solidity

    /**
    * @dev This structure stores the details regarding the identifiers provided by issuer. 
    * @notice  the referenceURI can be either defined with the onchain tradeoff in the gas costs of storing large strings vs encoding/decoding costs while describing the standard.
    * @param methodName stores the strong consisting of did:'companyName':'referenceHash'.
    * @param referenceURI this will point to the registry where additional information (like issuanceDate, reference about the issuer of the DID,etc).
    * @param referenceHash this stores the hash of the data stored in the verifiable registry, for insuring identity uniqueness.
     */
    struct issuer {
        string methodName; 
        string referenceURI; 
        bytes32 referenceDataHash // this stores the hash of the data stored in the verifiable registry, in order to insure the uniqueness of data.
    }
```

### 2. Credential structure

This will store the content about the claims that user wants to convey (ie age > 18, jurisdiction not from the blacklisted countries, etc). these will be stored as the combination of one or many requirement structure detail attributes as defined below: 

```solidity

    // Values represent the various attributes that users can define in the requirements structure onchain:

    
    /**
    Requirements structure consist of the conditions and value that holder claims to associate and verifier has to validate the claim.
    @notice the below given parameters are for reference purposes only, developers can optimise the fields that are needed to be represented onchain, and transferring the rest into the referenceURI JSON blob.
    @param title: it defines the credential identifier
    @param description: this defines the condition string that the holder has to abide following the rules as defined by condition values.
    @param conditions: this defines single/multiple values  of constraints that user credentials have to satisfy based on logic symbol.
    @param logicSymbol is the hexadecimal representation of the logic condition that the credential has to satisfy on the 
    
    */

    struct Requirements {
    string title;
    string description;
    bytes32[] logicCondition;
    string referenceURI;   
    }

    /**
    * @dev structure that defines each credential information along with the constraints.
    * @param credentialDetails consist of the workflow concerning the credential
    * @param string proofDetailsURI is the reference URI in the registry that stores the details of onchain proofs and also the signature scheme used for generating that proof.
    * @param proofDetailsHash is the details regarding the proof details that are stored on registry.
    */
    struct credentialSubject {
    string[] type;
    Requirements[]  credentialDetails;    
    string proofDetailsURI; 
    bytes32 proofDetailsHash;
    }

     /**
     * @dev structure that Defines the final credential details that are to be presented by the bond issuer to the given holder.
     * @notice this structure is used for the verification process, it contains the metadata, logic, and expectation
     * @logic given here MUST be one of ("⊄", "⊂", "<", "<=", "==", "!=", ">=",">")
     */
    
struct verifiableCredentials {
        string[] context;
        DID idDetails;
        credentialSubject  credentials;  
    }
```

### Example

Considering an example verifiable credential with nonTransferrable(SBT) based on W3C credential standard:

```JSON
[
{
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["VerifiableCredential", "ProofOfAgeCredential"],
  "issuer": "https://example.edu/issuers/14",
  "issuanceDate": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "ageOver": 21
    },
  "nonTransferable": true,
  "proof": { ..
  "verificationMethod": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  ... }
}

]
```

the corresponding information will be stored as SBT by the holder with following details:

1. Metadata Information:

```solidity

IERC5851.issuer didDetails =  IERC5851.issuer("did:example:ebfeb1f712ebc6f1c276e12ec21", "https://example.edu/issuers/14", "Aqoweiuqewiwueo32....");


// defining the condition of the age being greater than 21 yrs
// here the bytes storage will be bytes version of the  hexadecimal string "age>21"
IERC5851.Requirement condition = IERC5851.Requirement("Age verification","age should be greater than value provided by verifier",'0x...6167653E3231', 'ipfs://QWiouiuoiu....');



IERC5851.credentialSubject credentials =  IERC5851.credentialSubject(["AgeVerification"], condition, 'ipfs://QWiouiuoiu....', 'Aseioasid......');


// finally the details about verifiable credentials.

/**
struct verifiableCredentials {
        string[] context;
        DID idDetails;
        credentialSubject  credentials;  
    }
*/



IERC5851.verifiableCredentials credential = IERC5851.verifiableCredentials(["https://w3c.github.io/example/...."], didIssuer, credentials );
```

### Interface specification


1. for the  issuer of the contract:

```solidity
pragma solidity ^0.8.0;

interface IERC5851Issuer {
    // getter functions

    /// @notice getter function to fetch the onchain identification logic for the given identity holder.
    /// @dev it MUST not be defined for address(0). 
    /// @param SBTID is the Id of the SBT that the user is the claimer.
    /// @return the struct array of all the descriptions of condition metadata that is defined by the administrator for the given KYC provider.
    /**
    ex: standardRequirement(1) --> {
    { "title":"DepositRequirement",
        "type": "number",
        "description": "defines the minimum deposit in USDC for the investor along with the credit score",
        },
       "logic": "and",
    "values":{"30000", "5"}
}
This defines the condition encoded for the identity index 1, defining the identity condition that the holder must have 30000 USDC along with a credit score of at least 5.*/

    function standardRequirement(uint256 SBTID) external view returns (Requirement[] memory);
   
// setter functions

    /// @notice function for setting the requirement logic (defined by Requirements metadata) details for the given identity token defined by SBTID.
    /// @dev it should only be called by the admin address.
    /// @param SBTID is the Id of the SBT-based identity certificate for which the admin wants to define the Requirements.
    /// @param `requirements` is the struct array of all the descriptions of condition metadata that is defined by the administrator. check metadata section for more information.
/**
example: changeStandardRequirement(1, { "title":"DepositRequirement",
    "type": "number",
    "description": "defines the minimum deposit in USDC for the investor along with the credit score",
    },
    "logic": "and",
    "values":{"30000", "5"}
}); 
will correspond to the functionality that admin needs to adjust the standard requirement for the identification SBT with tokenId = 1, based on the conditions described in the Requirements array struct details.
**/
    function changeStandardRequirement(uint256 SBTID, Requirement[] memory requirements) external returns (bool);

    /// @notice function which uses the ZKProof protocol to validate the identity based on the given 
    /// @dev it should only be called by the admin address.
    /// @param SBTID is the Id of the SBT-based identity certificate for which admin wants to define the Requirements.
    /// @param certifying is the address that needs to be proven as the owner of the SBT defined by the tokenID.
    /**
example: certify(0xA....., 10) means that admin assigns the DID badge with id 10 to the address defined by the `0xA....` wallet.
    */
    function certify(address certifying, uint256 SBTID) external returns (bool);


    /// @notice function which uses the ZKProof protocol to validate the identity based on the given 
    /// @dev it should only be called by the admin address.
    /// @param SBTID is the Id of the SBT-based identity certificate for which the admin wants to define the Requirements.
    /// @param certifying is the address that needs to be proven as the owner of the SBT defined by the tokenID.
    // eg: revoke(0xfoo,1): means that KYC admin revokes the SBT certificate number 1 for the address '0xfoo'.

    function revoke(address certifying, uint256 SBTID) external returns (bool);


// Events
    /** 
    * standardChanged
    * @notice standardChanged MUST be triggered when requirements are changed by the admin. 
    * @dev standardChanged MUST also be triggered for the creation of a new SBTID.
    e.g : emit StandardChanged(1, Requirement(Metadata('depositRequirement','number', 'defines the max deposited that user can have in the denomination of USDC' ), "<=", "30000");
    is emitted when the Requirement condition is changed which allows the certificate holder to call the functions with the modifier, only after the deposit in the address is not greater than 30000 USDC.
    */
    event StandardChanged(uint256 SBTID, Requirement[] _requirement);
    
    /** 
    * certified
    * @notice certified MUST be triggered when the SBT certificate is given to the certifying address. 
    * eg: Certified(0xfoo,2); means that wallet holder address 0xfoo is certified to hold a certificate issued with id 2, and thus can satisfy all the conditions defined by the required interface.
    */
    event Certified(address certifying, uint256 SBTID);
    
    /** 
    * revoked
    * @notice revoked MUST be triggered when the SBT certificate is revoked. 
    * eg: Revoked( 0xfoo,1); means that entity user 0xfoo has been revoked to all the function access defined by the SBT ID 1.
    */
    event Revoked(address certifying, uint256 SBTID);
}
```

### Workflow diagram

![diagram](../assets/eip-5851/architecture-diagram-5851.png)

## Rationale

### Metadata generation

In order to represent any identity based on W3C DID documentation(context,id,authentication) and then combine them, we followed the metadata definition similar to that defined in [EIP-3475](./eip-3475.md) ,so as for smart contracts to have better details.

## Backwards Compatibility

- This EIP is backward compliant for the contracts that keep intact the metadata structure of previous issued SBT's with their ID and requirement details.
  - For e.g if the DeFI provider (using the modifiers to validate the ownership of required SBT by owner) wants the admin to change the logic of verification or remove certain requirement structure, the previous holders of the certificates that are affected by this changes.

## Test Cases

Test cases for the minimal reference implementation can be found [here](../assets/eip-5851/contracts/test.sol) for using transaction verification regarding whether the users hold the tokens or not. Use Remix IDE to compile and test the contracts.

## Reference Implementation

The interface standard is divided into two separate implementations:

- [verifier_modifier](../assets/eip-5851/contracts/verification_modifier.sol) is a simple modifier that needs to be imported by functions that are to be only called by holders of the SBT certificates. This is a wrapper contract of this EIP's `verify()` method and can be implemented for arbitrary types of contract.

- [SBT_certification](../assets/eip-5851/contracts/SBT_certification.sol) is an example of an identity certificate that can be assigned by a KYC controller contract. This is a full implementation of the standard interface.

There is also an [example script](../assets/eip-5851/script/createProof.js) that allows the creation of Merkle root off-chain (or all the hashes of the given user VC) and thereafter stored on this EIP contract so that `function verify(address owner, uint SBTID)` compares the re-generated Merkle root from user inputs 

## Security Considerations

1. Implementation of functional interfaces for creating KYC on SBT (i.e `changeStandardRequirement()`, `certify()` and `revoke()`) are dependent on the admin role. Thus the developer must insure security of admin role and rotation of this role to the entity entrusted by the KYC attestation service provider and DeFI protocols that are using this attestation service.

2. The modifiers SHOULD not be deployed for the verifier contract that is upgradable (either via proxy patterns defined by [eip-1167](./eip-1167.md), [eip-1967](./eip-1967.md). If the requirement is deemed important, there need to be appropriate roles(usually by the admin) to insure that secured interface.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).