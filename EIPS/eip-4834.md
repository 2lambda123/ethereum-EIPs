---
eip: 4834
title: Hierarchical Domains Standard
description: The Hierarchal Domains Standard is a standard for extremely generic name resolution.
author: Pandapip1 (@Pandapip1)
discussions-to: https://ethereum-magicians.org/t/erc-4834-hierarchical-domains-standard/8388
status: Draft
type: Standards Track
category: ERC
created: 2022-02-22
requires: 165
---

## Abstract
`ERC-4834` is a standard for generic name resolution with access control. It permits contracts that implement `ERC-4834` ("domains") to be addressable with a more human-friendly name, similar to `ERC-137`.

Unlike `ERC-137`, any program that resolves domains should treat domains as equivalent to their resolved addresses. In practice, this means that instead of having to specify a contract address that looks like `0x6b175474e89094c44da98b954eedeac495271d0f`, it might be possible to put (this is a completely made-up address) `dai.token` and have it automatically resolve to the right address. This is different from `ERC-137`, where addresses are resolved by ENS to a "resolver," which then gets resolved to the correct address. 

Another notable divergence from `ERC-137` is that access control can be extremely complex. `ERC-137` domains have a defined owner, whereas any access control patterns can be implemented for an `ERC-4834` domain. This allows for many more use-cases, such as a token that coukd be redeemed for domains.

## Motivation
The motivation behind this ERC is that existing standards like ERC-137 are relatively complex and have limitations. The advantage of ERC-4834 is that it provides a minimal interface that supports name resolution. This permits use-cases such as referencing an ERC-20 or ERC-1155 token by a name directly, without using a "resolver."

This ERC also implements flexible access control. This allows for clever implementations, such as having a token that can be redeemed for subdomains of the token, and domains that are themselves NFTs that grant the ability to manage the domain to the owner of said NFT. There can also be multiple managers of a single domain with different access, instead of a single "owner."

In addition, TLDs (like .com), subdomains, and even the "root" itself (analogous to the ENS registry) are all implemented as ERC-4834 smart contracts, meaning that name-resolution is a relatively simple iterative algorithm, and there is no limit to the amount of nesting that is possible (e.g. 0.1.2.3.4.5.6.7.8.9.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z could be valid if the root contains z, and z contains y, and etc).

## Specification

### Contract Interface

Solidity Interface with NatSpec & OpenZeppelin v4 Interfaces (also available at [IDomain.sol](../assets/eip-4834/IDomain.sol)):

```sol
interface IDomain is IERC165 {
    //// Events
    
    /// @notice     Emitted when createDomain is called
    /// @param      sender msg.sender for createDomain
    /// @param      name name for createDomain
    /// @param      subdomain subdomain in createDomain
    event SubdomainCreate(address indexed sender, string name, IDomain subdomain);

    /// @notice     Emitted when setDomain is called
    /// @param      sender msg.sender for setDomain
    /// @param      name name for setDomain
    /// @param      subdomain subdomain in setDomain
    /// @param      oldSubdomain the old subdomain
    event SubdomainUpdate(address indexed sender, string name, IDomain subdomain, IDomain oldSubdomain);

    /// @notice     Emitted when deleteDomain is called
    /// @param      sender msg.sender for deleteDomain
    /// @param      name name for deleteDomain
    /// @param      subdomain the old subdomain
    event SubdomainDelete(address indexed sender, string name, IDomain subdomain);


    //// CRUD

    /// @notice     Query if a domain has a subdomain with a given name
    /// @param      name The subdomain to query
    /// @return     `true` if the domain has a subdomain with the given name, `false` otherwise
    function hasDomain(string memory name) external view returns (bool);

    /// @notice     Fetch the subdomain with a given name
    /// @dev        This should revert is `hasDomain(name)` is `false`
    /// @param      name The subdomain to fetch
    /// @return     The subdomain with the given name
    function getDomain(string memory name) external view returns (IDomain);

    /// @notice     Create a subdomain with a given name
    /// @dev        This should revert if `canCreateDomain(msg.sender, name, pointer)` is `false` or if the domain exists
    /// @param      name The subdomain name to be created
    /// @param      subdomain The subdomain to create
    function createDomain(string memory name, IDomain subdomain) external;

    /// @notice     Update a subdomain with a given name
    /// @dev        This should revert if `canSetDomain(msg.sender, name, pointer)` is `false` of if the domain doesn't exist
    /// @param      name The subdomain name to be updated
    /// @param      subdomain The subdomain to set
    function setDomain(string memory name, IDomain subdomain) external;

    /// @notice     Delete the subdomain with a given name
    /// @dev        This should revert if the domain doesn't exist or if
    ///             `canDeleteDomain(msg.sender, name, this)` is `false`
    /// @param      name The subdomain to delete
    function deleteDomain(string memory name) external;


    //// Parent Domain Access Control

    /// @notice     Get if an account can create a subdomain with a given name
    /// @dev        It is highly suggested to return `false` if `hasDomain(name)` is `true`
    ///             and `getDomain(name).canUpdateSubdomain(msg.sender, this, subdomain)` is `false`,
    ///             or if `subdomain.canPointSubdomain(msg.sender, name, this) is `false`
    /// @param      updater The account that may or may not be able to create/update a subdomain
    /// @param      name The subdomain name that would be created/updated
    /// @param      subdomain The subdomain that would be set
    /// @return     Whether an account can update or create the subdomain
    function canCreateDomain(address updater, string memory name, IDomain subdomain) external view returns (bool);

    /// @notice     Get if an account can update or create a subdomain with a given name
    /// @dev        It is highly suggested to return `false` if `hasDomain(name)` is `true`
    ///             and `getDomain(name).canUpdateSubdomain(msg.sender, this, subdomain)` is `false`,
    ///             or if `subdomain.canPointSubdomain(msg.sender, name, this) is `false`
    /// @param      updater The account that may or may not be able to create/update a subdomain
    /// @param      name The subdomain name that would be created/updated
    /// @param      subdomain The subdomain that would be set
    /// @return     Whether an account can update or create the subdomain
    function canSetDomain(address updater, string memory name, IDomain subdomain) external view returns (bool);

    /// @notice     Get if an account can delete the subdomain with a given name
    /// @dev        It is highly suggested to return `false` if `hasDomain(name)` is `true` and
    ///             `getDomain(name).canDeleteSubdomain(msg.sender, name, this)` is `false`
    /// @param      updater The account that may or may not be able to delete a subdomain
    /// @param      name The subdomain to delete
    /// @return     Whether an account can delete the subdomain
    function canDeleteDomain(address updater, string memory name) external view returns (bool);


    //// Subdomain Access Control

    /// @notice     Get if an account can point this domain as a subdomain
    /// @dev        May be called by `canSetDomain` of the parent domain - implement access control here!!!
    /// @param      updater The account that may be moving the subdomain
    /// @param      name The subdomain name
    /// @param      parent The parent domain
    /// @return     Whether an account can update the subdomain
    function canPointSubdomain(address updater, string memory name, IDomain parent) external view returns (bool);

    /// @notice     Get if an account can move the subdomain away from the current domain
    /// @dev        May be called by `canSetDomain` of the parent domain - implement access control here!!!
    /// @param      updater The account that may be moving the subdomain
    /// @param      name The subdomain name
    /// @param      parent The parent domain
    /// @param      newSubdomain The domain that will be set next
    /// @return     Whether an account can update the subdomain
    function canMoveSubdomain(address updater, string memory name, IDomain parent, IDomain newSubdomain) external view returns (bool);

    /// @notice     Get if an account can point this domain as a subdomain
    /// @dev        May be called by `canDeleteDomain` of the parent domain - implement access control here!!!
    /// @param      updater The account that may or may not be able to delete a subdomain
    /// @param      name The subdomain to delete
    /// @param      parent The parent domain
    /// @return     Whether an account can delete the subdomain
    function canDeleteSubdomain(address updater, string memory name, IDomain parent) external view returns (bool);
}
```
### Name Resolution

To resolve a name (like `"a.b.c"`), you first split it by the delimiter (resulting in something like `["a", "b", "c"]`). Set `domain` initially to the root domain.

Pop off the last element of the array (`"c"`), then call `domain.hasDomain(lastElement)`. If it's `false`, then the domain resolution fails. Otherwise, set the domain to `domain.getDomain(lastElement)`. Repeat until there are no more lists.

Here is a solidity function that resolves a name:

```sol
function resolve(string[] calldata splitName, IDomain root) public view returns (IDomain) {
    IDomain current = root;
    for (uint i = splitName.length - 1; i >= 0; i--) {
        require(current.hasDomain(splitName[i]));
        current = current.getDomain(splitName[i]);
    }
    return current;
}
```

## Rationale
As previously mentioned in the abstract and motivation, the design of this ERC is different than that of ERC-137. ERC-137 has a strong tiering - the registrars update the ENS registry, which points to resolvers. In ERC-4834, every domain is effectively a registry, resolver, and registrar all in one. This is specifically designed to be a simple addressing system.

## Backwards Compatibility
There is no compatibility with ERC-137. While the two ERCs are somewhat similar, the rationale for each is different. It is likely impossible to create an ERC-4834 domain that wraps ERC-137.

## Reference Implementations

Some of these implementations use some contracts from OpenZeppelin (included in the contracts directory) for ease of implementation and understandability. 

Naive Domain Implementation: [NaiveDomain.sol](../assets/eip-4834/NaiveDomain.sol)
EIP-173 (Ownable) Domain Implementation: [OwnableDomain.sol](../assets/eip-4834/OwnableDomain.sol)
ERC-721 (NFT) Domain Implementation: [NFTDomain.sol](../assets/eip-4834/NFTDomain.sol)

## Security Considerations
- Moving a subdomain using `setDomain` is a dangerous operation. Depending on the parent domain's implementation, a malicious subdomain can always return `false` on `canMoveSubdomain`, effectively locking the domain (See [BlackHole.sol](../assets/eip-4834/BlackHole.sol)). Alternatively, it might return `true` when it isn't expected, allowing the contract owner to take over the domain. It is therefore important to always verify the subdomain contract source.
- More discussion needed.


## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
