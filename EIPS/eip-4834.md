---
eip: 4834
title: Hierarchical Domains Standard
description: The Hierarchal Domains Standard is a standard for extremely generic name resolution.
author: Pandapip1 (@Pandapip1)
discussions-to: https://ethereum-magicians.org/t/erc-4834-hierarchical-domains-standard/8388
status: Draft
type: Standards Track
category: ERC
created: 2022-02-22
requires: 165
---

## Abstract
`ERC-4834` is a standard for generic name resolution with access control. It permits contracts that implement `ERC-4834` ("domains") to be addressable with a more human-friendly name, similar to `ERC-137`.

Unlike `ERC-137`, any program that resolves domains should treat domains as equivalent to their resolved addresses. In practice, this means that instead of having to specify a contract address that looks like `0x6b175474e89094c44da98b954eedeac495271d0f`, it might be possible to put (this is a completely made-up address) `dai.token` and have it automatically resolve to the right address. This is different from `ERC-137`, where addresses are resolved by ENS to a "resolver," which then gets resolved to the correct address. 

Another notable divergence from `ERC-137` is that access control can be extremely complex. `ERC-137` domains have a defined owner, whereas any access control patterns can be implemented for an `ERC-4834` domain. This allows for many more use-cases, such as a token that could be redeemed for domains.

## Motivation
The motivation behind this ERC is that existing standards like ERC-137 are relatively complex and have limitations. The advantage of ERC-4834 is that it provides a minimal interface that supports name resolution. This permits use-cases such as referencing an ERC-20 or ERC-1155 token by a name directly, without using a "resolver" contract.

This ERC also implements flexible access control. This allows for clever implementations, such as having a token that can be redeemed for subdomains of the token, and domains that are themselves NFTs that grant the ability to manage the domain to the owner of said NFT. There can also be multiple managers of a single domain with different access, instead of a single owner. Of course, it's still possible to implement a single-owner domain, should that be desired.

In addition, TLDs (like .com), subdomains, and even the "root" itself (analogous to the ENS registry) are all implemented as ERC-4834 smart contracts, meaning that name-resolution is a relatively simple iterative algorithm, and there is no limit to the amount of nesting that is possible (e.g. 0.1.2.3.4.5.6.7.8.9.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z could be valid if the root contains z, and z contains y, and etc).

## Rationale
As previously mentioned in the abstract and motivation, the design of this ERC is different than that of ERC-137. ERC-137 has a strong tiering - the registrars update the ENS registry, which points to resolvers. In ERC-4834, every domain is effectively a registry, resolver, and registrar all in one. This is specifically designed to be a simple addressing system.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

### Contract Interface
Solidity Interface with NatSpec & OpenZeppelin v4 Interfaces (also available at [IDomain.sol](../assets/eip-4834/IDomain.sol)):

```sol
interface IDomain is IERC165 {
    //// Events
    
    /// @notice     Must be emitted when a new subdomain is created (eg. through `createDomain`.)
    /// @param      sender msg.sender for createDomain
    /// @param      name name for createDomain
    /// @param      subdomain subdomain in createDomain
    event SubdomainCreate(address indexed sender, string name, address subdomain);

    /// @notice     Must be emitted when the resolved address for a domain is changed (eg. with `setDomain`)
    /// @param      sender msg.sender for setDomain
    /// @param      name name for setDomain
    /// @param      subdomain subdomain in setDomain
    /// @param      oldSubdomain the old subdomain
    event SubdomainUpdate(address indexed sender, string name, address subdomain, address oldSubdomain);

    /// @notice     Must be emitted when a domain is unmapped (eg. with `deleteDomain`)
    /// @param      sender msg.sender for deleteDomain
    /// @param      name name for deleteDomain
    /// @param      subdomain the old subdomain
    event SubdomainDelete(address indexed sender, string name, address subdomain);


    //// CRUD

    /// @notice     Query if a domain has a subdomain with a given name
    /// @param      name The subdomain to query
    /// @return     `true` if the domain has a subdomain with the given name, `false` otherwise
    function hasDomain(string memory name) external view returns (bool);

    /// @notice     Fetch the subdomain with a given name
    /// @dev        This should revert if `hasDomain(name)` is `false`
    /// @param      name The subdomain to fetch
    /// @return     The subdomain with the given name
    function getDomain(string memory name) external view returns (address);

    /// @notice     Query all subdomains. Must revert if the list of domains is unknown or infinite.
    /// @return     The list of all subdomains.
    function listDomains() external view returns (string[]);

    /// @notice     Create a subdomain with a given name
    /// @dev        This should revert if `canCreateDomain(msg.sender, name, pointer)` is `false` or if the domain exists
    /// @param      name The subdomain name to be created
    /// @param      subdomain The subdomain to create
    function createDomain(string memory name, address subdomain) external;

    /// @notice     Update a subdomain with a given name
    /// @dev        This should revert if `canSetDomain(msg.sender, name, pointer)` is `false` of if the domain doesn't exist
    /// @param      name The subdomain name to be updated
    /// @param      subdomain The subdomain to set
    function setDomain(string memory name, address subdomain) external;

    /// @notice     Delete the subdomain with a given name
    /// @dev        This should revert if the domain doesn't exist or if
    ///             `canDeleteDomain(msg.sender, name, this)` is `false`
    /// @param      name The subdomain to delete
    function deleteDomain(string memory name) external;


    //// Parent Domain Access Control

    /// @notice     Get if an account can create a subdomain with a given name
    /// @dev        This must return `false` if `hasDomain(name)` is `true`.
    ///             If `subdomain` is a domain, this should return `false` if
    ///             `subdomain.canPointSubdomain(msg.sender, name, this) is `false`.
    /// @param      updater The account that may or may not be able to create/update a subdomain
    /// @param      name The subdomain name that would be created/updated
    /// @param      subdomain The subdomain that would be set
    /// @return     Whether an account can update or create the subdomain
    function canCreateDomain(address updater, string memory name, address subdomain) external view returns (bool);

    /// @notice     Get if an account can update or create a subdomain with a given name
    /// @dev        This must return `false` if `hasDomain(name)` is `false`.
    ///             If `subdomain` is a domain, this should return `false` if
    ///             `subdomain.canPointSubdomain(msg.sender, name, this) is `false`.
    ///             If `getDomain(name)` is also a domain, this should return `false` if
    ///             `getDomain(name).canMoveSubdomain(msg.sender, this, subdomain)` is `false`.
    /// @param      updater The account that may or may not be able to create/update a subdomain
    /// @param      name The subdomain name that would be created/updated
    /// @param      subdomain The subdomain that would be set
    /// @return     Whether an account can update or create the subdomain
    function canSetDomain(address updater, string memory name, address subdomain) external view returns (bool);

    /// @notice     Get if an account can delete the subdomain with a given name
    /// @dev        This must return `false` if `hasDomain(name)` is `false`.
    ///             If `getDomain(name)` is a domain, this should return `false` if
    ///             `getDomain(name).canDeleteSubdomain(msg.sender, this, subdomain)` is `false`.
    /// @param      updater The account that may or may not be able to delete a subdomain
    /// @param      name The subdomain to delete
    /// @return     Whether an account can delete the subdomain
    function canDeleteDomain(address updater, string memory name) external view returns (bool);


    //// Subdomain Access Control

    /// @notice     Get if an account can move the subdomain away from the current domain
    /// @dev        May be called by `canSetDomain` of the parent domain - implement access control here!!!
    /// @param      updater The account that may be moving the subdomain
    /// @param      name The subdomain name
    /// @param      parent The parent domain
    /// @param      newSubdomain The domain that will be set next
    /// @return     Whether an account can update the subdomain
    function canMoveSubdomain(address updater, string memory name, IDomain parent, address newSubdomain) external view returns (bool);

    /// @notice     Get if an account can unset this domain as a subdomain
    /// @dev        May be called by `canDeleteDomain` of the parent domain - implement access control here!!!
    /// @param      updater The account that may or may not be able to delete a subdomain
    /// @param      name The subdomain to delete
    /// @param      parent The parent domain
    /// @return     Whether an account can delete the subdomain
    function canDeleteSubdomain(address updater, string memory name, IDomain parent) external view returns (bool);
}
```

### Name Resolution
To resolve a name (like `"a.b.c"`), you first split it by the delimiter (resulting in something like `["a", "b", "c"]`). Set `domain` initially to the root domain.

Pop off the last element of the array (`"c"`), then call `domain.hasDomain(lastElement)`. If it's `false`, then the domain resolution fails. Otherwise, set the domain to `domain.getDomain(lastElement)`. Repeat until the list of split segments is empty.

Here is a solidity function that resolves a name:

```sol
function resolve(string[] calldata splitName, IDomain root) public view returns (address) {
    IDomain current = root;
    for (uint i = splitName.length - 1; i >= 0; i--) {
        // Require that the current domain has a domain
        require(current.hasDomain(splitName[i]));
        // Resolve subdomain
        current = current.getDomain(splitName[i]);
    }
    return current;
}
```

### Supported Interfaces
| Interface Name 	| ERC-165 Hash 	| Reference                                       	|
|----------------	|--------------	|-------------------------------------------------	|

## Backwards Compatibility
There is no compatibility with ERC-137. While the two ERCs are somewhat similar, the rationale for each is different. It is also likely impossible to create an ERC-4834 domain that wraps ERC-137, because ERC-137 domains are indexed by the hash of the entire domain, while ERC-4834 domains are indexed by the subdomain name.

## Reference Implementations
Some of these implementations use some contracts from OpenZeppelin (see assets folder) for ease of implementation and understandability. 

Naive Domain Implementation: [NaiveDomain.sol](../assets/eip-4834/NaiveDomain.sol)

EIP-173 (Ownable) Domain Implementation: [OwnableDomain.sol](../assets/eip-4834/OwnableDomain.sol)

ERC-721 (NFT) Domain Implementation: [NFTDomain.sol](../assets/eip-4834/NFTDomain.sol)

## Security Considerations

### Malicious canMoveSubdomain (Black Hole)

#### Description
Moving a subdomain using `setDomain` is a dangerous operation.

Depending on the parent domain's implementation, if a malicious new subdomain unexpectedly returns `false` on `canMoveSubdomain`, that subdomain can effectively lock the ownership of the domain. 

Alternatively, it might return `true` when it isn't expected (i.e. a backdoor), allowing the contract owner to take over the domain.

#### Example Exploit
Black Hole: [BlackHole.sol](../assets/eip-4834/BlackHole.sol)

#### Mitigation
Clients can help by warning if `canMoveSubdomain` or `canDeleteSubdomain` for the new subdomain is false, but it is important to note that since these are functions, it is possible for the value to change depending on whether or not it has already been linked. It's also still possible for it to unexpectedly return true. It is therefore recommended to **always** audit the new subdomain's source code before calling `setDomain`.

### Parent Domain Resolution

#### Description
Parent domains have full control of name resolution for their subdomains. If a particular domain is linked to `a.b.c`, then `b.c` can, depending on its code, set `a.b.c` to any domain, and `c` can set `b.c` itself to any domain.

#### Examples
The reference Ownable domain implementation: [OwnableDomain.sol](../assets/eip-4834/OwnableDomain.sol)

The reference NFT domain implementation: [NFTDomain.sol](../assets/eip-4834/NFTDomain.sol)

In both of these cases, you must trust the owner of the contract not to change the subdomain.

#### Mitigation
Before acquiring a domain that has been pre-linked, it is recommended to always have the contract **and** all the parents up to the root audited.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
