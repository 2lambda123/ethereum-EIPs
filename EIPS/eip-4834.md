---
eip: 4834
title: Hierarchical Domains Standard
description: The Heirarchal Domains Standard is a standard for extremely generic name resolution.
author: Pandapip1 (@Pandapip1)
discussions-to: https://ethereum-magicians.org/t/erc-4834-hierarchical-domains-standard/8388
status: Draft
type: Standards Track
category: ERC
created: 2022-02-22
requires: 165
---

## Abstract
The Hierarchical Domains Standard is a standard for extremely generic name resolution. conversely it makes it simple to extend - any smart contract that implements the ERC-4834 interface could be set as a subdomain. This differs from ERC-137 because it does not provide a separate "resolver" contract - any behaviour should be part of the ERC-4834 contract itself.

## Motivation
The motivation behind this ERC is that existing standards like ERC-137 are relatively complex and have limitations. The advantage of ERC-4834 is that it provides a minimal interface that supports name resolution. This permits use-cases such as referencing an ERC-20 or ERC-1155 token by a name directly, without using a "resolver."

This ERC also implements flexible access control. This allows for clever implementations, such as having a token that can be redeemed for subdomains of the token, and domains that are themselves NFTs that grant the ability to manage the domain to the owner of said NFT. There can also be multiple managers of a single domain with different access, instead of a single "owner."

In addition, TLDs (like .com), subdomains, and even the "root" itself (analogous to the ENS registry) are all implemented as ERC-4834 smart contracts, meaning that name-resolution is a relatively simple recursive algorithm, and there is no limit to the amount of nesting that is possible (e.g. 0.1.2.3.4.5.6.7.8.9.a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z could be valid if the root contains z, and z contains y, and etc).

## Specification
Solidity Interface with NatSpec (Raw: [./eip-4834/IDomain.sol]):
```sol
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.9;

/// @title          ERC-165 Standard Interface Detection
/// @dev            See https://eips.ethereum.org/EIPS/eip-165
interface IERC165 {
    /// @notice     Query if a contract implements an interface
    /// @param      interfaceID The interface identifier, as specified in ERC-165
    /// @dev        Interface identification is specified in ERC-165. This function
    ///             uses less than 30,000 gas.
    /// @return     `true` if the contract implements `interfaceID` and
    ///             `interfaceID` is not 0xffffffff, `false` otherwise
    function supportsInterface(bytes4 interfaceID) external view returns (bool);
}

/// @title          ERC-4835 Heirarchal Domains Standard
/// @author         Pandapip1
/// @dev            https://eips.ethereum.org/EIPS/eip-4835
///                 The ERC-165 identifier for this interface is 0x12E2.
interface IDomain is IERC165 {
    //// CRUD

    /// @notice     Query if a domain has a subdomain with a given name
    /// @param      name The subdomain to query
    /// @return     `true` if the domain has a subdomain with the given name, `false` otherwise
    function hasDomain(string memory name) external view returns (bool);

    /// @notice     Fetch the subdomain with a given name
    /// @dev        This should revert is `hasDomain(name)` is `false`
    /// @param      name The subdomain to fetch
    /// @return     The subdomain with the given name
    function getDomain(string memory name) external view returns (IDomain);

    /// @notice     Update a subdomain with a given name
    /// @dev        This should revert if `canSetDomain(msg.sender, name, pointer)` is `false`
    /// @param      name The subdomain name to be created/updated
    /// @param      subdomain The subdomain to set
    function setDomain(string memory name, IDomain subdomain) external;

    /// @notice     Delete the subdomain with a given name
    /// @dev        This should revert is `hasDomain(name)` is `false` or if
    ///             `canDeleteDomain(msg.sender, name, this)` is `false`
    /// @param      name The subdomain to delete
    function deleteDomain(string memory name) external;


    //// Access Control

    /// @notice     Get if an account can update or create a subdomain with a given name
    /// @dev        It is highly suggested to return `false` if `hasDomain(name)` is `true`
    ///             and `getDomain(name).canUpdateSubdomain(msg.sender, this, subdomain)` is `false`,
    ///             or if `subdomain.canPointSubdomain(msg.sender, name, this) is `false`
    /// @param      updater The account that may or may not be able to create/update a subdomain
    /// @param      name The subdomain name that would be created/updated
    /// @param      subdomain The subdomain that would be set
    /// @return     Whether an account can update or create the subdomain
    function canSetDomain(address updater, string memory name, IDomain subdomain) external view returns (bool);

    /// @notice     Get if an account can move the subdomain away from the current domain
    /// @dev        May be called by `canSetDomain` of the parent domain - implement access control here!!!
    /// @param      updater The account that may be moving the subdomain
    /// @param      name The subdomain name
    /// @param      parent The parent domain
    /// @param      newSubdomain The domain that will be set next
    /// @return     Whether an account can update the subdomain
    function canSetSubdomain(address updater, string memory name, IDomain parent, IDomain newSubdomain) external view returns (bool);

    /// @notice     Get if an account can point this domain as a subdomain
    /// @dev        May be called by `canSetDomain` of the parent domain - implement access control here!!!
    /// @param      updater The account that may be moving the subdomain
    /// @param      name The subdomain name
    /// @param      parent The parent domain
    /// @return     Whether an account can update the subdomain
    function canPointSubdomain(address updater, string memory name, IDomain parent) external view returns (bool);

    /// @notice     Get if an account can delete the subdomain with a given name
    /// @dev        It is highly suggested to return `false` if `hasDomain(name)` is `true` and
    ///             `getDomain(name).canDeleteSubdomain(msg.sender, name, this)` is `false`
    /// @param      updater The account that may or may not be able to delete a subdomain
    /// @param      name The subdomain to delete
    /// @return     Whether an account can delete the subdomain
    function canDeleteDomain(address updater, string memory name) external view returns (bool);

    /// @notice     Get if an account can point this domain as a subdomain
    /// @dev        May be called by `canDeleteDomain` of the parent domain - implement access control here!!!
    /// @param      updater The account that may or may not be able to delete a subdomain
    /// @param      name The subdomain to delete
    /// @param      parent The parent domain
    /// @return     Whether an account can delete the subdomain
    function canDeleteSubdomain(address updater, string memory name, IDomain parent) external view returns (bool);
}
```


## Rationale
As previously mentioned in the abstract and motivation, the design of this ERC is different than that of ERC-137. ERC-137 has a strong tiering - the registrars update the ENS registry, which points to resolvers. In ERC-4834, every domain is effectively a registry, resolver, and registrar all in one. This is specifically designed to be a universal addressing system.

## Backwards Compatibility
There is no compatibility with ERC-137. While the two ERCs are somewhat similar, the rationale for each is different. An ERC-4834 contract that wraps the ERC-137 contract could be created, however, that would support .eth domains, so compatibility is possible.

## Reference Implementation
Ownable (eip-173) domain: [./eip-4834/OwnableDomain.sol]

## Security Considerations
Needs discussion.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
