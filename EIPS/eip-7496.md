---
eip: 7496
title: NFT Dynamic Traits
description: Extension to ERC-721 and ERC-1155 for dynamic onchain traits
author: Adam Montgomery (@montasaurus), Ryan Ghods (@ryanio), 0age (@0age), James Wenzel (emo.eth), Stephan Min (@stephankmin)
discussions-to: https://ethereum-magicians.org/t/erc-7496-nft-dynamic-traits/15484
status: Draft
type: Standards Track
category: ERC
created: 2023-07-28
requires: 165, 721, 1155
---

## Abstract

This specification introduces a new interface that extends [ERC-721](./eip-721.md) and [ERC-1155](./eip-1155.md) that defines methods for setting and getting dynamic onchain traits associated with non-fungible tokens. These dynamic traits can be used to represent properties, characteristics, redeemable entitlements, or other attributes that can change over time. By defining these traits onchain, they can be used and modified by other onchain contracts.

## Motivation

Metadata for non-fungible tokens are often stored offchain. This makes it difficult to query and mutate these values in contract code. Specifying the ability to set and get traits onchain allows for new use cases like transacting based on a token's traits or redeeming onchain entitlements.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

Contracts implementing this EIP MUST include the events, getters, and setters as defined below, and MUST return `true` for [ERC-165](./eip-165.md) supportsInterface for `0x12345678(to be set here when final)`, the 4 byte interfaceId for this ERC. The setters are optional to expose if the contract does not wish for others to modify their metadata, however it is RECOMMENDED to still implement them as permissioned methods to enable for external contract use cases like redemptions. If the contract does not implement the setters, the interfaceId including the setters MUST still be used to identify the contract as implementing this EIP.

```solidity
interface IERC7496 {
    /* Events */
    event TraitUpdated(bytes32 indexed traitKey, uint256 indexed tokenId, bytes32 value);
    event TraitUpdatedBulkConsecutive(bytes32 indexed traitKey, uint256 fromTokenId, uint256 toTokenId);
    event TraitUpdatedBulkList(bytes32 indexed traitKey, uint256[] tokenIds);
    event TraitLabelsURIUpdated(string uri);

    /* Getters */
    function getTraitValue(bytes32 traitKey, uint256 tokenId) external view returns (bytes32);
    function getTraitValues(uint256 tokenId, bytes32[] traitKeys) external view returns (bytes32[]);
    function getTraitKeys() external view returns (bytes32[] memory);
    function getTotalTraitKeys() external view returns (uint256);
    function getTraitKeyAt(uint256 index) external view returns (bytes32);
    function getTraitLabelsURI() external view returns (string memory);

    /* Setters */
    function setTrait(bytes32 traitKey, uint256 tokenId, bytes32 value) external;
    function setTraitLabelsURI(string calldata uri) external;
}
```

### Trait keys

The `traitKey` is used to identify a single trait. The `traitKey` MAY be any value, but it is RECOMMENDED to be the ASCII value of the preferred display label of the trait. Longer key values and translated labels MAY be defined in the trait labels URI.

If a trait key is queried that has not been set, it MUST revert with the error `TraitKeyNotSet(bytes32 traitKey)`. If the tokenId does not exist, it MUST revert, the error MAY be `NonexistentToken()`.

### Trait values

Trait values are returned when querying trait keys. Trait values MAY be any value, but it is RECOMMENDED to display as desired when converting the bytes32 value to ASCII. If the desired trait value is longer than 32 characters that can fit in bytes32, the full trait values and translations MAY be defined in the trait labels URI.

### Trait labels

Trait labels are an optional way to define extra information for displaying trait keys, trait values, and who can edit traits along with their acceptable values to allow for websites to provide UIs to change traits.

The trait labels URI MAY point to an offchain location or an onchain data URI. The specification for the trait labels URI is as follows:

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "traitKey": {
        "type": "string",
        "description": "The bytes32 traitKey stored on the contract."
      },
      "traitLabel": {
        "type": ["string"],
        "description": "The trait label to be displayed for the traitKey."
      },
      "traitLabelTranslations": {
        "type": ["object"],
        "properties": {
          "locale": {
            "type": "string"
          },
          "traitLabel": {
            "type": "string"
          }
        },
        "description": "The traitLabel translations by locale."
      },
      "displayType": {
        "type": ["number"],
        "description": "The display type for the label. See 'Metadata Display Type' enum."
      },
      "traitValues": {
        "type": "object",
        "properties": {
          "onchainTraitValue": {
            "type": "string"
          },
          "displayTraitValue": {
            "type": "string"
          },
          "translations": {
            "type": "object",
            "properties": {
              "locale": {
                "type": "string"
              },
              "traitValue": {
                "type": "string"
              }
            }
          }
        },
        "description": "The full trait values to display in replacement of the onchain trait value. Useful when longer than the 32 ASCII characters that bytes32 allows for."
      },
      "editors": {
        "type": "array",
        "items": {
          "type": "number"
        },
        "description": "The allowed editors who can edit the label. See 'Editor' enum."
      },
      "editorsAddressList": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "If the allowed editors of a trait if the allowed editors are a list of addresses."
      },
      "acceptableValues": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "The acceptable values that the trait can be changed to by the specified editors."
      }
    },
    "required": []
  }
}
```

The `displayType` is how the trait value MUST be displayed to front-end users. If the `displayType` is not defined, it MUST default to `0`. The following table defines the values for `displayType` and MAY be added to in future EIPs that require this one.

| Integer | Metadata Display Type |
| ------- | --------------------- |
| 0       | plain value           |
| 1       | number / percentage   |
| 2       | date                  |
| 3       | hidden                |

The `editors` field should specify an array of integers below mapping to the entities that can modify the trait.

| Integer | Editor                      |
| ------- | --------------------------- |
| 0       | internal (contract address) |
| 1       | contract owner              |
| 2       | token owner                 |
| 3       | custom address list         |

The `acceptableValues` are a set of predefined values that are acceptable to be set for the trait. If any value is accepted, the `*` character SHOULD be used. The `acceptableValues` MAY also define the validation in regex by starting with `regex:`.

The `fullTraitValues` may specify the full trait value display if the desired trait value is larger than the supported bytes32 on the contract itself, along with the translations to different locales.

### Events

Updating traits MUST either emit the `TraitUpdated`, `TraitUpdatedBulkConsecutive` or `TraitUpdatedBulkList` event. For the event `TraitUpdatedBulkConsecutive`, the `fromTokenId` and `toTokenId` MUST be a consecutive range of tokens IDs and MUST be treated as an inclusive range. For the event `TraitUpdatedBulkList`, the `tokenIds` MAY be in any order. Updating the trait labels URI or the contents within the URI MUST emit the event `TraitLabelsURIUpdated` so offchain indexers can be notified to parse the changes.

If the `traitKey` is specified as `*`, then offchain indexers MUST call `getTraitKeys()` to query all trait keys and values for the token IDs.

### Conflicting values with metadata URIs

Traits specified via this specification MUST override any conflicting values specified by ERC-721 or ERC-1155 metadata URIs. If the label of the trait has an exact match of the trait that is returned by tokenURI, then the value returned by this EIP MUST match, and if they do not match, the value returned by the onchain dynamic trait lookup MUST be displayed and used in precedence of the value over tokenURI, since that is what onchain contracts will use to guarantee the values.

If there is a difference in values between the onchain trait and data in the metadata URI, ingestors and websites SHOULD show a warning that there are conflicting values and the onchain trait is to be used for e.g. guaranteeing marketplace transactions.

### setTrait

If the methods `setTrait` and `setTraitLabelsURI` are public on the contract they MUST be permissioned and only be callable by authorized users (e.g. token owner or permissioned contract). This is so `setTrait` can be programmatically called, for example by a redeemable contract when a redemption occurs.

If `setTrait` does not modify the trait's existing value, it MUST revert with the custom error `TraitValueUnchanged()`.

### Newly minted tokens

Newly minted tokens MUST emit the trait updated events for offchain indexers to properly register the traits to be indexed. If the `traitKey` is specified as `*`, then offchain indexers MUST call `getTraitKeys()` to query all trait keys and values for the token IDs.

### Registry functionality

If this EIP is being used as a "registry" to contain onchain metadata for multiple token addresses, for example to augment existing tokens that cannot have their code upgraded, the first 20 bytes of the `traitKey` MUST be the token address. The remaining `12` bytes can be used for the trait key, as ASCII characters OR as the first 12 bytes of the keccak256 hash of a longer key. When used in this format, the supportsInterface SHOULD NOT return for ERC-721 or ERC-1155 so external providers can understand that the traits are not for the contract's token address.

When implemented in a registry format, the trait labels URI JSON MAY specify the `traitKey` as only the last 12 bytes to simplify redundant labels for traitKeys across token addresses.

### ERC-1155 (Semi-fungibles)

This standard MAY be applied to ERC-1155 but the traits would apply to all token amounts for specific token identifiers. If the ERC-1155 contract only has tokens with amount of 1, then this specification MAY be used as written.

## Rationale

While offchain traits specified by metadata URIs are useful, they do not provide the full benefits of having traits available onchain. Onchain traits can be used by internal and external contracts to get and mutate traits in a variety of different scenarios. For example, a contract that enables redeemables can check the value of a redemption and update the trait after the redemption is executed. This also allows onchain p2p marketplaces to guarantee certain trait values during order fulfillment, so trait properties cannot be modified before the sale through frontrunning.

## Backwards Compatibility

As a new EIP, no backwards compatibility issues are present, except for the point in the specification above that it is explicitly required that the onchain traits MUST override any conflicting values specified by the ERC-721 or ERC-1155 metadata URIs.

## Test Cases

Authors have included Foundry tests covering functionality of the specification in the assets folder.

## Reference Implementation

Authors have included reference implementations of the specification in the assets folder.

## Security Considerations

The set\* methods exposed externally MUST be permissioned so they are not callable by everyone but only by select roles or addresses.

Marketplaces SHOULD NOT trust offchain state of traits as they can be frontrunned. Marketplaces SHOULD check the current state of onchain traits at the time of transfer. Marketplaces MAY check certain traits that change the value of the NFT (e.g. redemption status) or they MAY hash all the trait values to guarantee the same state at the time of order creation.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
