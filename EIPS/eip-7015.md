---
eip: 7015
title: NFT Creator Attribution
description: Extending NFTs with cryptographically secured creator attribution.
author: Carlos Flores (@strollinghome)
discussions-to: https://ethereum-magicians.org/t/eip-authorship-attribution-for-erc721/14244
status: Draft
type: Standards Track
category: ERC
created: 2023-05-11
requires: 55, 155, 712, 721, 1155
---

## Abstract

This Ethereum Improvement Proposal aims to solve the issue of creator attribution for Non-Fungible Token (NFT) standards ([ERC-721](./eip-721.md), [ERC-1155](./eip-1155.md)). To achieve this, this EIP proposes a mechanism where the NFT creator signs the required parameters for the NFT creation, including the NFT metadata in a hash along with any other relevant information. The signed parameters and the signature are then validated and emitted during the deployment transaction, which allows the NFT to validate the creator and NFT platforms to attribute creatorship correctly. This method ensures that even if a different wallet sends the deployment transaction, the correct account is attributed as the creator.

## Motivation

Current NFT platforms assume that the wallet deploying the smart contract is the creator of the NFT, leading to a misattribution in cases where a different wallet sends the deployment transaction. This happens often when working with smart wallet accounts, and new contract deployment strategies such as the first collector deploying the NFT contract. This proposal aims to solve the problem by allowing creators to sign the parameters required for NFT creation so that any wallet can send the deployment transaction with an signal in a verifiable way who is the creator.

## Specification

The keywords “MUST,” “MUST NOT,” “REQUIRED,” “SHALL,” “SHALL NOT,” “SHOULD,” “SHOULD NOT,” “RECOMMENDED,” “MAY,” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

ERC-721 and ERC-1155 compliant contracts MAY implement this NFT Creator Attribution extension to provide a standard event to be emitted that defines the NFT creator at the time of contract creation.

This EIP takes advantage of the fact that contract addresses can be precomputed before a contract is deployed. Whether the NFT contract is deployed through another contract (a factory) or through an EOA, the creator can be correctly attributed using this specification.

**Signing Mechanism**

Creator consent is given by signing an [EIP-712](./eip-712.md) compatible message; all signatures compliant with this EIP MUST include all fields defined. The struct signed can be any arbitrary data that defines how to create the token; it must hashed in an EIP-712 compatible format with a proper EIP-712 domain. 

The following shows some examples of structs that could be encoded into `structHash` (defined below):

```solidity
// defines that a token can be created with a specified id and metadata uri
struct TokenCreation {
  uint256 tokenId;
  string metadataUri;
}

// defines that a token can be created and will have the specified price
struct TokenCreation {
  uint256 price;
}
```

**Signature Validation**

Creator attribution is given through a signature verification that MUST be verified by the NFT contract being deployed and an event that MUST be emitted by the NFT contract during the deployment transaction. The event includes all the necessary fields for reconstructing the signed digest and validating the signature to ensure it matches the specified creator. The event name is `CreatorAttribution` and includes the following fields:

- `structHash`: hashed information for deploying the NFT contract (e.g. name, symbol, admins etc). This corresponds to the value `hashStruct` as defined in the [EIP-712 definition of hashStruct](./eip-712.md#definition-of-hashstruct) standard.
- `domainName`: the domain name of the contract verifying the singature (for EIP-712 signature validation). 
- `version`: the version of the contract verifying the signature (for EIP-712 signature validation)
- `creator`: the creator's account
- `signature`: the creator’s signature

The event is defined as follows:

```solidity
event CreatorAttribution(
	bytes32 structHash,
	string domainName,
	string version,
    address creator,
	bytes signature
);
```

Note that although the `chainId` parameters is necessary for [EIP-712](./eip-712.md) signatures, we omit the parameter from the event as it can be inferred through the transaction data. Similarly, the `verifyingContract` parameter for signature verification is omitted since it MUST be the same as the `emitter` field in the transaction. `emitter` MUST be the token.

A platform can verify the validity of the creator attribution by reconstructing the signature digest with the parameters emitted and recovering the signer from the `signature` parameter. The recovered signer MUST match the `creator` emitted in the event. If `CreatorAttribution` event is present creator and the signature is validated correctly, attribution MUST be given to the `creator` instead of the account that submitted the transaction.

### Reference Implementation

#### Example signature validator

The following shows an example erc721 contract that implements the Creator Attribution standard.
It allows a creator to sign a message that includes the token uri and a nonce; the nonce ensures
that the signature can only be used once to create a token. The signature and token creation
parameters are passed to the `delegatedSafeMint` function which validates the signature, ensuring
that the signer is an account that can create a token on the contract, which in this case can only
be the owner. It then creates the token, while marking the `nonce` as being used.  It then emits the 
`CreatorAttribution` event which can includes all of the data needed to recover the creator address 
from the signature.

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/cryptography/EIP712.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract DelegatedErc721 is EIP712, ERC721, ERC721URIStorage, Ownable {
  error Invalid_Signature();
  error AlreadyMinted();

  event CreatorAttribution(
    bytes32 structHash,
    string domainName,
    string version,
    address creator,
    bytes signature
  );

  uint256 private _nextTokenId;

  bytes32 public constant TYPEHASH =
    keccak256("CreatorAttribution(string uri,uint256 nonce)");

  // mapping of signature nonce to if it has been minted
  mapping(uint256 => bool) public minted;

  constructor(
    address initialOwner
  ) EIP712("ERC7015", "1") ERC721("My Token", "TKN") Ownable(initialOwner) {}

  function delegatedSafeMint(
    address to,
    string memory uri,
    uint256 nonce,
    bytes calldata signature
  ) external {
    uint256 tokenId = _nextTokenId++;

    // validate that the nonce has not been used, then mark it as used.
    if (minted[nonce]) revert AlreadyMinted();
    minted[nonce] = true;

    // validate the signature, ensuring the signer has permission to create 
    // tokens, then emit the `CreatorAttribution` event
    _validateSignature(uri, nonce, signature);

    _safeMint(to, tokenId);
    _setTokenURI(tokenId, uri);
  }

  function makeAttributionStructHash(
    string memory uri,
    uint256 nonce
  ) public pure returns (bytes32) {
    return keccak256(abi.encode(TYPEHASH, keccak256(bytes(uri)), nonce));
  }

  function _validateSignature(
    string memory uri,
    uint256 nonce,
    bytes memory signature
  ) internal {
    // build the struct hash from the signature params
    bytes32 structHash = makeAttributionStructHash(uri, nonce);

    // require creator to be the contract owner
    address creator = owner();

    if (!_isValid(structHash, creator, signature)) revert Invalid_Signature();

    emit CreatorAttribution(structHash, "ERC7015", "1", creator, signature);
  }

  function _isValid(
    bytes32 structHash,
    address signer,
    bytes memory signature
  ) internal view returns (bool) {
    require(signer != address(0), "cannot validate");

    bytes32 digest = _hashTypedDataV4(structHash);

    address recoveredSigner = ECDSA.recover(digest, signature);

    return recoveredSigner == signer;
  }

  // The following functions are overrides required by Solidity.
  function tokenURI(
    uint256 tokenId
  ) public view override(ERC721, ERC721URIStorage) returns (string memory) {
    return super.tokenURI(tokenId);
  }

  function supportsInterface(
    bytes4 interfaceId
  ) public view override(ERC721, ERC721URIStorage) returns (bool) {
    return super.supportsInterface(interfaceId);
  }
}
```

#### End to end example of creating a token with creator attribution, then verifying the creator from the CreatorAttribution event

The following shows how `viem.sh` can be used to sign a typed message to be used in the 
above contract:

```ts
import {
  http,
  createWalletClient,
  createPublicClient,
  hashDomain,
  Hex,
  keccak256,
  concat,
  recoverAddress,
  TypedDataDomain
} from "viem";
import {
  mainnet
} from "viem/chains";

// this would be set to the deployed contract address
const contractAddress: Address = '....';

// this would be set to the creator address of the token
const creator: Address = '....';

const walletClient = createWalletClient({
  chain: mainnet,
  transport: http(),
}); 

// 1. Have the creator sign a message to create a token
// sign a message for the CreatorAttribution, which has a TYPEHASH of CreatorAttribution(string uri,uint256 nonce)
const tokenUri = 'ipfs://QmYXJ5Y2FzdC5qcGc';
const nonce = 1n;

// eipDomain params
const chainId = await walletClient.getChainId();

// have creator sign a message permitting a token to be created on the contract
const signature = await walletClient.signTypedData({
  types: {
    CreatorAttribution: [
      { name: "uri", type: "string" },
      { name: "nonce", type: "uint256" },
    ],
  },
  primaryType: "CreatorAttribution",
  message: {
    uri: tokenUri,
    nonce,
  },
  // signer of the message; the contract requires
  // this to match the owner of the contract
  account: creator,
  domain: {
    chainId,
    verifyingContract: contractAddress,
    // these two need to match the domain name and version in the erc712 contract
    name: "ERC7015",
    version: "1"
  }
});
```

When requesting the signature the message, the wallet will display a popup module with the specific fields that are to be signed.

Then, given that signature, the token uri, and the nonce, the token can be created and minted by any account:

```ts
const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(),
});

// This would be set to be the account that is minting the token
const minter: Address = '0x...';

// relevant part of the abi for this 
const delegatedMintAbi = [{
  stateMutability: 'nonpayable',
  type: 'function',
  inputs: [
    { name: 'to', internalType: 'address', type: 'address' },
    { name: 'uri', internalType: 'string', type: 'string' },
    { name: 'nonce', internalType: 'uint256', type: 'uint256' },
    { name: 'signature', internalType: 'bytes', type: 'bytes' },
  ],
  name: 'delegatedSafeMint',
  outputs: [],
}] as const;

const tx = await walletClient.writeContract({
  abi: delegatedMintAbi,
  address: contractAddress,
  account: minter,
  functionName: 'delegatedSafeMint',
  args: [
    minter, tokenUri, nonce, signature
  ]
});

const receipt = await publicClient.waitForTransactionReceipt({
  hash: tx
});
```

And finally, the creator can be recovered from the `CreatorAttribution` event:

```ts
const topics = await publicClient.getContractEvents({
  abi: delegatedErc721ABI,
  address: contractAddress,
  eventName: "CreatorAttribution"
});

const creatorAttributionEventArgs = topics[0]!.args;

const domain: TypedDataDomain = {
  chainId,
  name: creatorAttributionEventArgs.domainName!,
  verifyingContract: contractAddress,
  version: creatorAttributionEventArgs.version!
}

// hash the eip712 domain based on the parameters emitted from the event:
const hashedDomain = hashDomain({
  domain,
  types: {
    EIP712Domain: getTypesForEIP712Domain({ domain })
  }
});

// re-build the eip-712 typed data hash, consisting of the hashed domain and the structHash emitted from the event:
const parts: Hex[] = ["0x1901", hashedDomain, creatorAttributionEventArgs.structHash!];

const hashedTypedData = keccak256(concat(parts));

// recover the signer from the hashed typed data and the signature:
const recoveredSigner = await recoverAddress({
  hash: hashedTypedData,
  signature: signature!,
});

// recoveredSigner should match the creator address
```

## Rationale

By standardizing the `CreatorAttribution` event, this EIP enables platforms to ascertain creator attribution without relying on implicit assumptions. Establishing a standard for creator attribution empowers platforms to manage the complex aspects of deploying contracts while preserving accurate onchain creator information. This approach ensures a more reliable and transparent method for identifying NFT creators, fostering trust among participants in the NFT ecosystem.

[ERC-5375](./eip-5375.md) attempts to solve the same issue and although offchain data offers improved backward compatibility, ensuring accurate and immutable creator attribution is vital for NFTs. A standardized onchain method for creator attribution is inherently more reliable and secure.

In contrast to this proposal, ERC-5375 does not facilitate specifying creators for all tokens within an NFT collection, which is a prevalent practice, particularly in emerging use cases.

Both this proposal and ERC-5375 share similar limitations regarding address-based creator attribution:

> The standard defines a protocol to verify that a certain *address* provided consent. However, it does not guarantee that the address corresponds to the expected creator […]. Proving a link between an address and the entity behind it is beyond the scope of this document.

## Backwards Compatibility

Since the standard requires an event to be emitted during the NFTs deployment transaction, existing NFTs cannot implement this standard.

## Security Considerations

A potential attack exploiting this proposal could involve deceiving creators into signing creator attribution consent messages unintentionally. Consequently, creators MUST ensure that all signature fields correspond to the necessary ones before signing.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
