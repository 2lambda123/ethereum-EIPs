---
eip: 7108
title: Clustered ERC-721
description: Extend ERC-721 to allow for clusters of NFTs ad sub-collections
author: Francesco Sullo (@sullof)
discussions-to: https://ethereum-magicians.org/t/clustered-nft-for-sub-collections/14502
status: Draft
type: Standards Track
category: ERC
created: 2023-05-30
requires: 165, 721
---

## Abstract

A standard interface for contracts that manage clusters or sub-collections of [ERC-721](./eip-721) tokens within a single contract.

This EIP introduces a new standard interface for Ethereum contracts that manage multiple clusters or sub-collections of [ERC-721](./eip-721) tokens within a single contract. This allows the tokens to be grouped together in a way that maintains each group's distinct identity and metadata.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

A contract that includes this interface must implement the [ERC-721](./eip-721) interface and adhere to the same specifications and restrictions. Additionally, it must implement the following functions:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

// Authors: Francesco Sullo <francesco@sullo.co>

/**
 * @title IERC7108
 * @dev This interface allows managing clusters or sub-collections of ERC721 tokens within a single contract
 */
interface IERC7108 {
  /**
   * @dev Emitted when a new cluster is added
   */
  event ClusterAdded(uint256 indexed clusterId, string name, string symbol, string baseTokenURI, uint256 size, address owner);

  /**
   * @dev Emitted when ownership of a cluster is transferred
      The interface does not specify functions to transfer the ownership of the cluster
      to leave the implementer full freedom about how to implement it, with the only
      requirement that a ClusterOwnershipTransferred event MUST be emitted if so
   */
  event ClusterOwnershipTransferred(uint256 indexed clusterId, address indexed newOwner);

  /**
   * @notice Gets the id of the cluster to which a token belongs
   * @param tokenId ID of the token
   * @return uint256 ID of the cluster to which the token belongs
   */
  function clusterOf(uint256 tokenId) external view returns (uint256);

  /**
   * @notice Gets the name of a cluster
   * @param clusterId ID of the cluster
   * @return string Name of the cluster
   */
  function nameOf(uint256 clusterId) external view returns (string memory);

  /**
   * @notice Gets the symbol of a cluster
   * @param clusterId ID of the cluster
   * @return string Symbol of the cluster
   */
  function symbolOf(uint256 clusterId) external view returns (string memory);

  /**
   * @notice Gets the range of token IDs that are included in a specific cluster
   * @param clusterId ID of the cluster
   * @return (uint256, uint256) Start and end of the token ID range
   */
  function rangeOf(uint256 clusterId) external view returns (uint256, uint256);

  /**
   * @notice Gets the owner of a cluster
   * @param clusterId ID of the cluster
   * @return address Owner of the cluster
   */
  function clusterOwner(uint256 clusterId) external view returns (address);

  /**
   * @notice Gets how many clusters have been added
   * @return uint256 Total number of clusters
   */
  function clustersCount() external view returns (uint256);

  /**
   * @notice Adds a new cluster
   * @dev The ClusterAdded event MUST be emitted upon successful execution
   * @param name Name of the cluster
   * @param symbol Symbol of the cluster
   * @param baseTokenURI Base Token URI of the cluster
   * @param size Size of the cluster (number of tokens)
   * @param clusterOwner Address of the cluster owner
   */
  function addCluster(
    string memory name,
    string memory symbol,
    string memory baseTokenURI,
    uint256 size,
    address clusterOwner
  ) external;

  /**
   * @notice Gets the normalized token ID for a token
   * @dev The normalized token ID is the token ID within the cluster, starting from 1
   * @param tokenId ID of the token
   * @return uint256 Normalized token ID
   */
  function normalizedTokenId(uint256 tokenId) external view returns (uint256);

}
```

## Rationale

Non-fungible tokens (NFTs) have proven to be a transformative way of demonstrating ownership over both digital and physical assets. However, when multiple categories or groups of NFTs are managed within a single contract, it can become difficult and confusing. This EIP presents a standard interface that simplifies the management of grouped NFTs. This is particularly beneficial in scenarios where collections of NFTs can be logically grouped together under a common theme or characteristic, while still necessitating that each maintains its unique identity and metadata.

Additionally, this EIP aims to alleviate the financial burden for developers who may not be able to afford the costs associated with deploying a new contract for each distinct collection. With this interface, a single contract can manage an infinite number of clusters, thus streamlining the creation process for new collections. This parallels the function of marketplaces such as OpenSea or SuperRare, which support lazy-minting by allowing the creation of multiple unique tokens within a single contract.

By facilitating the creation of distinct clusters within one contract, this standard provides greater flexibility and simplicity for managing collections of NFTs. This allows for a more organized representation of NFTs, aiding both developers and users in navigation and interaction, while preserving the unique attributes of each token. For example, a game may allow its users to create collections of generated assets.

## Backwards Compatibility

This EIP is fully backwards compatible with the existing [ERC-721](./eip-721) standard. A contract that implements [ERC-7108](./eip-7108) also implements [ERC-721](./eip-721).


## Reference Implementation

There is an example of implementation of this interface (also in [this directory](../assets/eip-7108)).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// Authors: Francesco Sullo <francesco@sullo.co>

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./IERC7108.sol";

//import "hardhat/console.sol";

// Reference implementation of ERC-7108

contract ERC7108 is IERC7108, ERC721, Ownable {

  using Strings for uint256;

  error ZeroAddress();
  error NotClusterOwner();
  error SizeTooLarge();
  error ClusterFull();
  error ClusterNotFound();

  struct Cluster {
    address owner;
    uint32 size;
    uint32 firstTokenId;
    uint32 nextTokenId;
    string name;
    string symbol;
    string baseTokenURI;
  }

  mapping(uint256 => Cluster) public clusters;
  mapping(address => uint256[]) public clusterIdByOwners;
  uint256 public maxSize = 10000;

  uint256 private _nextClusterId = 0;

  constructor(string memory name, string memory symbol) ERC721(name, symbol) {}

  // in this implementation anyone can create a new collection
  function addCluster(
    string memory name,
    string memory symbol,
    string memory baseTokenURI,
    uint256 size,
    address clusterOwner_
  ) public override {
    if (clusterOwner_ == address(0)) revert ZeroAddress();
    if (size > maxSize) revert SizeTooLarge();
    uint256 lastTokenIdInClusters;
    if (_nextClusterId > 0) {
      lastTokenIdInClusters = clusters[_nextClusterId - 1].firstTokenId + clusters[_nextClusterId - 1].size - 1;
    }
    clusters[_nextClusterId] = Cluster({
      name: name,
      symbol: symbol,
      baseTokenURI: baseTokenURI,
      owner: clusterOwner_,
      firstTokenId: uint32(lastTokenIdInClusters + 1),
      size: uint32(size),
      nextTokenId: uint32(lastTokenIdInClusters + 1)
    });
    clusterIdByOwners[clusterOwner_].push(_nextClusterId);
    emit ClusterAdded(_nextClusterId, name, symbol, baseTokenURI, size, clusterOwner_);
    _nextClusterId++;
  }

  function _binarySearch(uint x) internal view returns(uint) {
    if (_nextClusterId == 0) {
      return type(uint).max;
    }

    uint start;
    uint end = _nextClusterId - 1;
    uint mid;

    while (start <= end) {
      mid = start + (end - start) / 2;
      uint first = uint(clusters[mid].firstTokenId);
      uint next = uint(clusters[mid].firstTokenId + clusters[mid].size);
      if (x >= first && x < next) {
        return mid;
      }
      else if (x >= next) {
        if (mid == end) {
          break;
        }
        start = mid + 1;
      }
      else {
        if (mid == 0) {
          break;
        }
        end = mid - 1;
      }
    }
    return type(uint).max;
  }

  function clusterOf(uint256 tokenId) public view override returns (uint256) {
    uint256 clusterId = _binarySearch(tokenId);
    if (clusterId == type(uint256).max) revert ClusterNotFound();
    return clusterId;
  }

  function nameOf(uint256 clusterId) public view override returns (string memory) {
    return clusters[clusterId].name;
  }

  function symbolOf(uint256 clusterId) public view override returns (string memory) {
    return clusters[clusterId].symbol;
  }

  function rangeOf(uint256 clusterId) public view override returns (uint256, uint256) {
    return (clusters[clusterId].firstTokenId, clusters[clusterId].firstTokenId + clusters[clusterId].size - 1);
  }

  function clusterOwner(uint256 clusterId) public view override returns (address) {
    return clusters[clusterId].owner;
  }

  function clustersCount() public view override returns (uint256) {
    return _nextClusterId;
  }

  // This function was originally part of the interface but it was removed
  // to leave the implementer full freedom about how to manage the ownership
  function transferClusterOwnership(uint256 clusterId, address newOwner) public {
    if (newOwner == address(0)) revert ZeroAddress();
    if (clusters[clusterId].owner != msg.sender) revert NotClusterOwner();
    clusters[clusterId].owner = newOwner;
    emit ClusterOwnershipTransferred(clusterId, newOwner);
  }

  function normalizedTokenId(uint256 tokenId) public view override returns (uint256) {
    uint256 clusterId = _binarySearch(tokenId);
    if (clusterId == type(uint32).max) revert ClusterNotFound();
    return tokenId - clusters[clusterId].firstTokenId + 1;
  }

  function mint(uint256 clusterId, address to) public {
    if (clusters[clusterId].owner == address(0)) revert ClusterNotFound();
    if (clusters[clusterId].owner != msg.sender) revert NotClusterOwner();
    if (clusters[clusterId].nextTokenId > clusters[clusterId].firstTokenId + clusters[clusterId].size - 1) revert ClusterFull();
    _mint(to, clusters[clusterId].nextTokenId++);
  }

  // This function assumes that if a project manage a specific cluster, it would be easier to look at the metadata of the token
  // starting from 1 instead of from cluster.firstTokenId. However, the implementer can decide the best strategy
  // and change this function accordingly. This is just an example.
  function tokenURI(uint256 tokenId) public view override returns (string memory) {
    _requireMinted(tokenId);
    uint256 clusterId = _binarySearch(tokenId);
    string memory baseURI = clusters[clusterId].baseTokenURI;
    tokenId -= clusters[clusterId].firstTokenId - 1;
    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
  }

  function getInterfaceId() external pure returns(bytes4) {
    return type(IERC7108).interfaceId;
  }
}
```

## Security Considerations

Given that a single contract under this standard allows for the creation of an unlimited number of sub-collections, each mintable by their respective cluster owners, it's crucial for marketplaces and other interacting entities to accurately distinguish between these sub-collections. Each sub-collection should be treated as a distinct entity, rather than conflating them as part of a single collection.

This distinction is essential for maintaining the security and integrity of the contract, as it helps to prevent unauthorized actions across different clusters. Misidentifying clusters can lead to unintentional access permissions, faulty transactions, or incorrect display of data. Therefore, it is highly recommended that adequate measures are taken to ensure proper identification and handling of the individual sub-collections within a contract.

Additionally, developers implementing this interface should take extra precautions in their permissions system to make sure that only the rightful cluster owners are allowed to mint tokens in their respective clusters. Robust implementation of access controls is critical in avoiding potential security vulnerabilities associated with unauthorized minting.

Finally, the contract, may want to avoid that two clusters share the same name or the same baseTokenURI, etc. to avoid scams.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
