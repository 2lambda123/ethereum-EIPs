---
eip: 2585
title: Minimal Native Meta Transaction Forwarder
author: Ronan Sandford (@wighawag)
discussions-to: https://github.com/ethereum/EIPs/issues/2585
status: Draft
type: Standards Track
category: ERC
created: 2020-04-03
---

## Simple Summary

This standard defines a universal smart contract, the "Forwarder", that accept specially crafted signed message by Externally Owned Accounts (EOA) to be executed as contract calls on their behalf by third parties (relayers). These relayers take the responsibility of signing and broadcasting an ethereum transaction carrying the message (a "Meta Transaction" message). The proposal is made so that extra Meta Transaction functionality can be built on top without the need for receiver contract to be changed.

## Abstract

Native Meta Transaction allows users that simply own a private key to interact on the Ethereum network by only signing messages (no need for ether or account contract, just a private key). Third parties (the relayers) broadcast these messages through a contract on their behalf. 
That contract is in charge to ensure the signing message is well formed and come from the intended signer. It also ensure replay protection so a message cannot be used twice.

This proposal implements a minimal contract with that responsibility, while remaining flexible for future extension. On particular it allows more complex message format (like [EIP-1776](https://github.com/ethereum/EIPs/issues/1776)) to be implemented on top, while meta transaction receiver can remain unchanged and trust only the singleton Forwarder.

msg.sender verification is achieved by replacing the use of solidity `msg.sender` with a function that extract the signer address from the call data.

## Motivation

Several EIPs have been proposed to support Meta Transactions ([EIP-1776](https://github.com/ethereum/EIPs/issues/1776), [EIP-1613](https://eips.ethereum.org/EIPS/eip-1613), [EIP-1077](https://eips.ethereum.org/EIPS/eip-1077)). They all have so far failed to get traction. This can be attributed to several factor but one important aspect is that they all tries to implement much more that simply forwarding message to contracts.
By being complex, they increase the friction for contract developer that need to trust that these solution are future proof.

This proposal aims at finding the most basic features while remaining extensible. As such this proposal will not deal with relayer repayment (that EIP-1776 and other tackle) or relayer coordination (that EIP-1613 tackle). Its sole purpose it to ensure the signed message is valid and that receiver contract have only one contract to trust.

## Specification 
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).
 
### Message format  
  
The proposal is using a message format based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712) so that wallet that support EIP-712 but do not support the proposal described here can still offer an approval display showing all the information albeit in a less than ideal presentation.  
    
Here is the proposed EIP-712 message format :  
```MetaTransaction(address from,address to,uint256 value,uint256 chainId,address replayProtection,bytes nonce,bytes data,bytes32 innerMessageHash)```  

The meaning of each field is as follow:  
  
* **from**: the account from which the meta-transaction is executed for, that value will be appended to the calldata of the meta transaction call. It MUST be either equal to the resulting message signer or have been given execution rights to the signer (via [ERC1271](https://eips.ethereum.org/EIPS/eip-1271) or [ERC1654](https://github.com/ethereum/EIPs/issues/1654))  
* **to**: the target that will receive the meta transaction call.
* **value**: the ether value expected to be given by the relayer to the call. This can be used by more complex meta transaction implementation, to allow user that do own ether to perfrom tx that requires it. THis can be compensated for example by paying the relayer for it in token or other means. This is outside of the scope of this EIP.
* **chainId**: By specifying the chainId, the meta transaction is not going to be executable in a fork whose chainId is different. See rationale for why we do not use EIP-712 chainId from the domain
* **replayProtection**: address of a contract that will handle replay protection for the user. If set to address(0) or the address of the forwarder, it will use the default replay protection, see below for more details.
* **nonce**:  the nonce value used by the signer and passed to `replayProtection.checkAndUpdateNonce(bytes)`. The default is a 2 dimensional nonce represented as a 256 bit integer split in two.
* **data**: the bytes to be executed at ```to```. the `from` address will be appended to it so that receiver contract can access the signer of the meta transaction.
* **innerMessageHash**: Its purpose is to allow more complex meta transaction mechanism to embed message into a single message. (see below for details)
  
### transaction execution and receiver verification  
  
After the singleton Forwarder contract check for the validity of the signature, it append the address of the signer (or the account contract if using EIP-1271 or EIP-1654) to the call data.

As the result in order for a contract to receive meta transaction it simply has to extend the following contract and replace text occurance of `msg.sender` with `_getTxSigner()` :

```
pragma solidity 0.6.4;

contract ForwarderReceiverBase {
    address /* immutable */ _forwarder; // can be hardcoded once the Forwarder address is known
    constructor(address forwarder) public {
        _forwarder = forwarder;
    }

    function _getTxSigner() internal view returns (address payable signer) {
        if (msg.sender == _forwarder) {
            bytes memory data = msg.data;
            uint256 length = msg.data.length;
            assembly { signer := and(mload(sub(add(data, length), 0x00)), 0xffffffffffffffffffffffffffffffffffffffff) }
        } else {
            signer = msg.sender;
        }
	}
}
``` 


### default replay protection

While the Forwarder allows user to choose any replay protection they chose, this forwarder comes with a default implementation to get started.
The default implementation use a 2 dimensional nonce, so that user can send simultaneous transactions in multiple independent batches.

The nonce is simply an abi encoded uint256 that is split in two 128 bit values. The higher bits represent the batchId while the lower bits represent the nonce in the batch.

Application can request the current nonce by calling the function `getNonce(userAddress, batchId)`

The nonce to be sent is equal to the current Nonce. For every use the current Nonce get increased by one for that particular batch.

### batching calls

THe forwarder also provide a mechanism to batch meta transaction in one message allowing the calls to either succeed fully or fails.
The message need to perform encode a call to the forwarder with this special function : `batch` that can only be called by the forwarder itself.
Calls are a struct containing the destination (`to`), the data (`data`) and the ether value to passed in (`value`). It is up to the user to ensure it sign a value big enough to cover the sum of all values passed in.

 
### wallet / browser  
  
While the forwarder use EIP-712 message format and wallet can use the information to display some information about the meta transaction. Wallets should integrate EIP-2585 more comprehensively.
In particular they should show a UI similar to existing ethereum transaction.
Furthermore, since that proposal is built to support extensibility via the `innerMessageHash` wallet that supports EIP-2585 should add a specific API for emitting meta transaction :

`eth_signMetaTransaction(message, innerMessage)`

`innerMessage` is optional. When absent, message need to include the `innerMessageHash` or it default to the zero filled bytes32.

where message is the message format specified above (minus innerMessageHash) and innerMessage is an EIP-712 compliant message that will get hashed to become the `innerMessageHash` of the message.

## Rationale

### Account Contract Support

While Native Meta Transaction System like this EIP, are designed to allow Externally Owned Accounts (EOA) to emit Meta Transaction, allowing Account contract to use such system is valuable for the following reasons :
- Account Contract can reuse the relayers already setup for EIP-2585
- Any EIP built on top of EIP-2585 would benefit Account Contracts too
- The extra complexity is not big and EIP like EIP-1271 and EIP-1654 already exists

### Forwarding msg.value

While on its own forwarding `msg.value` might not be used with EIP-2585 alone (as relayer would need to be compensated and EIP-2585 does not attempt to tackle that), EIP built on top, like EIP-1776 would benefit in allowing EOA to pay for service in ETH by rewarding relayers in other tokens.

### Flexible Replay Protection

While the implementation implements a default 2 dimensional nonce replay protection, it also allows signers to provide their own.

### innerMessageHash

The innerMessageHash's purpose is that more complex message format can be used to support more complex meta transaction system. FOr example relayer repayment mechanism proposed by EIP-1776 can be built on top.

The innerMessageHash is to be used by wallet provider and MUST be the hash of an EIP-712 message, that wallet can then interpret to display the relevant information. See below for a description on how wallet handle such hash. Future message format could be added too.

### Signature Format : EIP-712

The message format is based on EIP-712 so that wallet not supporting EIP-2585 can still display some information. Unfortunately, they would not be able to display any information provided by the message hashed into `innerMessageHash` for EIP-2585 extension, like EIP-1776

### Fork Protection (and transition)

The message format do not use EIP-712 domain for chainId protection as this introduce unnecessary implementation complexity for dealing with EIP-712 domain hash refresh. Instead the chainId is provided as part of the meta transaction message. Since we expect wallet to parse the message for proper display, they can handle chainId verification too.

The chainId is then passed in to the call and checked against the current chain's chainId. This is so a proper error message is given in case the chainId do not match.

Note that such system does not handle fork transition. [EIP-1344](https://eips.ethereum.org/EIPS/eip-1344) is not well suited for it as it would require the maintenance of a chainId cache to handle past chainId and this would add extra complexity. Because contentious chain forks are infrequent and the only downside would be that user would have to resubmit their signed message for the new fork they are interested in, the complexity added is not worth it. Plus even a cache is not full proof as mentioned in [EIP-1965](https://eips.ethereum.org/EIPS/eip-1965)

On the other hand if EIP-1965 was implemented we could have used it to offer safe fork transition too.

### Batching Capability

The Forwarder allows Meta transaction to be batched in a single transaction, but instead of complexifying the message format to include an array of calls, the implementation instead relies on a special `batch` function that can be the target of the meta transaction itself.

Wallet will need to parse this special call to display the list of meta transaction call to be executed.


## Backwards Compatibility
This is a new contract and interface, no backward compatibility issues

## Test Cases

Tests can be found [here](https://github.com/wighawag/eip-2585/tree/master/contracts/test/)

## Implementation

```solidity
/* EIP-2585 Minimal Native Meta Transaction Forwarder
 * This standard defines a universal native meta transaction smart contract
 * that accept specially crafted Externally Owned Accounts (EOA) signed message
 * to forward to receiver contract via third parties.
 *
 * Written in 2020 by Ronan Sandford
 *
 * To the extent possible under law, the author(s) have dedicated all copyright
 * and related and neighboring rights to this software to the public domain
 * worldwide. This software is distributed without any warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication along
 * with this software. If not, see
 * <https://creativecommons.org/publicdomain/zero/1.0/>.
 *    
 *       .-''-.  .-./`) .-------.               .`````-.  ,--------.     .-''''-.  ,--------.   
 *     .'_ _   \ \ .-.')\  _(`)_ \             /   ,-.  \ |   _____|    /  _--.  \ |   _____|   
 *    / ( ` )   '/ `-' \| (_ o._)|            (___/  |   ||  )          |_( )_ ' | |  )         
 *   . (_ o _)  | `-'`"`|  (_,_) /_ _    _ _        .'  / |  '----.     (_ o _). / |  '----.    
 *   |  (_,_)___| .---. |   '-.-'( ' )--( ' )   _.-'_.-'  |_.._ _  '.  .'(_,_).  `.|_.._ _  '.  
 *   '  \   .---. |   | |   |   (_{;}_)(_{;}_)_/_  .'        ( ' )   \|_( )_    \  |  ( ' )   \ 
 *    \  `-'    / |   | |   |    (_,_)--(_,_)( ' )(__..--. _(_{;}_)  |(_ o _)   /  |_(_{;}_)  | 
 *     \       /  |   | /   )               (_{;}_)      ||  (_,_)  /  (_,_)..-' .'|  (_,_)  /  
 *      `'-..-'   '---' `---'                (_,_)-------' `...__..'     `-....-'   `...__..'   
 *                                                                                           
 */
pragma solidity 0.6.4;
pragma experimental ABIEncoderV2;

interface ERC1271 {
    function isValidSignature(bytes calldata data, bytes calldata signature) external view returns (bytes4 magicValue);
}

interface ERC1654 {
   function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);
}

interface ReplayProtection {
    function checkAndUpdateNonce(address signer, bytes calldata nonce) external returns (bool);
}

interface Forwarder {

    enum SignatureType { DIRECT, EIP1654, EIP1271 }

    struct Message {
        address from;
        address to;
        uint256 chainId;
        address replayProtection;
        bytes nonce;
        bytes data;
        bytes32 innerMessageHash;
	}

    function forward(
        Message calldata message,
        SignatureType signatureType,
        bytes calldata signature
    ) external payable;
}

library SigUtil {
    function recover(bytes32 hash, bytes memory sig) internal pure returns (address recovered) {
        require(sig.length == 65, "SIGNATURE_INVALID_LENGTH");

        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }

        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions
        if (v < 27) {
            v += 27;
        }
        require(v == 27 || v == 28, "SIGNATURE_INVALID_V");

        recovered = ecrecover(hash, v, r, s);
        require(recovered != address(0), "SIGNATURE_ZERO_ADDRESS");
    }

    function eth_sign_prefix(bytes32 hash) internal pure returns (bytes memory) {
        return abi.encodePacked("\x19Ethereum Signed Message:\n32", hash);
    }
}

/// @notice Forwarder for Meta Transactions Using EIP712 Signing Standard, also implement default Replay Protection using 2 dimensional nonces
contract EIP712Forwarder is Forwarder, ReplayProtection {

    // ///////////////////////////// FORWARDING EOA META TRANSACTION ///////////////////////////////////

    bytes4 internal constant ERC1271_MAGICVALUE = 0x20c13b0b;
    bytes4 internal constant ERC1654_MAGICVALUE = 0x1626ba7e;

    /// @notice forward call from EOA signed message
    /// @param message.from address from which the message come from (For EOA this is the same as signer)
    /// @param message.to target of the call
    /// @param message.replayProtection contract address that check and update nonce
    /// @param message.nonce nonce value
    /// @param message.data call data
    /// @param message.innerMessageHash extra data hashed that can be used as embedded message for implementing more complex scenario, with one sig
    /// @param signatureType signatureType either EOA, EIP1271 or EIP1654
    /// @param signature signature
    function forward(
        Message memory message,
        SignatureType signatureType,
        bytes memory signature
    ) public override payable { // external with ABIEncoderV2 Struct is not supported in solidity < 0.6.4
        require(_isValidChainId(message.chainId), "INVALID_CHAIN_ID");
        _checkSigner(message, signatureType, signature);
        // optimization to avoid call if using default nonce strategy
        // this contract implements a default nonce strategy and can be called directly
        if (message.replayProtection == address(0) || message.replayProtection == address(this)) {
            require(checkAndUpdateNonce(message.from, message.nonce), "NONCE_INVALID");
        } else {
            require(ReplayProtection(message.replayProtection).checkAndUpdateNonce(message.from, message.nonce), "NONCE_INVALID");
        }

        _call(message.from, message.to, msg.value, message.data);
    }


    // /////////////////////////////////// BATCH CALL /////////////////////////////////////

    struct Call {
        address to;
        bytes data;
        uint256 value;
    }

    /// @notice batcher function that can be called as part of a meta transaction (allowing to batch call atomically)
    /// @param calls list of call data and destination
    function batch(Call[] memory calls) public payable { // external with ABIEncoderV2 Struct is not supported in solidity < 0.6.4
        require(msg.sender == address(this), "FORWARDER_ONLY");
        address signer;
        bytes memory data = msg.data;
        uint256 length = msg.data.length;
        assembly { signer := and(mload(sub(add(data, length), 0x00)), 0xffffffffffffffffffffffffffffffffffffffff) }
        for(uint256 i = 0; i < calls.length; i++) {
            _call(signer, calls[i].to, calls[i].value, calls[i].data);
        }
    }

    // /////////////////////////////////// REPLAY PROTECTION /////////////////////////////////////

    mapping(address => mapping(uint128 => uint128)) _batches;

    /// @notice implement a default nonce stategy
    /// @param signer address to check and update nonce for
    /// @param nonce value of nonce sent as part of the forward call
    function checkAndUpdateNonce(address signer, bytes memory nonce) public override returns (bool) {
        // TODO? default nonce strategy could be different (maybe the most versatile : batchId + Nonce)
        uint256 value = abi.decode(nonce, (uint256));
        uint128 batchId = uint128(value / 2**128);
        uint128 batchNonce = uint128(value % 2**128);

        uint128 currentNonce = _batches[signer][batchId];
        if (batchNonce == currentNonce) {
            _batches[signer][batchId] = currentNonce + 1;
            return true;
        }
        return false;
    }

    function getNonce(address signer, uint128 batchId) external view returns (uint128) {
        return _batches[signer][batchId];
    }


    // ///////////////////////////////// INTERNAL ////////////////////////////////////////////

    function _call(
        address from,
        address to,
        uint256 value,
        bytes memory data
    ) internal {
        (bool success,) = to.call.value(value)(abi.encodePacked(data, from));
        if (!success) {
            assembly {
                let returnDataSize := returndatasize()
                returndatacopy(0, 0, returnDataSize)
                revert(0, returnDataSize)
            }
        }
    }

    function _checkSigner(
        Message memory message,
        SignatureType signatureType,
        bytes memory signature
    ) internal view returns (address) {
        bytes memory dataToHash = _encodeMessage(message);
        if (signatureType == SignatureType.EIP1271) {
            require(ERC1271(message.from).isValidSignature(dataToHash, signature) == ERC1271_MAGICVALUE, "SIGNATURE_1271_INVALID");
        } else if(signatureType == SignatureType.EIP1654){
            require(ERC1654(message.from).isValidSignature(keccak256(dataToHash), signature) == ERC1654_MAGICVALUE, "SIGNATURE_1654_INVALID");
        } else {
            address signer = SigUtil.recover(keccak256(dataToHash), signature);
            require(signer == message.from, "SIGNATURE_WRONG_SIGNER");
        }
    }

    function _isValidChainId(uint256 chainId) internal view returns (bool) {
        uint256 _chainId;
        assembly {_chainId := chainid() }
        return chainId == _chainId;
    }

    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(
        "EIP712Domain(string name,string version)"
    );
    bytes32 constant DOMAIN_SEPARATOR = keccak256(
        abi.encode(
            EIP712DOMAIN_TYPEHASH,
            keccak256("Forwarder"),
            keccak256("1")
        )
    );

    bytes32 constant METATRANSACTION_TYPEHASH = keccak256(
        "MetaTransaction(address from,address to,uint256 value,uint256 chainId,address replayProtection,bytes nonce,bytes data,bytes32 innerMessageHash)"
    );

    function _encodeMessage(Message memory message) internal view returns (bytes memory) {
        return abi.encodePacked(
            "\x19\x01",
            DOMAIN_SEPARATOR,
            keccak256(abi.encode(
                METATRANSACTION_TYPEHASH,
                message.from,
                message.to,
                msg.value,
                message.chainId,
                message.replayProtection,
                keccak256(message.nonce),
                keccak256(message.data),
                message.innerMessageHash
            ))
        );
    }
}
```

## Security Considerations

The Security of the proposal relies on the safety of the contract implementation only. One of the reason, native meta transaction has not taken off is that contract creator have to trust a specific mechanism. The proposal aims to be a minimal meta transaction implementation.


## References

- [EIP-1776](https://github.com/ethereum/EIPs/issues/1776)
- [EIP-1613](https://eips.ethereum.org/EIPS/eip-1613)
- [EIP-1077](https://eips.ethereum.org/EIPS/eip-1077)
- [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)
- [EIP-1654](https://github.com/ethereum/EIPs/issues/1654)
- [EIP-1344](https://eips.ethereum.org/EIPS/eip-1344)
- [EIP-1965](https://eips.ethereum.org/EIPS/eip-1965)
- [EIP-1930](https://eips.ethereum.org/EIPS/eip-1930)

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
