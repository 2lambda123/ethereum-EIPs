---
eip: 3779
title: Safe Control Flow for the EVM
description: Introduces contract validation rules for jumps and stack depth that are applied at deploy time.
status: Draft
type: Standards Track
category: Core
author: Greg Colvin (@gcolvin), Greg Colvin <greg@colvin.org>
discussions-to: https://ethereum-magicians.org/t/eip-3779-safe-control-flow-for-the-evm/6975
created: 2021-08-30
requires: 3540
---

## Abstract

This EIP specifies validation rules for some important safety properties, including
* valid jump destinations,
* valid instructions,
* no stack underflows, and
* no stack overflows without recursion.

Valid contracts will not halt with an exception unless they either run out of gas or overflow stack during a recursive subroutine call.

Code is validated at contract creation time – not runtime – by the provided algorithm.  This is a one-pass algorithm, linear in the size of the bytecode, so as not to be a DoS surface.

## Motivation

Validating safe control flow at creation time has a few important advantages.
* Jump destination analysis does not need to be performed at runtime, thus improving performance and preventing denial of service attacks.
* Jump destination validity does not need to be checked for at runtime, improving performance.
* Stack underflow does not need to be checked for at runtime, improving performance.

Consider this example of calling a minimal subroutine.
```
ADD:
    RTN_ADD 
    0x02
    0x03
    ADDITION
    jump
RTN_ADD:
    jumpdest

ADDITION:
    jumpdest
    add
    swap1
    jump 
```
 We do not need dynamic jumps to implement subroutines.  Note that the return address and the destination address are pushed on the stack as constants, so the `JUMP` instruction are static, not dynamic – they jump to the same `PC` with every run.  Since the jumps are static we can validate their safety with a static analysis of the code.

## Specification

### Dependencies

We need [EIP-3540: EVM Object Format (EOF)](./eip-3540.md) to deprecate dynamic use of JUMP and JUMPI and forbid invalid instructions.

### Validity

We define safety here as avoiding exceptional halting states:
* Valid contracts will not halt with an exception unless they
   * run out of gas or
   * overflow stack without making a recursive subroutine call.

Attempts to create contracts that cannot be proven to be valid will fail.

#### Exceptional Halting States

_Execution_ is as defined in the [Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)  a sequence of changes to the EVM state.  The conditions on valid code are preserved by state changes.  At runtime, if execution of an instruction would violate a condition the execution is in an exceptional halting state.  The Yellow Paper defines five such states.
1. Insufficient gas
2. More than 1024 stack items
3. Insufficient stack items
4. Invalid jump destination
5. Invalid instruction

We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state, but we must be able to validate code in linear time to avoid denial of service attacks.  So in practice, we can only partially meet these requirements.  Our validation algorithm does not consider the codes data and computations, only its control flow and stack use.  This means we will reject programs with any invalid code paths, even if those paths are not reachable at runtime.   Further, conditions _1_ and _2_  Insufficient gas and stack overflow  must in general be checked at runtime.  Conditions _3_, _4_, and _5_ cannot occur if the code conforms to the following rules.

#### The Rules

1. `JUMP` and `JUMPI` address only constant, valid `JUMPDEST` instructions.
2. The `stack depth` at the end of  a _basic block_ is always always positive.
3. The `stack pointer` is at most 1024.

We need to define `stack depth`.  The Yellow Paper has the `stack pointer` (`SP`) pointing just past the top item on the `data stack`.   We define the `stack base` as the element that the `SP` addressed at the entry to the current _basic block_, or `0` on program entry.  So we can define the `stack depth` as the number of stack elements between the current `SP` and the current `stack base`.  

#### The Algorithm 

The following is a pseudo-Go implementation of an algorithm for enforcing program validity.  This algorithm is a symbolic execution of the program that recursively traverses the bytecode, following its control flow and stack use and checking for violations of the rules above. 

This algorithm runs in time equal to `O(vertices + edges)` in the program's control-flow graph, where vertices represent control-flow instructions and the edges represent basic blocks  thus the algorithm takes time proportional to the size of the bytecode.

For simplicity's sake:
* We assume an `advance_pc()` routine to skip immediate data.
* We assume `add_items()` and `remove_items()` functions that push or pop items and return the effect of each instruction on the `stack pointer`.  `add_items()` will `PUSH` the value of constants – all other stack items are zeroed.
```
	var bytecode [code_len]byte
	var stack_depth [code_len]unsigned
	var stack[1024]unsigned
	var SP := 0

	func validate(PC :=0, stack_depth:=0) boolean {

		// valid instructions only
		if !valid_instruction(bytecode[PC]) {
			return false;
		}

		// if stack depth for `PC` is non-zero we have been here before 
		// return true to break cycle in control flow graph
		if stack_depth[PC] != 0 { 
			return true
		}
		stack_depth[PC] = stack_depth
		entrySP := SP

		if instruction == JUMP {

			// check for valid destination
			jumpdest = stack[SP]
			if bytecode[jumpdest] != JUMPDEST {
				return false
			}

			// reset PC to destination of jump 
			PC += jumpdest
			continue
		}
		if instruction == JUMPI {

			// check for valid destination
			jumpdest = stack[SP]
			if bytecode[jumpdest] != JUMPDEST {
				return false
			}

			// reset PC to destination of jump 
			PC += jumpdest

			// check for stack underflow and
			// recurse to jump to code to validate
			stack_depth := SP - entry_SP
			if stack_depth < 0 { 
				return false
			}
			if !validate(stack[SP]), stack_depth {
				return false
			}
			continue 
		}
 
		// check effect of instruction on stack
		SP -= remove_items(instruction)
		SP += add_items(instruction)
		if SP < 0 || 1024 < SP {
			return false
		}

		// successful validation of path
		if PC > code_len ||
	       instruction == STOP || 
		   instruction == RETURN ||
		   instruction == SUICIDE {
		   
		    return true
		}

		// advance PC according to instruction
		PC = advance_pc(PC, instruction)
	}
```

## Rationale

The alternative to checking validity at creation time is checking it at runtime.  This hurts performance and is a DoS vulnerability.  Thus the above rules and accompanying validation algorithm.

_Rule 1_, requiring constant destinations for `JUMP` and `JUMPI`, forbids dynamic jumps.  This rule is required by `EIP-3540`.  Further, jump destinations are currently checked at runtime.  Static jumps allow them to be validated at creation time, per _Rule 1_.   Nonetheless, valid subroutine code can still be created with these instructions, as shown above. _Note: Valid instructions are not part of immediate data._  

Given our definition of `stack depth`, _Rule 2_ ensures that basic_blocks always have sufficient stack.  Exceptions can be caused by irreducible paths like jumping into loops and subroutines, and by calling subroutines with insufficient numbers of arguments.  Taken together, these rules allow for code to be validated  by following the control-flow graph, traversing each edge only once.

Finally, _Rule 3_ catches all stack overflows that occur without recursion.

## Backwards Compatibility

These changes affect the semantics of existing EVM code – the [EVM Object Format](./eip-3540.md) deprecates dynamic use of JUMP and JUMPI.  Contracts that make only static use of JUMP and JUMPI remain valid.  Most contracts do not use dynamic jumps.

## Security Considerations

Safety and amenability to static analysis of valid programs are comparable to [EIP-615](./eip-615.md),  without imposing syntactic constraints.  Validity can ensured by following the rules given previously, and programs can be validated with the provided algorithm.  The validation algorithm is simple and bounded by the size of the code, allowing for validation at creation time and preventing DoS attacks.  Compilers can easily follow the rules, and in most cases already do.
 
## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
