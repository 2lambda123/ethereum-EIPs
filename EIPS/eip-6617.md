---
eip: 6617
title: Bit Based Permission
description: A permission and role system based on bits
author: Chiro (@chiro-hiro), Victor Dusart (@vdusart)
discussions-to: https://ethereum-magicians.org/t/bit-based-permission/13065
status: Review
type: Standards Track
category: ERC
created: 2023-02-27
---

## Abstract

This EIP offers a standard for building a bit-based permission and role system. Each permission is represented by a single bit. By using an `uint256`, up to $256$ permissions and $2^{256}$ roles can be defined. We are able to specify the importance of each permission based on the order of the bits.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

_Note_ The following specifications use syntax from Solidity `0.8.7` (or above)

- Permission and role MUST be defined as an `uint256`
- Permission MUST be defined as a power of two
- Permission MUST be unique
- `0` MUST be used for none permission

```solidity
pragma solidity ^0.8.7;

/**
    @title EIP-6617 Bit Based Permission
    @dev See https://eips.ethereum.org/EIPS/eip-6617
*/
library EIP6617 {
    /**
        @notice Check if _permission is a superset of _requiredPermission
        @param _permission          The given permission
        @param _requiredPermission  The required permission
        @return                     True if the _permission is a superset of the _requiredPermission else False
    */
    function permissionCheck(uint256 _permission, uint256 _requiredPermission)
        internal
        pure
        returns (bool)
    {
        return _permission & _requiredPermission == _requiredPermission;
    }

    /**
        @notice Add permission
        @param _permission          The given permission
        @param _permissionToAdd     The permission that will be added
        @return                     The new permission with the _permissionToAdd
    */
    function permissionGrant(uint256 _permission, uint256 _permissionToAdd)
        internal
        pure
        returns (uint256)
    {
        return _permission | _permissionToAdd;
    }

    /**
        @notice Remove permission
        @param _permission          The given permission
        @param _permissionToRemove  The permission that will be removed
        @return                     The new permission without the _permissionToRemove
    */
    function permissionRevoke(uint256 _permission, uint256 _permissionToRemove)
        internal
        pure
        returns (uint256)
    {
        return (_permission | _permissionToRemove) ^ _permissionToRemove;
    }
}
```

### Metadata Interface

It is RECOMMENDED for compliant contracts to implement the optional extension `IEIP6617Meta`.

SHOULD define a name and description for the base permissions and main combinaison.

SHOULD NOT define a description for every subcombinaison of permissions possible.

```solidity
/**
 * @dev Defined the interface of the metadata of EIP6617, MAY NOT be implemented
 */
interface IEIP6617Meta {
  /**
   * Structure of permission description
   * @param _permission     Permission
   * @param _name           Name of the permission
   * @param _description    Description of the permission
   */
  struct PermissionDescription {
    uint256 permission;
    string name;
    string description;
  }

  /**
   * MUST trigger when the description is updated.
   * @param _permission     Permission
   * @param _name           Name of the permission
   * @param _description    Description of the permission
   */
  event UpdatePermissionDescription(uint256 indexed _permission, string indexed _name, string indexed _description);

  /**
   * Returns the description of a given `_permission`.
   * @param _permission     Permission
   */
  function getDescription(uint256 _permission) external view returns (PermissionDescription memory description);

  /**
   * Return `true` if the description was set otherwise return `false`. It MUST emit `UpdatePermissionDescription` event.
   * @param _permission     Permission
   * @param _name           Name of the permission
   * @param _description    Description of the permission
   */
  function setDescription(
    uint256 _permission,
    string memory _name,
    string memory _description
  ) external returns (bool success);
}
```

## Rationale

Currently permission and access control is performed using a single owner ([ERC-173](./eip-173.md)) or with `bytes32` roles ([ERC-5982](./eip-5982.md)).
However, using bitwise and bitmask operations allows for greater gas-efficiency and flexibility.

### Gas cost efficiency

Bitwise operations are very cheap and fast. For example, doing an `AND` bitwise operation on a permission bitmask is significantly cheaper than calling any number of `LOAD` opcodes.

### Flexibility

With the 256 bits of the `uint256`, we can create up to 256 different permissions which leads to $2^{256}$ unique combinations (a.k.a. roles).
_(A role is a combination of multiple permissions)._ Not all roles have to be predefined.

Since permissions are defined as unsigned integers, we can use the binary OR operator to create new role based on multiple permissions.

### Ordering permissions by importance

We can use the most significant bit to represent the most important permission, the comparison between permissions can then be done easily since they all are `uint256`s.

### Associate a meaning

Compared with access control managed via ERC-5982, this EIP does not provide a direct and simple understanding of the meaning of a permission or role.

To deal with this problem, you can set up the metadata interface, which associates a name and description to each permission or role. 

## Test Cases

```solidity
pragma solidity ^0.8.7;

import "EIP6617.sol";
import "EIP6617Meta.sol";

contract Test is EIP6617Meta {
    using EIP6617 for uint256;

    uint256 public constant PERMISSION_NONE = 0;
    uint256 public constant PERMISSION_READ = 1;     // 2⁰
    uint256 public constant PERMISSION_WRITE = 2;    // 2¹
    uint256 public constant PERMISSION_EXECUTE = 4;  // 2²

    // Role operator = 1 | 2 = 3
    uint256 public constant ROLE_OPERATOR = PERMISSION_READ | PERMISSION_WRITE;

    // Role admin = 1 | 2 | 4 = 7
    uint256 public constant ROLE_ADMIN = PERMISSION_READ | PERMISSION_WRITE | PERMISSION_EXECUTE;

    constructor() {
        _setDescription(
            PERMISSION_NONE,
            "PERMISSION_NONE",
            "No permission"
        );
        _setDescription(
            PERMISSION_READ,
            "PERMISSION_READ",
            "Permission owner can read data"
        );
        _setDescription(
            PERMISSION_WRITE,
            "PERMISSION_WRITE",
            "Permission owner can write data"
        );
        _setDescription(
            PERMISSION_EXECUTE,
            "PERMISSION_EXECUTE",
            "Permission owner can execute"
        );
        _setDescription(
            ROLE_ADMIN,
            "ROLE_ADMIN",
            "Admin role can read, write and execute"
        );
        _setDescription(
            ROLE_OPERATOR,
            "ROLE_OPERATOR",
            "Operator role can read and write"
        );
    }

    function testPermissions() external pure returns (uint256) {
        uint256 userPermission;

        // adding read permission
        userPermission = userPermission.permissionGrant(PERMISSION_READ);

        // adding admin role
        userPermission = userPermission.permissionGrant(ROLE_ADMIN);

        // removing execute permission
    	userPermission = userPermission.permissionRevoke(PERMISSION_EXECUTE);

        // Checking permission
        if (userPermission.permissionCheck(ROLE_ADMIN)) {
            // Only admin can access this part
        }

        return userPermission;
    }
}
```

## Reference Implementation

First implementation could be found here:

- [ERC-6617 Meta implementation](../assets/eip-6617/contracts/EIP6617Meta.sol)

## Security Considerations

No security considerations.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
