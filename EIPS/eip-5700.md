---
eip: 5700
title: Bindable Token Standard
author: Leeren <leeren@dopamine.xyz>
type: Standards Track
category: ERC
status: Draft
created: 2022-09-18
discussions-to: https://ethereum-magicians.org/t/EIP-4400-EIP721consumer-extension/7371
requires: 165, 721, 1155
---

## Simple Summary

Described below is a standard for allowing fungible and non-fungible tokens to be bound to unique assets. These tokens, once bound, may not be directly transferred, instead having their ownership and tracking delegated through the assets to which they are bound to, and may be unbound at any time.

## Abstract

The proposed standard defines an interface by which fungible and non-fungible tokens may be bound to arbitrary assets (typically represented as NFTs themselves), enabling token ownership, transfer, and balance attribution to be proxied through the assets they are bound to. 

A bindable token ("bindable") is an EIP-721 or EIP-1155 token which, when bound to an asset, remains owned by the bound asset owner and can only be transferred as a result of its bound asset being transferred, and, when unbound, functions normally according to its base token implementation.

To enable coupling with any kinds of assets, an asset being bound to ("binder") has few restrictions on how it is represented, except that it be unique and interfaceable through a contract that can answer to queries around asset ownership. Bindable tokens and the assets to which they are bound to form a many-to-one relationship.

Below are example use-cases that benefit from such a standard:

- Physical assets packaged with digital collectibles - microchipped streetwear bundles, digitized automobile collections, digitally-twinned real-estate property
- NFT-bundled digital assets - accessorizable virtual wardrobes, composable music tracks, customizable metaverse land

## Motivation

A standard interface for token binding allows tokens to be bundled with other assets (most commonly represented as NFTs themselves) in a way that is easily integrable with wallets, marketplaces, and other NFT applications, and avoids the need for ad-hoc ownership attribution strategies that are neither flexible nor backwards-compatible.

Unlike other standards tackling delegated ownership attribution, which look at increasing composability on the account level, this standard addresses composability on the asset level, with the goal of creating a universal interface for token modularity that is compatible with existing EIP-721 and EIP-1155 standards.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

### ERC-721 Bindable

**Smart contracts implementing the ERC-721 Bindable standard MUST implement the `IERC721Bindable` interface.**

**Smart contracts implementing the ERC-721 Bindable standard MUST return the constant value `true` if `xxx` is passed as the interface id argument to the ERC-165 `supportsInterface` function.**

```solidity
pragma solidity ^0.8.16;

/// @title ERC-721 Bindable Token Standard
/// @dev See https://eips.ethereum.org/EIPS/eip-5656
///  Note: the ERC-165 identifier for this interface is 0xxxxxx
interface IERC721Bindable /* is IERC721 */ {

	/// @notice The `Bind` event MUST emit when NFT ownership is delegated
	///  through an asset and when minting an NFT bound to an existing asset.
	/// @dev When minting bound NFTs, `from` MUST be set to the zero address.
	/// @param operator The address calling the bind (SHOULD be `msg.sender`).
	/// @param from The address which owns the unbound NFT.
	/// @param to The address which owns the asset being bound to.
	/// @param tokenId The identifier of the NFT being bound.
	/// @param bindId The identifier of the asset being bound to.
	/// @param bindAddress The contract address handling asset ownership.
    event Bind(
        address indexed operator,
        address indexed from,
        address to,
        uint256 tokenId,
        uint256 bindId,
        address indexed bindAddress
    )

    /// @notice The `Unbind` event MUST emit when asset-delegated NFT ownership 
	///  is revoked, as well as when burning an NFT bound to an existing asset.
	/// @dev When burning bound NFTs, `to` MUST be set to the zero address.
	/// @param operator The address calling the unbind (SHOULD be `msg.sender`).
	/// @param from The address which owns the asset the NFT is bound to.
	/// @param to The address which will own the NFT once unbound.
	/// @param tokenId The identifier of the NFT being unbound.
	/// @param bindId The identifier of the asset being unbound from.
	/// @param bindAddress The contract address handling bound asset ownership.
    event Unbind(
        address indexed operator,
        address indexed from,
        address to,
        uint256 tokenId,
        uint256 bindId,
        address indexed bindAddress
    )

	/// @notice Delegates NFT ownership of NFT `tokenId` from address `from`
	///  through the asset `bindId` owned by address `to`.
	/// @dev The function MUST throw unless `msg.sender` is the current owner, 
	///  an authorized operator, or the approved address for the NFT. It also
	///  MUST throw if NFT `tokenId` is already bound, if `from` is not the NFT 
	///  owner, or if `to` is not the asset owner. After ownership delegation, 
    ///  the function MUST check if `bindAddress` is a valid contract (code size
    ///  > 0), and if so, call `onERC721Bind` on the contract, throwing if the 
    ///  wrong identifier is returned (see "Binding Rules") or if the contract 
    ///  is invalid. On bind completion, the function MUST emit both `Bind` and 
    ///  IERC-721 `Transfer` events to reflect delegated ownership change.
	/// @param from The address which owns the unbound NFT.
	/// @param to The address which owns the asset being bound to.
	/// @param tokenId The identifier of the NFT being bound.
	/// @param bindId The identifier of the asset being bound to.
	/// @param bindAddress The contract address handling asset ownership.
    /// @param data Additional data sent with the `onERC721Bind` hook.
    function bind(
        address from,
        address to,
        uint256 tokenId,
        uint256 amount,
        uint256 bindId,
        address bindAddress,
        bytes calldata data
    ) external;

	/// @dev The function MUST throw unless `msg.sender` is an approved operator
    ///  or owner of the delegated asset. It also MUST throw if NFT `tokenId` is
    ///  not bound, if `from` is not the asset owner, or if `to` is the zero 
    ///  address. After ownership transition, the function MUST check if 
    ///  `bindAddress` is a valid contract (code size > 0), and if so, call 
    ///  `onERC721Unbind` the contract, throwing if the wrong identifier is 
    ///  returned (see "Binding Rules") or if the contract is invalid. 
    ///  The function also MUST check if `to` is a valid contract, and if so, 
    ///  call `onERC721Received`, throwing if the wrong identifier is returned.
    ///  On unbind completion, the function MUST emit both `Unbind` and IERC-721 
    ///  `Transfer` events to reflect delegated ownership change.
	/// @param from The address which owns the asset the NFT is bound to.
	/// @param to The address which will own the NFT once unbound.
	/// @param tokenId The identifier of the NFT being unbound.
	/// @param bindId The identifier of the asset being unbound from.
	/// @param bindAddress The contract address handling bound asset ownership.
    /// @param data Additional data sent with the `onERC721Unbind` hook.
    function unbind(
        address from,
        address to,
        uint256 tokenId,
        uint256 bindId,
        address bindAddress,
        bytes calldata data
    ) external;

    /// @notice Counts total bound and unbound NFTs owned by address `owner`.
	/// @dev This function MUST throw for queries around the zero address.
    /// @param owner The address whose NFT ownership is being queried.
    /// @return The total number of bound and unbound NFTs owned by `owner`.
    function balanceOf(address owner) external view returns (uint256);

    /// @notice Gets the owner address of NFT of id `tokenId`. When an NFT is
	///  bound, its owner corresponds to that of the asset which it is bound to.
	/// @dev This function MUST throw for NFTs assigned to the zero address.
	/// @param tokenId The identifier of the NFT whose ownership is queried.
    /// @return The address of the owner of the NFT.
    function ownerOf(uint256 tokenId) external returns (address);

```

**Smart contracts representing assets MUST implement the `IERC721Binder` interface if they are to accept binds.**

```solidity
pragma solidity ^0.8.16;

/// @dev Note: the ERC-165 identifier for this interface is 0xxxxxx
interface IERC721Binder /* is IERC165 */ {

	/// @notice Handles the binding of an IERC721Bindable-compliant NFT.
	/// @dev An IERC721Bindable-compliant smart contract MUST call this function
	///  at the end of a `bind` after delegating ownership to the asset owner.
	///  The function MUST revert if `to` is not the asset owner of `bindId` or 
    ///  if asset `bindId` is not a valid asset. The function MUST revert if it 
    ///  rejects the bind. If accepting the bind, the function MUST return 
    /// `bytes4(keccak256("onERC721Bind(address,address,address,uint256,uint256,bytes)"))`
	///  Caller MUST revert the transaction if the above value is not returned.
	///  Note: The contract address of the binding NFT is `msg.sender`.
	/// @param operator The address responsible for initiating the bind.
	/// @param from The address which owns the unbound NFT.
	/// @param to The address which owns the asset being bound to.
	/// @param tokenId The identifier of the NFT being bound.
	/// @param bindId The identifier of the asset being bound to.
    /// @param data Additional data sent along with no specified format.
	/// @return `bytes4(keccak256("onERC721Bind(address,address,address,uint256,uint256,bytes)"))`
	function onERC721Bind(
			address operator,
			address from,
			address to,
			uint256 tokenId,
			uint256 bindId,
			bytes calldata data
	) external returns (bytes4);

	/// @notice Handles the unbinding of an IERC721Bindable-compliant NFT.
	/// @dev An IERC721Bindable-compliant smart contract MUST call this function
	///  at the end of an `unbind` after revoking delegated asset ownership.
	///  The function MUST revert if `from` is not the asset owner of `bindId`
    ///  or if `bindId` is not a valid asset. The function MUST revert if it 
    ///  rejects the unbind. If accepting the unbind, the function MUST return
    ///  `bytes4(keccak256("onERC721Unbind(address,address,address,uint256,uint256,bytes)"))`
	///  Caller MUST revert the transaction if the above value is not returned.
	///  Note: The contract address of the unbinding NFT is `msg.sender`.
	/// @param from The address which owns the asset the NFT is bound to.
	/// @param to The address which will own the NFT once unbound.
	/// @param tokenId The identifier of the NFT being unbound.
	/// @param bindId The identifier of the asset being unbound from.
    /// @param data Additional data with no specified format.
	/// @return `bytes4(keccak256("onERC721Unbind(address,address,address,uint256,uint256,bytes)"))`
	function onERC721Unbind(
			address operator,
			address from,
			address to,
			uint256 tokenId,
			uint256 bindId,
			bytes calldata data
	) external returns (bytes4);

    /// @notice Gets the owner address of the asset represented by id `bindId`.
	/// @param bindId The identifier of the asset whose owner is being queried.
    /// @return The address of the owner of the asset.
	function ownerOf(uint256 bindId) external view returns (address);

    /// @notice Checks if an operator can act on behalf of an asset owner.
    /// @param owner The address that owns an asset.
    /// @param operator The address that acts on behalf of owner `owner`.
    /// @return True if `operator` can act on behalf of `owner`, else False.
    function isApprovedForAll(address owner, address operator) external view returns (boolean);

```

The **binder owner extension* is OPTIONAL for IERC721Binder smart contracts. This enables querying for all asset-bound NFT balances of a specific contract assigned to an owner, as well as asset owners and their operators.

```solidity
pragma solidity ^0.8.16;

/// @dev Note: the ERC-165 identifier for this interface is 0xxxxxx
interface IERC721BinderOwner /* is IERC721Binder */ {

	/// @notice Counts all bound NFTs of contract `token` owned by `owner`.
	/// @param token The bound NFT contract address.
	/// @param owner The address whose bound NFT balance is being queried.
	/// @return The count of bound NFTs of contract `token` owned by `owner`.
	function boundBalanceOf(address token, address owner) external view returns (uint256);
```

### ERC-1155 Bindable

**Smart contracts implementing the ERC-1155 Bindable standard MUST implement the `IERC1155Bindable` interface.**

**Smart contracts implementing the ERC-1155 Bindable standard MUST return the constant value `true` if `xxx` is passed as the interface id argument to the ERC-165 `supportsInterface` function.**

```solidity
pragma solidity ^0.8.16;

/// @title ERC-1155 Bindable Token Standard
/// @dev See https://eips.ethereum.org/EIPS/eip-5656
///  Note: the ERC-165 identifier for this interface is 0xxxxxx
interface IERC1155Bindable /* is IERC1155 */ {

	/// @notice The `Bind` event MUST emit when token ownership is delegated
	///  through an asset and when minting tokens bound to an existing asset.
	/// @dev When minting bound tokens, `from` MUST be set to the zero address.
	/// @param operator The address calling the bind (SHOULD be `msg.sender`).
	/// @param from The address which owns the unbound token(s).
	/// @param to The address which owns the asset being bound to.
	/// @param tokenId The identifier of the token type being bound.
	/// @param amount The number of tokens of type `tokenId` being bound.
	/// @param bindId The identifier of the asset being bound to.
	/// @param bindAddress The contract address handling asset ownership.
    event Bind(
        address indexed operator,
        address indexed from,
        address to,
        uint256 tokenId,
		uint256 amount,
        uint256 bindId,
        address indexed bindAddress
    )

	/// @notice The `BindBatch` event MUST emit when token ownership of 
	///  different token types are delegated through different assets at once
	///  and when minting multiple token types bound to existing assets at once.
	/// @dev When minting bound tokens, `from` MUST be set to the zero address.
	/// @param operator The address calling the bind (SHOULD be `msg.sender`).
	/// @param from The address which owns the unbound token(s).
	/// @param to The address which owns the asset being bound to.
	/// @param tokenIds The identifiers of the token types being bound.
	/// @param amounts The number of tokens for each token type being bound.
	/// @param bindIds The identifiers of the assets being bound to.
	/// @param bindAddress The contract address handling asset ownership.
    event BindBatch(
        address indexed operator,
        address indexed from,
        address to,
        uint256[] calldata tokenIds,
        uint256[] calldata amounts,
        uint256[] bindIds,
        address indexed bindAddress
    )

    /// @notice The `Unbind` event MUST emit when asset-delegated token 
	///  ownership is revoked and when burning tokens bound to existing assets.
	/// @dev When burning bound tokens, `to` MUST be set to the zero address.
	/// @param operator The address calling the unbind (SHOULD be `msg.sender`).
	/// @param from The address which owns the asset the token(s) are bound to.
	/// @param to The address which will own the token(s) once unbound.
	/// @param tokenId The identifier of the token type being unbound.
	/// @param amount The number of tokens of type `tokenId` being unbound.
	/// @param bindId The identifier of the asset being unbound from.
	/// @param bindAddress The contract address handling bound asset ownership.
    event Unbind(
        address indexed operator,
        address indexed from,
        address to,
        uint256 tokenId,
        uint256 bindId,
        address indexed bindAddress
    )

    /// @notice The `UnbindBatch` event MUST emit when asset-delegated token 
	///  ownership is revoked for multiple token types at once and when burning 
	///  multiple token types bound to existing assets at once.
	/// @dev When burning bound tokens, `to` MUST be set to the zero address.
	/// @param operator The address calling the unbind (SHOULD be `msg.sender`).
	/// @param from The address which owns the asset the token(s) are bound to.
	/// @param to The address which will own the token(s) once unbound.
	/// @param tokenIds The identifiers of the token types being unbound.
	/// @param amounts The number of tokens for each token type being unbound.
	/// @param bindIds The identifier of the assets being unbound from.
	/// @param bindAddress The contract address handling bound asset ownership.
    event UnbindBatch(
        address indexed operator,
        address indexed from,
        address to,
        uint256[] calldata tokenIds,
        uint256[] calldata amounts,
        uint256[] bindIds,
        address indexed bindAddress
    )

	/// @notice Delegates ownership of `amount` tokens of type `tokenId` from 
	///  address `from` through asset `bindId` owned by address `to`.
	/// @dev The function MUST throw unless `msg.sender` is an approved operator
	///  for `from`. The function also MUST throw if `from` owns fewer than 
    ///  `amount` unbound tokens, or if `to` is not the asset owner. After 
    ///  delegation of ownership, the function MUST check if `bindAddress` is a 
    ///  valid contract (code size > 0), and if so, call `onERC1155Bind` on the 
    ///  contract, throwing if the wrong identifier is returned (see "Binding 
    ///  Rules") or if the contract is invalid. On bind completion, the function
    ///  MUST emit both `Bind` and IERC-1155 `TransferSingle` events to reflect 
    ///  delegated ownership change.
	/// @param from The address which owns the unbound token(s).
	/// @param to The address which owns the asset being bound to.
	/// @param tokenId The identifier of the token type being bound.
	/// @param amount The number of tokens of type `tokenId` being bound.
	/// @param bindId The identifier of the asset being bound to.
	/// @param bindAddress The contract address handling asset ownership.
    /// @param data Additional data sent with the `onERC1155Bind` hook.
    function bind(
        address from,
        address to,
        uint256 tokenId,
        uint256 amount,
        uint256 bindId,
        address bindAddress,
        bytes calldata data
    ) external;

	/// @notice Delegates ownership of `amounts` tokens of types `tokenIds` from 
	///  address `from` through assets `bindIds` owned by address `to`.
	/// @dev The function MUST throw unless `msg.sender` is an approved operator
	///  for `from`. The function also MUST throw if length of `amounts` is not 
    ///  the same as `tokenIds` or `bindIds`, if any unbound balances of 
    ///  `tokenIds` for `from` is less than that of `amounts`, or if `to` is not
    ///  the asset owner. After delegating ownership, the function MUST check if 
    ///  `bindAddress` is a valid contract (code size > 0), and if so, call 
    ///  `onERC1155BatchBind` on the contract, throwing if the wrong identifier 
    ///  is returned (see "Binding Rules") or if the contract is invalid. On 
    ///  bind completion, the function MUST emit both `BindBatch` and IERC-1155 
    ///  `TransferBatch` events to reflect delegated ownership changes.
	/// @param from The address which owns the unbound tokens.
	/// @param to The address which owns the assets being bound to.
	/// @param tokenIds The identifiers of the token types being bound.
	/// @param amounts The number of tokens for each token type being bound.
	/// @param bindIds The identifiers of the assets being bound to.
	/// @param bindAddress The contract address handling asset ownership.
    /// @param data Additional data sent with the `onERC1155BatchBind` hook.
    function batchBind(
        address from,
        address to,
        uint256[] calldata tokenIds,
        uint256[] calldata amounts,
        uint256[] bindIds,
        address bindAddress,
        bytes calldata data
    ) external;

    /// @notice Revokes delegated ownership of `amount` tokens of type `tokenId`
	///  owned by `from` bound to `bindId`, binding direct ownership to `to`.
	/// @dev The function MUST throw unless `msg.sender` is an approved operator
    ///  or owner of the delegated asset. It also MUST throw if `from` owns
    ///  fewer than `amount` bound tokens, or if `to` is the zero address. Once
    ///  delegated ownership is revoked, the function MUST check if 
    ///  `bindAddress` is a valid contract (code size > 0), and if so, call 
    ///  `onERC1155Unbind` on the contract, throwing if the wrong identifier is 
    ///  returned (see "Binding Rules") or if the contract is invalid. The 
    ///  function also MUST check if `to` is a contract, and if so, call on it 
    ///  `onERC1155Received`, throwing if the wrong identifier is returned. On 
    ///  unbind completion, the function MUST emit both `Unbind` and IERC-1155 
    ///  `TransferSingle` events to reflect delegated ownership change.
	/// @param from The address which owns the asset the token(s) are bound to.
	/// @param to The address which will own the tokens once unbound.
	/// @param tokenId The identifier of the token type being unbound.
	/// @param amount The number of tokens of type `tokenId` being unbound.
	/// @param bindId The identifier of the asset being unbound from.
	/// @param bindAddress The contract address handling bound asset ownership.
    /// @param data Additional data sent with the `onERC1155Unbind` hook.
    function unbind(
        address from,
        address to,
        uint256 tokenId,
        uint256 amount,
		uint256 bindId,
		address bindAddress,
        bytes calldata data
    ) external;

    /// @notice Revokes delegated ownership of `amounts` tokens of `tokenIds`
	///  bound to assets `bindIds`, binding direct ownership to `to`.
	/// @dev The function MUST throw unless `msg.sender` is an approved operator
    ///  or owner of the delegated asset. It also MUST throw if the length of 
    ///  `amounts` is not the same as `tokenIds` or `bindIds`, if any bound 
    ///  balances of `tokenId` for `from` is less than that of `amounts`, or if 
    ///  `to` is the zero address. Once delegated ownership is revoked, the 
    ///  function MUST check if `bindAddress` is a valid contract (code size > 
    ///  0), and if so, call onERC1155BatchUnbind` on it, throwing if the wrong 
    ///  identifier is returned (see "Binding Rules") or if the contract is 
    ///  invalid. The function also MUST check if `to` is a valid contract, and 
    ///  if so, call `onERC1155BatchReceived`, throwing if the wrong identifier 
    ///  is returned. On unbind completion, the function MUST emit the 
    ///  `BatchUnbind` and IERC-1155 `TransferBatch` events to reflect delegated
    ///  ownership changes.
	/// @param from The address which owns the asset the tokens are bound to.
	/// @param to The address which will own the tokens once unbound.
	/// @param tokenIds The identifiers of the token types being unbound.
	/// @param amounts The number of tokens for each token type being unbound.
	/// @param bindIds The identifier of the assets being unbound from.
	/// @param bindAddress The contract address handling bound asset ownership.
    /// @param data Additional data sent with the `onERC1155BatchUnbind` hook.
    function batchUnbind(
        address from,
        address to,
        uint256[] calldata tokenIds,
        uint256[] calldata amounts,
		uint256[] calldata bindIds,
		address bindAddress,
        bytes calldata data
    ) external;

    /// @notice Gets the total balance of bound and unbound tokens of type
	///  `tokenId` owned by address `owner`.
    /// @param owner The address whose token ownership is being queried.
    /// @param tokenId The identifier for the token type being queried.
    /// @return The total number of bound and unbound tokens owned by `owner`.
    function balanceOf(address owner, uint256 tokenId) external view returns (uint256);

    /// @notice Gets the total balance of bound and unbound tokens for multiple
	///  token types given by `tokenIds` owned by addresses `owners`.
    /// @param owners The owner addresses of the token types being queried.
    /// @param tokenId The identifiers of the token types being queried.
    /// @return The count of bound and unbound tokens owned for each owner.
    function balanceOfBatch(
		address[] calldata owners,
		uint256[] calldata tokenIds
	) external view returns (uint256);

```

**Smart contracts representing assets MUST implement the `IERC1155Binder` interface if they are to accept binds.**

```solidity
pragma solidity ^0.8.16;

/// @dev Note: the ERC-165 identifier for this interface is 0xxxxxx
interface IERC1155Binder /* is IERC165 */ {

	/// @notice Handles binding of an IERC1155Bindable-compliant token type.
	/// @dev An IERC1155Bindable-compliant smart contract MUST call this 
	///  function at the end of a `bind` after delegating ownership to the asset 
	///  owner. The function MUST revert if `to` is not the asset owner of
    ///  `bindId`, or if `bindId` is not a valid asset. The function MUST revert
    ///  if it rejects the bind. If accepting the bind, the function MUST return
	///  `bytes4(keccak256("onERC1155Bind(address,address,address,uint256,uint256,uint256,bytes)"))`
	///  Caller MUST revert the transaction if the above value is not returned.
	///  Note: The contract address of the binding token is `msg.sender`.
	/// @param operator The address responsible for binding.
	/// @param from The address which owns the unbound tokens.
	/// @param to The address which owns the asset being bound to.
	/// @param tokenId The identifier of the token type being bound.
	/// @param bindId The identifier of the asset being bound to.
    /// @param data Additional data sent along with no specified format.
	/// @return `bytes4(keccak256("onERC1155Bind(address,address,address,uint256,uint256,uint256,bytes)"))`
	function onERC1155Bind(
        address operator,
        address from,
        address to,
        uint256 tokenId,
        uint256 amount,
        uint256 bindId,
        bytes calldata data
	) external returns (bytes4);

	/// @notice Handles binding of multiple IERC1155Bindable-compliant tokens 
    ///  `tokenIds` to multiple assets `bindIds`.
	/// @dev An IERC1155Bindable-compliant smart contract MUST call this 
	///  function at the end of a `batchBind` after delegating ownership of 
    ///  multiple token types to the asset owner. The function MUST revert if 
    ///  `to` is not the asset owner of `bindId`, or if `bindId` is not a valid 
    ///  asset. The function MUST revert if it rejects the binds. If accepting 
    ///  the binds, the function MUST return `bytes4(keccak256("onERC1155BatchBind(address,address,address,uint256[],uint256[],uint256[],bytes)"))`
	///  Caller MUST revert the transaction if the above value is not returned.
	///  Note: The contract address of the binding token is `msg.sender`.
	/// @param operator The address responsible for performing the binds.
	/// @param from The address which owns the unbound tokens.
	/// @param to The address which owns the assets being bound to.
	/// @param tokenIds The list of token types being bound.
	/// @param amounts The number of tokens for each token type being bound.
	/// @param bindIds The identifiers of the assets being bound to.
    /// @param data Additional data sent along with no specified format.
	/// @return `bytes4(keccak256("onERC1155Bind(address,address,address,uint256[],uint256[],uint256[],bytes)"))`
	function onERC1155BatchBind(
        address operator,
        address from,
        address to,
        uint256[] calldata tokenIds,
        uint256[] calldata amounts,
        uint256[] calldata bindIds,
        bytes calldata data
	) external returns (bytes4);

	/// @notice Handles unbinding of an IERC1155Bindable-compliant token type.
	/// @dev An IERC1155Bindable-compliant contract MUST call this function at
	///  the end of an `unbind` after revoking delegated asset ownership. The 
	///  function MUST revert if `from` is not the asset owner of `bindId`, 
	///  or if `bindId` is not a valid asset. The function MUST revert if it
	///  rejects the unbind. If accepting the unbind, the function MUST return
	///  `bytes4(keccak256("onERC1155Unbind(address,address,address,uint256,uint256,uint256,bytes)"))`
	///  Caller MUST revert the transaction if the above value is not returned.
	///  Note: The contract address of the unbinding token is `msg.sender`.
	/// @param operator The address responsible for performing the unbind.
	/// @param from The address which owns the asset the token type is bound to.
	/// @param to The address which will own the tokens once unbound.
	/// @param tokenId The token type being unbound.
	/// @param amount The number of tokens of type `tokenId` being unbound.
	/// @param bindId The identifier of the asset being unbound from.
    /// @param data Additional data sent along with no specified format.
	/// @return `bytes4(keccak256("onERC1155Unbind(address,address,address,uint256,uint256,uint256,bytes)"))`
	function onERC1155Unbind(
        address operator,
        address from,
        address to,
        uint256 tokenId,
        uint256 amount,
        uint256 bindId
        bytes calldata data
	) external returns (bytes4);

	/// @notice Handles unbinding of multiple IERC1155Bindable-compliant token types.
	/// @dev An IERC1155Bindable-compliant contract MUST call this function at
	///  the end of an `batchUnbind` after revoking delegated asset ownership. 
    ///  The function MUST revert if `from` is not the asset owner of `bindId`, 
	///  or if `bindId` is not a valid asset. The function MUST revert if it
	///  rejects the unbinds. If accepting the unbinds, the function MUST return
	///  `bytes4(keccak256("onERC1155Unbind(address,address,address,uint256[],uint256[],uint256[],bytes)"))`
	///  Caller MUST revert the transaction if the above value is not returned.
	///  Note: The contract address of the unbinding token is `msg.sender`.
	/// @param operator The address responsible for performing the unbinds.
	/// @param from The address which owns the assets being unbound from.
	/// @param to The address which will own the tokens once unbound.
	/// @param tokenIds The list of token types being unbound.
	/// @param amounts The number of tokens for each token type being unbound.
	/// @param bindIds The identifiers of the assets being unbound from.
    /// @param data Additional data sent along with no specified format.
	/// @return `bytes4(keccak256("onERC1155Unbind(address,address,address,uint256[],uint256[],uint256[],bytes)"))`
	function onERC1155BatchUnbind(
        address operator,
        address from,
        address to,
        uint256[] calldata tokenIds,
        uint256[] calldata amounts,
        uint256[] calldata bindIds,
        bytes calldata data
	) external returns (bytes4);

    /// @notice Gets the owner address of the asset represented by id `bindId`.
	/// @param bindId The identifier of the asset whose owner is being queried.
    /// @return The address of the owner of the asset.
	function ownerOf(uint256 bindId) external view returns (address);

    /// @notice Checks if an operator can act on behalf of an asset owner.
    /// @param owner The address that owns an asset.
    /// @param operator The address that acts on behalf of owner `owner`.
    /// @return True if `operator` can act on behalf of `owner`, else False.
    function isApprovedForAll(address owner, address operator) external view returns (boolean);

```

The **binder balance extension* is OPTIONAL for IERC1155Binder smart contracts. This enables querying for bound balances of specific token types of a token contract for an owner.

```solidity
pragma solidity ^0.8.16;

/// @dev Note: the ERC-165 identifier for this interface is 0xxxxxx
interface IERC1155BinderBalance /* is IERC1155Binder */ {

	/// @notice Counts the number of bound tokens of type `tokenId` belonging to
    ///  contract `token` owned by address `owner`.
	/// @param token The bound token contract address.
	/// @param owner The address whose bound token balance is being queried.
	/// @param tokenId The identifier of the bound token type.
	/// @return The number of bound tokens of type `tokenId` owned by `owner`.
	function boundBalanceOf(
        address token,
        address owner,
        uint2566 tokenId
    ) external view returns (uint256);

	/// @notice Gets the total balance of bound tokens for multiple token types
    ///  given by `tokenIds` owned by addresses `owners` for contract `token`.
	/// @param token The bound NFT contract address.
	/// @param owner The address whose bound NFT balance is being queried.
	/// @return The number of bound `token` NFTs owned by `owner`.
	function boundBalanceOfBatch(
        address token,
		address[] calldata owners,
		uint256[] calldata tokenIds
    ) external view returns (uint256[])

```

### Rules

#### Binding Rules

**_bind (IERC721Bindable & IERC1155Bindable) rules:_**
* When binding a bindable ERC-721 NFT to an asset
    - MUST throw if caller is not the current owner, the approved address for the NFT, or an approved operator for `from`.
    - MUST throw if NFT `tokenId` is already bound.
    - MUST throw if `from` is not the NFT owner.
    - MUST throw if `to` is not the asset owner.
    - After above conditions are met, MUST check if `bindAddress` is a smart contract (code size > 0). If so, it MUST call `onERC721Bind` on `bindAddress` with `data` passed unaltered and act appropriately (see "Hook Rules").
    - MUST emit the `Bind` event to reflect asset-delegated ownership attribution.
    - MUST emit the `Transfer` event if `from` is different than `to` to reflect ownership change.
* When binding a bindable ERC-1155 fungible or non-fungible token to an asset:
    - MUST throw if caller is not an approved operator for `from`.
    - MUST throw if `from` owns fewer than `amount` unbound tokens of type `tokenId`.
    - MUST throw if `to` is not the asset owner.
    - After above conditions are met, MUST check if `bindAddress` is a smart contract (code size > 0). If so, it MUST call `onERC1155Bind` on `bindAddress` with `data` passed unaltered and act appropriately (see "Hook Rules").
    - MUST emit `Bind` event to reflect asset-delegated ownership attribution.
    - MUST emit the `Transfer` event if `from` is different than `to` to reflect ownership change.

**_unbind (IERC721Bindable & IERC1155Bindable) rules:_**
* When unbinding a bindable ERC-721 NFT from an asset:
    - MUST throw if caller is not the owner of the asset or an approved operator
    - MUST throw if NFT `tokenId` is not bound.
    - MUST throw if `from` is not the asset owner.
    - MUST throw if `to` is the zero address.
    - After above conditions are met, MUST check if `bindAddress` is a smart contract (code size > 0). If so, it MUST call `onERC721Unbind` on `bindAddress` with `data` passed unaltered and act appropriately (see "Hook Rules").
    - In addition, it MUST check if `to` is a smart contract (code size > 0), and call `onERC721Received` on `to` with `data` passed unaltered and act appropriately (see "Hook Rules").
    - MUST emit the `Unbind` event to reflect asset-delegated ownership attribution.
    - MUST emit the `Transfer` event if `from` is different than `to` to reflect ownership change.
* When unbinding a bindable ERC-1155 fungible or non-fungible token from an asset:
    - MUST throw if caller is not the owner of the asset or an approved operator
    - MUST throw if `from` owns fewer than `amount` bound tokens of type `tokenId`.
    - MUST throw if `to` is the zero address.
    - After above conditions are met, MUST check if `bindAddress` is a smart contract (code size > 0). If so, it MUST call `onERC1155Bind` on `bindAddress` with `data` passed unaltered and act appropriately (see "Hook Rules").
    - In addition, it MUST check if `to` is a smart contract (code size > 0), and call `onERC1155Received` on `to` with `data` passed unaltered and act appropriately (see "Hook Rules").
    - MUST emit `Bind` event to reflect asset-delegated ownership attribution.
    - MUST emit the `Transfer` event if `from` is different than `to` to reflect ownership change.

**_batchBind & batchUnbind rules:_**
* When performing a `batchBind` of bindable ERC-1155 tokens on an asset:
    - MUST throw if caller is not an approved operator for `from`.
    - MUST throw if length of `tokenIds` is not the same length as `amounts` or `bindIds`.
    - MUST throw if any unbound token balances of `tokenids` for `from` is less than that of `amounts`.
    - MUST throw if `to` is not the asset owner.
    - After above conditions are met, MUST check if `bindAddress` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchBind` on `bindAddress` with `data` passed unaltered and act appropriately (see "Hook Rules").
    - MUST emit `Bind` event to reflect asset-delegated ownership attribution.
    - MUST emit the `Transfer` event if `from` is different than `to` to reflect ownership change.

#### Transfer Rules

**_IERC721Bindable & IERC721Binder transfer rules:_**

**_IERC1155Bindable & IERC1155Binder transfer rules:_**

#### Event Rules

**_Bind and Unbind event rules:_**

**_BindBatch and UnbindBatch event rules:_**

#### Hook Rules

**_onERC721Bind rules:_**

**_onERC1155Bind rules:_**

#### Query Rules

**_IERC721Bindable & IERC721Binder query rules:_**

**_IERC1155Bindable & IERC1155Binder query rules:_**

TBD
