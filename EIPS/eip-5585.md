---
eip: 5585
title: EIP-721 NFT Authorization
description: Allows NFT owners to authorize other users to use their NFTs.
author: Veega Labs (@VeegaLabsOfficial)
discussions-to: https://ethereum-magicians.org/t/nft-authorization-erc721-extension/10661
status: Draft
type: Standards Track
category: ERC
created: 2022-08-15
requires: 721
---

## Abstract

This standard is an extension of EIP-721. It proposes a solution where NFT holders can grant NFT buyers a set of rights for any kind of commercial purposes by separating the ownership of NFT and the usage, it supports the independent circulation of commercial authorization.

The NFT contract owner can set the maximum number of authorized users of each NFT and whether the authorization can be cancelled during the period, so as to define the authorization baseline of the project.

## Motivation
The NFTs have simplified ownership verification and transfer. However, other kinds of rights, such as exhibition, derivatives or any other commercial rights are still difficult to grant, which limits the values and commercialization of NFTs. So that is why we need to  separate every single NFT's ownership and user rights, which can enhance its commercial value. 

With the development of the Metaverse, NFTs are becoming more diverse, with new use cases such as digital collections, virtual real estate, and commercial copyrights. Meanwhile, the commercial rights, such as exhibition, derivative or commercial authorization based on NFTs are becoming a potential business form.  


## Specification

The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

### Contract Interface

```solidity
interface IERC5585 {
    
    struct UserRecord {
        address user;
        uint expires
    }

    /// @notice NFT holder authorizes his NFT to a user for a specified period of time
    /// @dev The zero address indicates there is no user
    /// @param tokenId The NFT which is authorized
    /// @param user The user to whom the NFT is authorized
    /// @param duration The period of time the authorization lasts
    function userAuthorization(uint256 tokenId, address user, uint duration) external returns(uint);

    /// @notice NFT holder extends the duration of authorization
    /// @dev The zero address indicates there is no user
    /// @param tokenId The NFT which has been authorized
    /// @param user The user to whom the NFT has been authorized
    /// @param duration The new duration of the authorization
    function durationUpdate(uint256 tokenId, address user, uint duration) external;

    /// @notice Get the authorization expired time of the specified NFT and user
    /// @dev The zero address indicates there is no user
    /// @param tokenId The NFT to get the user expires for
    /// @param user The user who has been authorized
    /// @return The authorization expired time
    function userExpiresTime(uint256 tokenId, address user) external view returns(uint);

    /// @notice The contract owner can update the number of users that can be authorized per NFT
    /// @param userLimit The number of users set by operators only
    function userLimitUpdate(unit256 userLimit) external onlyOwner;
  
    /// @notice resetAllowed flag can be updated by contract owner to control whether the authorization can be revoked or not 
    /// @param resetAllowed It is the boolean flag
    function resetAllowedUpdate(bool resetAllowed) external onlyowner;


    /// @notice Check if the token is available for authorization
    /// @dev Throws if tokenId is not a valid NFT
    /// @param tokenId The NFT to be checked the availability
    /// @return true or false whether the NFT is available for authorization or not
    function authorizationAvailabilityCheck (uint256 tokenId) public view returns(bool);

    /// @notice Clear authorization of a specified user
    /// @dev The zero address indicates there is no user. The function  works when resetAllowed is true and it will throw exception when false  
    /// @param tokenId The NFT on which the authorization based
    /// @param user The user whose authorization will be cleared
    function resetUser(uint256 tokenId, address user) external;

    /// @notice This is an OPTIONAL function that the operator MAY call, he can set the starting time of staking as a reward of the authorization for each user 
    /// @dev The zero address indicates there is no user
    /// @param user To which user the staking time will be set
    /// @param stakingTime The starting time of the staking for each user
    function stakingTimeUpdate(address[] user, uint[] stakingTime) external;


    /// @notice Emitted when the user of a NFT is changed or the authorization expires time is updated
    /// param tokenId The NFT on which the authorization based
    /// param indexed user The user to whom the NFT authorized
    /// param expires The expires time of the authorization
    event userAuthorization(uint256 indexed tokenId, address indexed user, uint expires);
}
```


The `userAuthorization(uint256 tokenId, address user, uint duration)` function MAY be implemented as `public` or `external`.

The `durationUpdate(uint256 tokenId, address user, uint duration)` function MAY be implemented as `public` or `external`.

The `userExpiresTime(uint256 tokenId, address user)` function MAY be implemented as `pure` or `view`.

The `userLimitUpdate(unit256 userLimit)` function MAY be implemented as`public` or `external`.

The `resetAllowedUpdate(bool resetAllowed)` function MAY be implemented as `public` or `external`.

The `authorizationAvailabilityCheck (uint256 tokenId)` function MAY be implemented as `pure` or `view`.

The `resetUser(uint256 tokenId, address user)` function MAY be implemented as `public` or `external`.

The `stakingTimeUpdate(address[] user, uint[] stakingTime)` function MAY be implemented as `public` or `external`.

The `userAuthorization` event MUST be emittedwhen the user of a NFT is changed or the authorization expires time is updated.



## Rationale

First of all, NFT contract Owner can set the maximum number of authorized users for each NFT and whether the NFT owner can cancel the authorization at any time to define the NFT's authorization properties and protect the interests of the parties involved.

Secondly, this EIP combines staking and authorization so that NFT owners can only assign limited authorizations for their NFTs for a given staking period. This protects all parties from overhype and to ensure that the NFT's price more accurately matches its value.

Thirdly, there is a resetAllowed flag to control the rights between the owner and the user. The owner can cancel the authorization at anytime if the flag is true, and can NOT cancel when it comes to false.

Finally, this design can be seamlessly integrated with third parties. It is an extension of [EIP-721](./eip-721.md), so it can be integrated into new NFT projects. Other projects can directly interact with these interfaces and functions to implement their own types of transactions. For example, an announcement platform could use this EIP to allow all its NFT owners to authorize partners and terminate the authorization at any time.

## Backwards Compatibility

This standard is compatible with EIP-721 since it is an extension of it.

## Security Considerations

There is a potential problem. If someone bought a NFT within the duration of authorization, he may not receive the authorization fee which has been transferred to the previous NFT holder when the authorization started. And he may cancel the authorization immediately which is definitely not expected by the NFT user.

We have a way to address the problem. The authorization fee paid by the users will be hosted and locked in a smart contract, and the "authorized funds" will be dynamically unlocked to NFT owners in terms of how long the NFT being used. For example, if the authorization duration is 12 months and the fee in total is 10ETH which has been locked into the "fund account", if the owner transferred his NFT to a new one in the end of third month, then the owner can receive 2.5ETH only.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
