---
eip: 5289
title: Notary Interface
description: Allows Smart Contracts to be Legally Binding Off-Chain
author: Pandapip1 (@Pandapip1)
discussions-to: https://ethereum-magicians.org/t/discussions-to-pr-5289/9980
status: Draft
type: Standards Track
category: ERC
created: 2022-07-16
requires: 165, 191, 1271
---

## Abstract

Currently, the real-world applications of smart contracts are limited by the fact that they aren't legally binding. This EIP proposes a standard that allows smart contracts to be legally binding by providing IPFS links to legal documents and ensuring that the users of the smart contract have privity with the relevant legal documents.

## Motivation

NFTs have oftentimes been branded as a way to hold and prove copyright of a specific work. However, this, in practice, has almost never been the case. Most of the time, NFTs have no legally-binding meaning, and in the rare cases that do, the NFT simply provides a limited license for the initial holder to use the work (but cannot provide any license for any future holders).

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

### Signing a Document

Calculate the signature of the following. The [EIP-191](./eip-191) version byte is `0x53`:

```solidity
keccak256(bytes("\x19Sign Legal Document:") + multihash)
```

This MUST be compatible with [EIP-1271](./eip-1271.md).

Wallets MUST display the contents of the PDF to the user.

### Legal Contract Library Interface

```solidity
/// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/introspection/IERC165.sol";

interface IContractLibrary is IERC165 {
    /// @notice Emitted when signDocument is called
    event DocumentSigned(address indexed signer, uint48 indexed documentId);
    
    /// @notice The IPFS multihash of the legal document. This MUST resolve to a PDF.
    function legalDocument(uint48 documentId) public pure returns (bytes memory);
    
    /// @notice Returns whether or not the given user signed the document
    function isDocumentSigned(address user, uint48 documentId) public view returns (boolean signed);

    /// @notice The block timestamp of when the user signed. Throws if not signed.
    function documentSignedAt(address user, uint48 documentId) public view returns (uint64 timestamp);

    /// @notice Provide a signature
    /// @dev This MUST be validated by the smart contract. This MUST emit DocumentSigned or throw.
    function signDocument(address signer, uint48 documentId, bytes memory signature) public;
}
```

### Requesting a Signature

To request that certain documents be signed, revert with the following reason:

```solidity
string.concat("Must Sign Documents:", libraryAddress1, "-", documentId1, ",", libraryAddress2, "-", documentId2, ...)
```

Example:

```solidity
"Must Sign Documents:0x0000000000000000000000000000000000000000-1,0x000000000000000000000000000000000000000-2,0x00000000000000000000000000000000000dead-743"
```

## Rationale

- `uint64` was chosen for the timestamp return type as 64-bit time registers are standard.
- `uint48` was chosen for the document ID as it uses 26 less bytes than `uint256`, and it is unlikely that more than 4 billion documents will ever need be signed in the same library. If so, oh well, just deploy another library.
- `signDocument` allows for the signing user to be different than the transaction sender so that it is possible to subsidize this type of transaction.
- IPFS is mandatory because the authenticity of the signed document can be proven.

## Backwards Compatibility

No backwards compatibility issues found.

## Reference Implementation

### Legal Contract Library

```solidity
/// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/introspection/ERC165Storage.sol";
import "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";

contract ContractLibrary is IContractLibrary, ERC165Storage {
    uint48 private counter = 0;
    mapping(uint48 => bytes memory) private multihashes;
    mapping(uint48 => bytes32) private signatureHashes;
    mapping(uint48 => mapping(address => bool)) signed;
    mapping(uint48 => mapping(address => uint64)) signedAt;

    constructor() {
        _registerInterface(type(ILegalDocument).interfaceId);
    }

    function registerDocument(bytes memory multihash) public {
        uint48 documentId = counter++;
        multihashes[documentId] = multihash;
        signatureHashes[documentId] = keccak256(abi.encodePacked(bytes("\x19Sign Legal Document:"), multihash));
    }

    function legalDocument(uint48 documentId) public view returns (bytes memory) {
        return multihash[documentId];
    }

    function isDocumentSigned(address user, uint48 documentId) public view returns (boolean signed) {
        return signed[documentId][user] && user != address(0);
    }

    function documentSignedAt(address user, uint48 documentId) public view returns (uint64 timestamp) {
        require(isDocumentSigned(user, documentId), "User didn't sign document");
        return signedAt[documentId][user];
    }

    function signDocument(address signer, bytes memory signature) public {
        require(SignatureChecker.isValidSignatureNow(signer, signatureHash[documentId], signature), "Invalid signature");
        signed[documentId][signer] = true;
        signedAt[documentId][signer] = uint64(block.timestamp);
        emit DocumentSigned(signer, documentId);
    }
}
```

## Security Considerations

No security considerations.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
