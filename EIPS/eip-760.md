---
eip: 760
title: Homomorphically encrypted storage
author:	silur <huohuli@protonmail.ch>
discussions-to: huohuli@protonmail.ch
type: Standard Track
category: Core
status: Draft
created: 2017-11-07
---

## Simple Summary
A precompile contract that supports various homomorphic operations on externally encrypted data while keeping data integrity.

## Abstract
Byzantium upgrade made zk-snarks possible but as we know with zk-snarks, data doesn't actually move only the validity of the commitment provided on the data.
Fully homomorphic encryption allows anyone to bootstrap a "storage-key" for their data which allows any endparty to execute mutually agreed boolean circuits on
encrypted data, without decrypting it, including searching and indexing too. This allows secure storage and operations on healthcare records or customer databases, enabling services easy compliance with EU GDPR. Concensus about data modification will still be transparent for storage keys are stored in the contracts.

## Motivation
A very common problem among people who wants to migrate or enter their business to blockchains is that they cannot put confidential data into a public ledger,
although they still need to overcome distrust between different types of customers. Uploading critical business data into a blockchain where competitors or unauthorized personnel can scrape and analyze it is not an option so in all cases these parties stay with the centralized non-transparent model.
This EIP issues this problem with enabling distribution of existing infrastructures on the blockchain, without exposing sensitive data into publicity.

## Specification

Bootstrapping is implemented using learning with errors which is known to be as hard as lattice shortest-vector problems (are quantum-resistant by design),
and allow near-infinite amounts of operations on secrets.

Implementation should include a flag of LWE-depth and noise `n`. Boolean primitives `x` are handled as gadget matrices (generated with a decomposition
function `D(v))` with the restriction that there exists an LWE sample outputing a small vector `u` where `ux -v` are less or equal to an agreed precision (see Gentry-Saha-Waters).
Decomposition algorithms shall include entropy to keep error limits independent.
Operating on encrypted data with these gadgets are possible with the use of a key-switching context which will output another sample with a different key
on the same data with only negligible difference on the noise parameter, which enables us billions of consequential switches.
Specifically the key-switching takes k LWE sample ciphertexts, an R-lipschitzian morphism of Z-modules, a key sample KS with noise limit `l`, and `Aks` and `Vks`
being the amplitude and variance of error, the algorithm shall output:
`||error(c)||∞ <= R||error(c)||∞  + nt*n*Aks + n*2^-(t+1)` in worst case and
`variance(error(c)) <= R^2*variance(error(c)) + nt*n*Vks + n*2^(2*(t+1))` in average case

I propose the introduction of a precompile contract that's capable of:
- Storing elements from a polynomial ring modulo (x^n + 1) of variable length and prime base. Variable parameters are required in order to properly respond to security indcidents in case prior parametrizations are proven to be unsecure.
- Basic polynomial arithmetics with the Number Theoretic Transform (prime field fastfourier): `addmod, mulmod, submod, fft_forward, fft_backward`.
- `add` and `mul` function calls which perform the ciphertext homomorphic addition and the error-relinearization with the trick above or other FHE logic if we don't keep these parameters.
- Later we can extend the supported homomorphic opcodes to more complex ones

The above primitives can also introduce more advanced LWE-RLWE based protocols like IO or IBE :)
Most of the mathematical design is based on the academic works of Ilaria Chillotti1, Nicolas Gama, Mariya Georgieva, and Malika Izabachene, cryptology ePrint 2017/430
## Rationale
Since the proposal doesn't change EVM state storage and key handling is not part of an account we decided to keep the FHE toolset to a precompile contract.
## Backwards Compatibility
EVM state storage does not need modifications as public keys can be used as regular byte arrays and private keys are trivially never stored onchain. Otherwise as seen with EC precompiles.
**Note that RLWE public keys are marginally bigger than their (security-wise) EC counterparts from 2-16kb depending on parameter selection**
## Test Cases
Realistic amount of key-switches (as in RL business cases) 
## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
