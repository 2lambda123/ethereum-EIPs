---
eip: 152
title: Add Blake2 compression function `F` precompile
author: Tjaden Hess <tah83@cornell.edu>, Matt Luongo (@mhluongo), Piotr Dyraga (@pdyraga), James Hancock (@MadeOfTin)
discussions-to: https://github.com/ethereum/EIPs/issues/152
status: Draft
type: Standards Track
category: Core
created: 2016-10-04
requires: 2046
---

<!--You can leave these HTML comments in your merged EIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new EIPs. Note that an EIP number will be assigned by an editor. When opening a pull request to submit your EIP, please use an abbreviated title in the filename, `eip-draft_title_abbrev.md`. The title should be 44 characters or less.-->

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Provide a simplified and layman-accessible explanation of the EIP.-->

This EIP will enable the Blake2b hash function to run cheaply on the EVM, allowing easier interoperability between Ethereum and Zcash as well as other Equihash-based PoW coins.

## Abstract
<!--A short (~200 word) description of the technical issue being addressed.-->

This EIP introduces a new precompiled contract which implements the compression function `F` used in the BLAKE2b cryptographic hashing algorithm, for the purpose of allowing interoperability between the EVM and Zcash, as well as introducing more flexible cryptographic hash primitives to the EVM.

## Motivation
<!--The motivation is critical for EIPs that want to change the Ethereum protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the EIP solves. EIP submissions without sufficient motivation may be rejected outright.-->

Besides being a useful cryptographic hash function and SHA3 finalist, BLAKE2b allows for efficient verification of the Equihash PoW used in Zcash, making a BTC Relay - style SPV client possible on Ethereum. A single verification of an Equihash PoW verification requires 512 iterations of the hash function, making verification of Zcash block headers prohibitively expensive if a Solidity implementation of BLAKE2b is used.

The BLAKE2b algorithm is highly optimized for 64-bit CPUs, and is faster than MD5 on modern processors.

Interoperability with Zcash could enable contracts like trustless atomic swaps between the chains, which could provide a much needed aspect of privacy to the very public Ethereum blockchain.

## Specification
<!--The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Ethereum platforms (go-ethereum, parity, cpp-ethereum, ethereumj, ethereumjs, and [others](https://github.com/ethereum/wiki/wiki/Clients)).-->

We propose adding a precompiled contract at address `0x09` wrapping the [BLAkE2b `F` compression function](https://tools.ietf.org/html/rfc7693#section-3.2).

The precompile requires 6 inputs encoded with `abi.encodePacked` and taking exactly 213 bytes. The encoded inputs are corresponding to the ones specified in the [BLAKE2b RFC](https://tools.ietf.org/html/rfc7693#section-3.2)

- `rounds` - the number of rounds
- `h` - the state vector
- `m` - the message block vector
- `t_0, t_1` - offset counters
- `f` - the final block indicator flag

```
[4 bytes for rounds][64 bytes for h][128 bytes for m][8 bytes for t_0][8 bytes for t_1][1 byte for f]
```

The precompile should compute the `F` function as [specified in the RFC](https://github.com/keep-network/go-ethereum/pull/4) and return the updated state vector `h`.

### Example Usage in Solidity

The precompile can be wrapped easily in Solidity to provide a more development-friendly interface to `F`.

```solidity
function F(uint32 rounds, bytes32[2] memory h, bytes32[4] memory m, uint64[2] memory t, bool f) public view returns (bytes32[2] memory) {
  bytes32[2] memory output;

  bytes memory args = abi.encodePacked(rounds, h[0], h[1], m[0], m[1], m[2], m[3], t[0], t[1], f);

  assembly {
      if iszero(staticcall(not(0), 0x09, add(args, 32), 0xd5, output, 0x40)) {
          revert(0, 0)
      }
  }

  return output;
}

function callF() public view returns (bytes32[2] memory) {
  bytes32[2] memory h;
  h[0] = hex"6a09e627f3bcc909bb67ae8484caa73b3c6ef372fe94b82ba54ff53a5f1d36f2"; 
  h[1] = hex"510e527fade682d19b05688c2b3e6c1f1f83d9abfb41bd6b5be0cd19137e2179";
  
  bytes32[4] memory m;
  m[0] = hex"278400340e6b05c5752592c52c4f121292eafc51cc01a997b4aed13409298fad";
  m[1] = hex"0d99ccc8f76453d9b3661e5c4d325d7751147db17489046d1682d50eefa4a1da";
  m[2] = hex"0000000000000000000000000000000000000000000000000000000000000000";
  m[3] = hex"0000000000000000000000000000000000000000000000000000000000000000";
 
  uint64[2] memory t;
  t[0] = 18446744073709551552;  // ffffffffffffffc0
  t[1] = 18446744073709551615;	// ffffffffffffffff

  bool f = true;

  uint32 rounds = 12;

  return F(rounds, h, m, t, f);
}    
```

### Gas costs and benchmarks

Each operation will cost `GFROUND * rounds` gas, where `GFROUND = 1`.

Assuming `ecrecover` precompile is perfectly priced, we executed a set of benchmarks comparing Blake2b F compression function precompile with `ecrecover` precompile. For benchmarks, we used 3,1 GHz Intel Core i7 64-bit machine.

- `ecrecover` took `180.3` microseconds on average to execute. With the fixed gas price of `3000` for `ecrecover`, it is about `16.64` gas per microsecond of `ecrecover` work.

```
BenchmarkPrecompiledEcrecover/-Gas=3000-8                  10000            180309 ns/op
```

- 12 rounds of `F` took `0.3686` microseconds on average, so the entire invocation with `12` rounds should cost `0.3686 * 16.64 = 6.133` gas, what gives `0.5111` gas per round.

```
BenchmarkPrecompiledBlake2F/testVectors2bX_0-Gas=12-8            3000000               352 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_3-Gas=12-8            5000000               342 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_70-Gas=12-8           5000000               328 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_140-Gas=12-8          5000000               329 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_230-Gas=12-8          5000000               332 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_300-Gas=12-8          5000000               335 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_370-Gas=12-8          3000000               424 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_440-Gas=12-8          3000000               413 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_510-Gas=12-8          3000000               417 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_580-Gas=12-8          3000000               414 ns/op
```

- Setting `1200` rounds instead of `12` brings down the gas cost even more. `1200` rounds of `F` took `25.66` microseconds on average, so the entire invocation with `1200` rounds should cost `25.66 * 16.64 = 426,98` gas, what gives `0.356` gas per round.
```
BenchmarkPrecompiledBlake2F/testVectors2bX_0-Gas=1200-8                    50000             25906 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_3-Gas=1200-8                    50000             25427 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_70-Gas=1200-8                   50000             26047 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_140-Gas=1200-8                  50000             25386 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_230-Gas=1200-8                  50000             25170 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_300-Gas=1200-8                  50000             25957 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_370-Gas=1200-8                  50000             26222 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_440-Gas=1200-8                  50000             25337 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_510-Gas=1200-8                  50000             25530 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_580-Gas=1200-8                  50000             25623 ns/op
```

- For the case of `1` round, an average invocation time takes `0.1569` microsecond, so one round should cost `0.1569 * 16.64 = 2.610 gas`. However, in this scenario the call cost would totally overshadow the dynamic cost anyway.

```
BenchmarkPrecompiledBlake2F/testVectors2bX_0-Gas=1-8            10000000               159 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_3-Gas=1-8            10000000               162 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_70-Gas=1-8           10000000               155 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_140-Gas=1-8          10000000               161 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_230-Gas=1-8          10000000               161 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_300-Gas=1-8          10000000               154 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_370-Gas=1-8          10000000               155 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_440-Gas=1-8          10000000               155 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_510-Gas=1-8          10000000               149 ns/op
BenchmarkPrecompiledBlake2F/testVectors2bX_580-Gas=1-8          10000000               158 ns/op
```


## Rationale
<!--The rationale fleshes out the specification by describing what motivated the design and why particular design decisions  were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->

BLAKE2b is an excellent candidate for precompilation. It exhibits an extremely asymmetric efficiency. BLAKE2b is heavily optimized for modern 64-bit CPUs, specifically utilizing 24 and 63-bit rotations to allow parallelism through SIMD instructions and little-endian arithmetic. These characteristics provide exceptional speed on native CPUs: 3.08 cycles per byte, or 1 gibibyte per second on an Intel i5.

In contrast, the big-endian 32 byte semantics of the EVM are not conducive to efficient implementation of BLAKE2, and thus the gas cost associated with computing the hash on the EVM is disproportionate to the true cost of computing the function natively.

An obvious implementation would be a direct BLAKE2b precompile. At first glance, a BLAKE2b precompile satisfies most hashing and interoperability requirements on the EVM. Once we started digging in, however, it became clear that any BLAKE2b implementation would need specific features and internal modifications based on different projects' requirements and libraries.

A [thread with the Zcash team](https://github.com/ethereum/EIPs/issues/152#issuecomment-499240310) makes the issue clear.

> The minimal thing that is necessary for a working ZEC-ETH relay is an implementation of BLAKE2b Compression F in a precompile.

> A BLAKE2b Compression Function F precompile would also suffice for the Filecoin and Handshake interop goals.

> A full BLAKE2b precompile would suffice for a ZEC-ETH relay, provided that the implementation provided the parts of the BLAKE2 API that we need (personalization, maybe something else—I'm not sure).

> I'm not 100% certain if a full BLAKE2b precompile would also suffice for the Filecoin and Handshake goals. It almost certainly could, provided that it supports all the API that they need.

> BLAKE2s — whether the Compression Function F or the full hash — is only a nice-to-have for the purposes of a ZEC-ETH relay.

From this and other conversations with teams in the space, we believe we should focus first on the `F` precompile as a strictly necessary piece for interoperability projects. A BLAKE2b precompile is a nice-to-have, and we support any efforts to add one-- but it's unclear whether complete requirements and a flexible API can be found in time for Istanbul.

Implementation of only the core F compression function also allows substantial flexibility and extensibility while keeping changes at the protocol level to a minimum. This will allow functions like tree hashing, incremental hashing, and keyed, salted, and personalized hashing as well as variable length digests, none of which are currently available on the EVM.

## Backwards Compatibility
<!--All EIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The EIP must explain how the author proposes to deal with these incompatibilities. EIP submissions without a sufficient backwards compatibility treatise may be rejected outright.-->

There is very little risk of breaking backwards-compatibility with this EIP, the sole issue being if someone were to build a contract relying on the address at `0x09` being empty. The likelihood of this is low, and should specific instances arise, the address could be chosen to be any arbitrary value with negligible risk of collision.

## Test Cases

<!--Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.-->

Test cases are in progress, and can be followed along in our [Golang Blake2 library fork](https://github.com/keep-network/blake2-f) as well as our fork of [go-ethereum](https://github.com/keep-network/go-ethereum).

## Implementation
<!--The implementations must be completed before any EIP is given status "Final", but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of "rough consensus and running code" is still useful when it comes to resolving many discussions of API details.-->

An initial implementation of the `F` function in Go, adapted from the standard library, can be found in our [Golang Blake2 library fork](https://github.com/keep-network/blake2-f). There's also an implementation of the precompile in our fork of [go-ethereum](https://github.com/keep-network/go-ethereum/pull/4).

## References

For reference, further discussion on this EIP also occurred in the following PRs and issues

 * [Original Issue](https://github.com/ethereum/EIPs/issues/152)
 * [Ethereum Magicians](https://ethereum-magicians.org/t/blake2b-f-precompile/3157)
 * [PR 2129](https://github.com/ethereum/EIPs/pull/2129)

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
