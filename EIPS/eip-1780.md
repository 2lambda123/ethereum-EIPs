---
eip: 1780
title: JSON-LD Contract Metadata for Semantic Web Ontologies
author: Cory Dickson <cory@aragon.black>
category: Interface
type: Standards Track
status: Draft
created: 2018-12-02
---
## Summary
A standard interface for publishing and validating JSON/RDF/GraphQL Schema data models associated with ethereum addresses

## Abstract
Taking some of the concepts in [EIP-1357](https://github.com/eth-registry/EIPs/blob/EIP-1357-Address-Metadata/EIPS/eip-1456.md) but not including the fields illustrated in their Specification:
> Ethereum addresses have related information (metadata) useful to users and developers. This metadata is captured by third parties and not accessible
> through an on-chain mechanism.
>
> ETH Registry makes address metadata available to applications and users through a registry contract that maps the addres to a JSON file stored on IPFS.
> A working prototype is available at: https://ethregistry.org.

This interface gives permissions for an agent to join a registry of off-chain JSON schemas associated with said address.

## Motivation

The goal to extend the semantic web technologies onto the blockchain stems from the idea of [Ricardian Contracts](https://en.wikipedia.org/wiki/Ricardian_contract).
Essentially we'd like to treat smart contracts like legal documents that machines can compute over, but are also human-readble for lawyers and non-technical contracting parties.

Associating these data model semantics with contract address opens the possibility to run complex queries across blockchain data and create more interactive experiences backed by
clearer policy definitions. This is critical in DAOs which need to treat contract logic like a law. And thus, a human-readable metadata structure will help both intelligent agents and humans make sense of the actions and
events that the organisation engages in.

Below you will find a specification that is derived from an example ontology: https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol
Entities can be described with both GraphQL/JSON-LD itself or using RDF format.

### Formal Verification

Furthermore, we intend to show with this example a potential path to interoperability between semantics that share similar context definitions. We would eventually try to construct formally verifiable proofs using the K Framework.
This will take significant time for additional research and development. In the meantime however, we can provide a compact spec that provides basic capabilities for anyone to create their own semantic metadata schemas
they can expose utilizing IPFS or Swarm.

The contract developers would only be responsible for setting the respective URL field to retrieve the data for the scheme associated with that address, denoting both its context and type. If we take an agent-centric approach to
creating these ontologies, contract implementers will be responsible for these definitions and registries can be leveraged to expose and validate implementations against the schema. This would be done off-chain until
there is a path to generate a translation between the formal semantics of the computation through the EVM + Solidity, into one that's generalizable for the semantic web schemas defined for a particular contract.
Although this approach raises the governance issue of contract creators maliciously uploading schemas that are buggy/exploitative, we can rely on community diligence to manage a whitelist of trusted contracts.

An immediate workaround would be to configure an ENS whitelist of trusted domains that guarantee up-to-date schemas on registered contracts.

## Specification
Inspired by:
https://github.com/MetaMask/eth-contract-metadata
https://github.com/eth-registry/EIPs/blob/EIP-1357-Address-Metadata/EIPS/eip-1456.md
https://github.com/ethereum/EIPs/issues/820
https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md

The following would be stored on the contract.json of this multisig wallet implementation:

```json-ld
{
  //The contract abi definitions
  ...
  contexts: [
    {
      // the protocol is more or less arbitrary, but a
      // Swarm URL is recommended to the JSON schema, or ENS Domain
      "@context": ["bzzr://56ab...", "gnosis.eth/context/v2/MultiSigWallet/MultiSigWallet.json"]
      "@type": "MultiSigWallet",
      "url": ["bzzr://22ef...", "gnosis.eth/v2/MultiSigWallet/"] //This could be a swarm url or an ENS domain
    }
  ]
}
```

Now when someone retrieves the JSON schema stored at the URL and verifies its context youâ€™ll retrieve a blob that reflects the data model body:

```json-ld
body: {
  TODO
}
```

Or even in RDF format:
```rdf
<?xml version="1.0"?>
<rdf:RDF
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  xmlns:s="gnosis.eth/context/v2/MultiSigWallet/MultiSigWallet.json">
  <rdf:Description about="gnosis.eth/v2/MultiSigWallet/">
    <s:Name>Jane's Multisig</s:Name>
  </rdf:Description>
</rdf:RDF>
```

If we were to create a subgraph definition:
```
type MultiSig @entity {
  signers: [Bytes]!
  balance: BigInt!
}
```

The rational to utilize a Swarm hash of the file is so that we can use to verify a correct implementation of a registered contract:
``0xa1 0x65 'b' 'z' 'z' 'r' '0' 0x58 0x20 <32 bytes swarm hash> 0x00 0x29 ``
(Further reading)[https://solidity.readthedocs.io/en/v0.4.25/metadata.html?highlight=swarm]

## Rationale

/* TODO */

### Off-chain Schema Validation

There needs to be a way to leverage some form of offchain verification because introspection of contract data is costly. To mitigate this hurdle an implementor would want to keep a collection of [radspec](https://hack.aragon.org/docs/human-readable-txs.html) tx hashes that serve as a record of the tx where JSON data was modified either by the contract registry owner or by another smart contract (agent). This ensures that if an agent wants to challenge
a schema definition, during the claims process they have the history of transactions and agents(addresses) that carried out the service. Bad actors would be more easily identifiable and could be punished judiciously within DAOs or
other types of agreements they engage in.

## Implementation

Here is the Solidity pseudocode of one of these schema management registries that implements [ERC820](https://github.com/ethereum/EIPs/issues/820):
Inspired by: https://arxiv.org/pdf/1801.02027.pdf

```solidity
contract SemanticInterface implements ERC820ImplementorInterface{
  //SHA256
  mapping (address => bytes32) standardRootHashes; //the contract associated with the root schema if deployed on The Graph
  mapping (address => bytes32) standardReferenceOntologyHashes;
  mapping (address => bytes32) annotatedSourceCodeHashes; //contracts without an explicit subgraph definition

  function getGovernanceModel(adresss addr) public returns (bytes32) {
    return standardRootHash[addr];
  }

  function getReferenceOntology(address addr) public returns (bytes32) {
    return standardReferenceOntology[addr];
  }

  function getAnnotatedSource(address addr) public returns (bytes32) {
    return annotatedSourceCodeHashes[addr];
  }

  function canImplementInterfaceForAddress(address addr, bytes32 interfaceHash) view public returns(bytes32); //TODO
}

```

```solidity
function isFamiliarGovernance(address otherContract) returns (bool) {
 SemanticInference otherInference = SemanticInference(otherContract);
 if(otherInference.getGovernanceModel(msg.sender) == standardRootHash[otherContract] && otherInference.getReferenceOntology(msg.sender) == standardReferenceOntology[msg.sender]) {
   return true;
 }
 return false;
}

//we could imagine complex business logic to behave differently, depending on the governance structure of the other
//if not a match, could pause in application flow, and wait for off-chain intervention
```

## Test Cases
Let's say there is a real-world organization that already have ontologies and semantic maps to describe all of the entities within it's domain. Combined with agent-centric modeling it would be able to rapidly prototype contracts:

*TODO*

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
