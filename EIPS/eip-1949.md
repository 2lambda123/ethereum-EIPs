---
eip: 1949
title: Delayed Distributed Minting
author: Johann Barbie (@johannbarbie), Pinkiebell (@pinkiebell)
discussions-to: https://ethresear.ch/t/a-distributed-breeding-function/5264
status: Draft
type: Standards Track
category: ERC
created: 2019-04-18
requires: 721, 1948
---

## Simple Summary

```
Two CryptoKitties take a honeymoon on a sidechain 🐈🐈🏖. The blazing fast transactions heat their blood 🔥, one thing leads to another ❤ and a rare baby-kitten is born 💥🐯. On the way home to mainnet the family gets stopped at the bridge contract, “👮‍♂️ tokenIDs please!”. Oh shoot, the baby-kitten doesn’t have one on the root chain 🤷‍♀️.
```

The minting function of NFT contracts is centralized to a single chain. This proposal allows to mint tokens across multiple chains.

## Abstract

This ERC introduced a design for NFT tokens to be mintable across multiple chains. A minimal requirement for distributed minting are collision-free token Ids. The collision-freeness is achieved by introducing two types of tokens, queens and workers. The Ids of the queens are generated by hashing the token contract address with an increasing `queenCounter` in the contract. The Ids of the workers are generated by hashing the queenIds with an increasing counter that the queen tokens carry in themselves using the [data token specification](https://github.com/ethereum/EIPs/pull/1948).

## Motivation

While fungible tokes have a natural performance gain when using sidechains, NFTs need to be minted on the mainnet and deposited one by one. With the distributed breeding function described here, NFTs can be minted on sidechains and only cause mainnet costs on exit.

## Specification

An extension of [ERC721](https://eips.ethereum.org/EIPS/eip-721) interface with the following function is suggested:

```
pragma solidity 0.5.2;

/**
 * @title IERC1949
 * @dev Interface for delayed breeding
 */
interface IERC1949 {

  function breed(uint256 _workerId, bytes32 _workerData) public;
}
```

## Rationale

Sidechain allow for easy user onboarding through fast block times and low transaction fees. Fungible tokes have natural cost savings when using sidechains, as there can be one large deposit from the mainnet followed by many small transfers. NFTs are equally important for user onboarding, but fail to gain similar advantages by use of sidechains, as they need to be minted individually. If the issuing contract is on the mainnet, then the cost is high, if the issuing contract is on the sidechain, then it's tokens can not be exited and will lack access to liquid markets.

Ideally NFTs could be minted on sidechains cheaply in masses. Only selected tokens gaining value through user interaction or scarcity would then cause justified minting cost on the mainnet to be traded on decentralized markets where their value can be realized. 

The proposal for this ERC stems from the [distributed breeding proposal](https://ethresear.ch/t/a-distributed-breeding-function/5264) to allow better integration of NFTs accross sidechains. [ost.com](https://ost.com/), [Skale](https://skalelabs.com/), [POA](https://poa.network/), and [LeapDAO](https://leapdao.org/) have been part of the discussion.

## Backwards Compatibility

🤷‍♂️ No related proposals are known to the author, hence no backwards compatibility to consider.

## Test Cases

Simple tests:

```
import { keccak256 } from 'ethereumjs-util';
const ERC1949 = artifacts.require('ERC1949.sol');

contract('ERC1949', (accounts) => {
  let queenId;
  const creator = accounts[0];
  const workerData = '0x0101010101010101010101010101010101010101010101010101010101010101';
  let breedToken;

  beforeEach(async () => {
    breedToken = await ERC1949.new();
    const rsp = await breedToken.mintQueen(creator);
    queenId = rsp.logs[0].args.tokenId;
  });

  it('should allow to breed new worker', async () => {
    // check queenCounter
    const queenCounter = '0x0000000000000000000000000000000000000000000000000000000000000001';
    let rsp = await breedToken.readData(queenId);
    assert.equal(rsp, queenCounter);

    // generate workerId
    const buffer = Buffer.alloc(64, 0);
    queenId.toBuffer().copy(buffer);
    buffer.writeUInt32BE(1, 60);
    const workerId = `0x${keccak256(buffer).toString('hex')}`;

    // breed and check result
    rsp = await breedToken.breed(workerId, workerData);
    const mintedId = `0x${rsp.logs[1].args.tokenId.toString('hex')}`;
    assert.equal(workerId, mintedId);

    // check worker data
    const data = await breedToken.readData(workerId);
    assert.equal(data, workerData);
  });

  it('should fail if breed called by non-owner', async () => {
    await breedToken.breed(123, workerData, {from: accounts[1]}).should.be.rejectedWith(EVMRevert);
  });

});
```


## Implementation

An example implementation of the interface in solidity would look as below:

```
pragma solidity 0.5.2;

import "./ERC1948.sol";
import "./IERC1949.sol";

/**
 * @title ERC1949
 * @dev An ERC721 token that allows to mint tokens accross multiple chains.
 * The contract contains two classe of tokens, queens and workers.
 */
contract ERC1949 is IERC1949, ERC1948 {
  uint256 public queenCounter = 0;
  mapping(address => uint256) queenOwners;

  function mintQueen(address _to) public {
    queenCounter += 1;
    uint256 queenId = uint256(keccak256(abi.encodePacked(address(this), queenCounter)));
    super._mint(_to, queenId);
    queenOwners[_to] = queenId;
    emit DataUpdated(queenId, data[queenId], bytes32(uint256(1)));
    data[queenId] = bytes32(uint256(1));
  }

  modifier onlyQueenOwner() {
    require(queenOwners[msg.sender] > 0, "sender not queen owner");
    _;
  }

  function breed(uint256 _workerId, bytes32 _workerData) public onlyQueenOwner() {
    super._mint(msg.sender, _workerId);
    emit DataUpdated(_workerId, data[_workerId], _workerData);
    data[_workerId] = _workerData;
  }

}
```

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).