---
eip: to be assigned (preferred 1898)
title: ERC-54 Upgradable Smart Contract
author: Kaidong Wu <wukd94@pku.edu.cn>, Chuqiao Ren <c@tryrenaissance.com>, Ruthia He <r@renaissance.app>, Yun Ma <pkucsmy@gmail.com>
status: Draft
type: Standards Track
category: ERC
created: 2018-10-17
---


## Simple Summary

A standard interface/guideline that makes a smart contract upgradable. 

## Abstract

Ethereum smart contracts have suffered a number of security issues in the past few years. The cost of fixing such a bug in smart contract is significant; for example, the consequences of The DAO attack in June 2016 caused tremendous financial loss and the hard fork of Ethereum blockchain.

The following standard makes it possible to upgrade a standard API within smart contracts. This standard provides basic functionalities to upgrade the operations of the contract without data migration. To ensure the decentralization/community interests, it also contains a voting mechanism to control the upgrade process. 

## Motivation

Smart contract is immutable after deployment. If any security risk is identified or program bug is detected, developers always have to destruct the old contract, deploy a new one and potentially migrate the data (hard fork) to the new contract. In some cases, deploying a smart contract with bugs and potential security vulnerabilities can cause a significant amount of financial loss.  

We propose this upgradable contract to fix the current situation. With the upgradable contract, developers can deploy a new version of smart contract after previous deployment and retain the data at the same time. 

For example, after an ERC20-compliant token contract is deployed, the users exploit a vulnerability in the source code.  Without the support of upgradable contract, developers have to fix this issue by deploy a new, secured contract otherwise the attackers would take advantage of the security hole, which may cause a tremendous financial loss. A challenge is how to migrate data from the old contract to a new one. With the upgradable contract below, this will become relatively easy as developers only have to upgrade the Handler contract to fix bugs while the Data contract will remain the same.


## Specification

The upgradable contract consists of three parts:

- **Data contract** keeps the resources (data) and is controlled by Handlers;
- **Handler contract** (implements **Handler** **interface****)** defines operations and provides services. This contract can be upgraded;
- **Upgrader** **contract** deals with the voting mechanism and upgrades the Handler contract. The voters are pre-defined by the contract owner. 

The following codes are extract copies of the [ERC54 Upgradable Smart Contract.](https://gist.github.com/renchuqiao/faf57c397f4d5ff2a7f67097ffe8bf83)

### Handler Interface

Below is the Handler interface. In the Handler interface we define the following actions:

- Initialize the data contract
- Register the upgrader contract address
- Destruct the handler contract after upgrade is done
- Verify the current handler is the working one → it should always return true

The process of deploying a handler:

1. Deploy data contract;
2. Deploy a handler contract at a given address specified in the data contract;
3. Register the handler contract address by calling setHandler() in the data contract, or use an upgrader contract to switch the handler contract, which requires that data contract is initialized;
4. Initialize data contract if haven’t done it already.

```solidity
    /// Handler interface.
    /// Handler defines bussiness related functions.
    /// Use the interface to ensure that your external services are always supported.
    /// Because of function live(), we design IHandler as an abstract contract rather than a true interface.
    contract IHandler {
    
            /// Initialize the data contarct.
            /// @param _str value of exmStr of data contract.
            /// @param _int value of exmInt of data contract.
            /// @param _array value of exmArray of data contract.
            function initialize (string _str, uint256 _int, uint16 [] _array) public;
    
            /// Register upgrader contract address.
            /// @param _upgraderAddr address of the upgrader contract.
            function registerUpgrader (address _upgraderAddr) external;
    
            /// Upgrader contract calls this to check if it is registered.
            /// @return  if the upgrader contract is registered.
            function isUpgraderRegistered () external view returns(bool);
    
            /// Handler has been upgraded so the original one has to self-destruct.
            function done() external;
    
            /// Check if the handler contract is a working handler contract.
            /// It is used to prove the contract is a handler contract.
            /// @return always true.
            function live() external pure returns(bool) {
                    return true;
            }
    
            /// Functions - define functions here
    
            /// Events - add events here
    }
```


### Upgrader Interface

Below is the upgrader Interface. After implement this interface:

- The upgrader contract has the ability to take **votes** from the registered voters. The success percentage is also configurable.
  - The contract owner is able to add voters anytime before the proposal expires.
  - Voter is able to vote through vote() function.
  - Voter can check the current status of the proposal. (succeed or expired)
- Developers are able to delete this upgrader contract by calling done() anytime after deployment.

The upgrader contract works as follows:

1. Verify the data contract, its corresponding handler contract and the new handler contract have all been deployed. 
2. Deploy an upgrader contract using data contract address, previous handler contract address and new handler contract address. 
3. Register upgrader address in the new handler contract first, then the original hander and finally the data contract.
4. Call startProposal() to start the voting process
5. Call getResolution() before the expiration
6. Upgrade succeed or proposal is expired.
Note:
  - Function done() can be called at any time to let upgrader destruct itself.
  - Function status() can be called at any time to show caller status of the upgrader.

```solidity
    /// Handler upgrader
    contract IUpgrader {
            /// Data contract
            DataContract public data;
            /// Original handler contract
            IHandler public originalHandler;
            /// New handler contract
            address public newHandlerAddr;
            
            /** Marker */
            enum UpgraderStatus {
                    Preparing,
                    Voting,
                    Success,
                    Expired,
                    End
            }
            UpgraderStatus public status;
    
            /// Check if the proposal is expired.
            /// If so, contract would be marked as expired.
            /// exception    PreparingUpgraderException      proposal has not been started.
            /// exception    ReupgradingException    upgrading has been done.
            /// exception    ExpirationException     proposal is expired.
            modifier notExpired {
                    require(status != UpgraderStatus.Preparing, "Invalid proposal!");
                    require(status != UpgraderStatus.Success, "Upgrading has been done!");
                    require(status != UpgraderStatus.Expired, "Proposal is expired!");
                    if (data.canBeUpgraded(address(originalHandler)) != DataContract.UpgradingStatus.InProgress) {
                        status = UpgraderStatus.Expired;
                        require(false, "Proposal is expired!");
                    }
                 _;
             }
    
             /// Start voting.
             /// Upgrader must do upgrading check, namely checking if data contract and 2 handler contracts are ok.
             /// exception  PermissionException   msg.sender is not the owner.
             /// exception  UpgraderConflictException  another upgrader is working.
             /// exception  NoPreparationException  original or new handler contract is not prepared.
            function startProposal () external;
    
             /// Anyone can try to get resolution.
             /// If voters get consensus, upgrade the handler contract.
             /// If expired, self-destruct.
             /// Otherwise, do nothing.
             /// exception   PreparingUpgraderException   proposal has not been started.
             /// exception   ExpirationException   proposal is expired.
             /// @return     status of proposal.
            function getResolution() external returns(UpgraderStatus);
    
             /// Destruct itself.
             /// exception   PermissionException   msg.sender is not the owner.
            function done() external;
    }
```

### Example:

To demonstrate how to implement the handler contract and what a data contract looks like, here we provide an example of a data contract with the implementation of its corresponding handler contract.

### Data Contract

Below is an example of the data contract. There are three parts in the data contract:

- **Administrator Data**: owner’s address, handler contract’s address and an boolean indicating whether the contract is initialized or not. 
- **Upgrader Data**: upgrader contract’s address, upgrade proposal’s submission timestamp and proposal’s time period. 
- **Resource Data**: all other resources that the contract needs to keep and manage.

```solidity
    /// The example of data contract.
    contract DataContract {
    
            /** Upgrader data */
            enum UpgradingStatus {
                    // Can be upgraded
                    Done,
                    // In upgrading
                    InProgress,
                    // Another proposal is in progress
                    Blocked,
                    // Expired
                    Expired,
                    // Original handler contract error
                    Error
            }
    
            /** Data resources */
    
            /// Constructor.
            /// Set the period of upgrading proposal.
            /// @param   _period   default value of this.proposalPeriod.
            constructor (uint256 _period) public;
    
            /** Modifiers */
            
            /// Check if msg.sender is the handler contract. It is used for setters.
            /// If fail, throw PermissionException.
            modifier onlyHandler;
    
            /// Check if msg.sender is not permitted to call getters. It is used for getters (if necessary).
            /// If fail, throw GetterPermissionException.
            modifier allowedAddress;
    
            /// Check if the contract is working.
            /// It is used for all functions providing services after initialization.
            /// If fail, throw UninitializationException.
            modifier isReady;
    
            /** Management functions */
    
            /// Initializer. Just the handler contract can call it. 
            /// @param  _str  default value of this.exmStr.
            /// @param  _int  default value of this.exmInt.
            /// @param  _array  default value of this.exmArray.
            /// exception  PermissionException  msg.sender is not the handler contract.
            /// exception   ReInitializationException   contract has been initialized.
            /// @return   if the initialization succeeds.
            function initialize (string _str, uint256 _int, uint16 [] _array) external onlyHandler returns(bool);
    
             /// Set handler contract for the contract. Owner must set one to initialize the data contract.
             /// Handler can be set by owner or upgrader contract.
             /// @param  _handlerAddr  address of a deployed handler contract.
             /// @param  _originalHandlerAddr  address of the original handler contract, only used when an upgrader contract want to set the handler contract.
             /// exception  PermissionException  msg.sender is not the owner nor a registered upgrader contract.
             /// exception   UpgraderException   upgrader contract does not provide a right address of the original handler contract.
             /// @return   if handler contract is successfully set.
            function setHandler (address _handlerAddr, address _originalHandlerAddr) external returns(bool);
    
            /** upgrader contract functions */
    
             /// Register an upgrader contract in the contract.
             /// If a proposal has not been accepted until proposalBlockNumber + proposalPeriod, it can be replaced by a new one.
             /// @param  _upgraderAddr  address of a deployed upgrader contract.
             /// exception   PermissionException   msg.sender is not the owner.
             /// exception   UpgraderConflictException   Another upgrader contract is working.
             /// @return  if upgrader contract is successfully registed.
            function startUpgrading (address _upgraderAddr) public returns(bool);
    
            /// Getter of proposalPeriod.
            /// exception  UninitializationException   uninitialized contract.
            /// exception  GetterPermissionException  msg.sender is not permitted to call the getter.
            /// @return  this.proposalPeriod.
            function getProposalPeriod () public view isReady allowedAddress returns(uint256);
    
            /// Setter of proposalPeriod.
            /// @param   _proposalPeriod   new value of this.proposalPeriod.
            /// exception  UninitializationException  uninitialized contract.
            /// exception  PermissionException   msg.sender is not the owner.
            /// @return    if this.proposalPeriod is successfully set.
            function setProposalPeriod (uint256 _proposalPeriod) public isReady returns(bool);
    
            /// Return upgrading status for upgrader contracts.
            /// @param        _originalHandlerAddr        address of the original handler contract.
            /// exception        UninitializationException        uninitialized contract.
            /// @return        handler contract's upgrading status.
            function canBeUpgraded (address _originalHandlerAddr) external view isReady returns(UpgradingStatus);
            
            /// Check if the contract has been initialized.
            /// @return        if the contract has been initialized.
            function live () external view returns(bool);
    
            /** Getters and setters of data resources */
    }
```  

### Caveats

Since the upgrader contract has a simple voting mechanism, it is prone to all the limitations that the voting contract is facing:

  - The administrator can only be the owner of data and handler contracts. Furthermore, only the administrator has the power to add voters and start a proposal. 
  - It requires voters to be constantly active, informative and attentive to make a upgrader succeed.
  - The voting will only be valid in a given time period. If in a given time period the contract cannot collect enough “yes” to proceed, the proposal will be automatically deleted. 


## Rationale

**Data Contract and Handler Contract**
A smart contract consists of two parts: resources and operations. We propose two new contracts for each part: 

1. Data contract keeps the resources (data)
2. Handler contract contains operations. 

The Handler contract can be upgraded in the future while the Data contract is permanent. Handler contract can get and set member variables in Data contract while Data contract will provide getters and setters.

**Upgrader Contract and Voting Mechanism**
In order to prevent centralization and protect the interests of the community and stakeholders, we also design a voting mechanism in the upgrader contract. Upgrader contract contains addresses of Data contract and two Handler contracts, and collects votes from pre-defined voters to upgrade the Handler contract when the pre-set condition is fulfilled.

For simplicity, the upgradable contract comes with a very minimal version of the voting mechanism. If the contract owner wants to implement a more complex voting mechanism, he/she can modify the existing voting mechanism to incorporate upgradability. The expiration mechanism (see related functions in data contract) and upgrading check (function startProposal() in upgrader contract) to the contract are mandatory.

**Gas and Complexity** (regarding the enumeration extension)
Contract creation requires a significant amount of effort and gas. One of the advantages of upgradable contracts is that the contract owners don’t have to create new contracts; instead, they only need to upgrade parts of contract that cause issues, which is less expensive in terms of data lost and blockchain consistency. In other words, upgradable contracts makes data contract more scalable and flexible. Although upgrading contract may take some efforts and gas, it is a much less painful than deprecating the insecure contract/creating a new contract or hard fork (e.g. DAO attack). 

**Community Consensus**

Thank you to those who helped on review and revise the proposal:

- [@lsankar4033](https://github.com/lsankar4033) from MIT
- more


**We have been very inclusive in this process and invite anyone with questions or contributions into our discussion. However, this standard is written only to support the identified use cases which are listed herein.


## **Implementations**
1. [Renaissance](https://www. renaissance.app) - a protocol that connect creators and fans financially
2. [ERC54](https://www.github.com) - a reference implementation


## **Copyright**

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).


