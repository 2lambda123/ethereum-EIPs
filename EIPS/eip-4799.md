---
eip: 4799
title: Non-Fungible Token Wrapping Standard
description: A standardized interface for contracts that own NFTs and mints versions of them as wrapped NFTs
author: David Buckman (@davidbuckman), Isaac Buckman (@isaacbuckman)
discussions-to: https://ethereum-magicians.org/t/erc-4799-non-fungible-token-wrapping-standard/8396
status: Draft
type: Standards Track
category: ERC
created: 2022-02-13
requires: 165
---

## Abstract

The following defines a standard interface for NFT wrapping contracts - contracts with which users can escrow their NFTs and receive a new provably authentic wrapped NFT that represents their ownership. This allows for the introduction of additional functionality for any preexisting NFT, without sacrificing authenticity.

The standard works by exposing an interface that allows client applications to track a chain of authenticity from the original NFT contract to the final owner. The owner can transfer their NFT to an ERCX contract, which then assigns ownership according to its own code - say, back to the original owner. Then, applications that want to know who the owner of an NFT is will ask the original contract, and upon being told that the owner is an ERCX contract, will ask that ERCX contract who the owner of that token is - in our example, still the original owner. In this way, the original owner will still receive all the utility associated with their NFT, there is still only one owner for a given NFT, but the owner can now enjoy any added functionality provided by the implementation of the ERCX contract (say, the ability to rent ownership of their NFT).

The standard works by exposing an interface that allows client applications to track a chain of authenticity from the original NFT contract to the final owner. Here is an example of a simple rental contract. The owner, Owner A can transfer their NFT to an ERCX contract, which then assigns ownership according to its own code - say, back to the Owner B. Then, applications that want to know who the owner of an NFT is will ask the original contract, and upon being told that the owner is an ERCX contract, will ask that ERCX contract who the owner of that token is - in our example, still the original owner. In this way, the original owner will still receive all the utility associated with their NFT, there is still only one owner for a given NFT, but the owner can now enjoy any added functionality provided by the implementation of the ERCX contract (say, the ability to rent ownership of their NFT).

## Motivation

Many NFTs aim to provide their holders with some utility - utility that can come in many forms. This can be the right to inhabit an apartment, access to tickets to an event, an airdrop of tokens, or one of the infinitely many other potential applications. However, the widespread use of ERC-721 to implement NFTs has meant that this distribution of utility is limited in a significant way. The ERC-721 standard only provides for outright ownership - the current owner definitionally has perpetual transfer rights. This means that the utility of a standard ERC-721 can only be given to the wallet with perpetual transfer rights over that NFT (unless there is customization in the original, immutable NFT contract).

The goal of this ERC is to allow users and developers the ability to define arbitrarily complex ownership agreements on top of NFTs that have already been minted. We accomplish this goal through a wrapping standard. This way, new contracts with innovative ownership structures can be deployed, but they can still leverage the authenticity afforded by established NFT contracts - in the past a wrapping contract meant brand new NFTs with no established authenticity, but with this standard that is no longer the case. Developers can now create contracts that enable any NFT to be used in agreements for rentals, collateralized loans, fractionalized ownership, conditional ownership, and much more.

Prior to this standard, wrapping an NFT inside another contract was the only way to add functionality after deployment of the NFT contract, but this meant losing access to the utility of holding the original NFT. Any application querying for the owner of that NFT would determine the wrapping smart contract to be the owner. Using this standard, applications will have a standardized method of interacting with wrapping contracts so that they can continue to direct their utility to users even when the NFT has been wrapped.

## Specification

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

```solidity
// SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.8.0 <0.9.0;

import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import "./IERCXNFT.sol";

/// @title ERC-X Non-Fungible Token Wrapping Standard
/// @dev See https://eips.ethereum.org/EIPS/eip-[TODO]
/// Note: the ERC-165 identifier for this interface is [TODO].

interface IERCX is IERC165, IERCXNFT {
    /// @dev This event emits when an NFT is wrapped by this contract.
    /// It also emits when the wrapping NFT that represents a particular
    /// wrapped NFT changes.
    event Wrap(
        address indexed wrappedContract,
        uint256 indexed wrappedTokenId,
        uint256 indexed tokenId
    );

    /// @notice Find the tokenId of a wrapped NFT's wrapping NFT
    /// @param wrappedContract The contract address of a wrapped NFT
    /// @param wrappedTokenId The tokenId of a wrapped NFT
    /// @return The tokenId of the wrapping NFT
    function tokenIdOf(IERCXNFT wrappedContract, uint256 wrappedTokenId)
        external
        view
        returns (uint256);
}
```


```solidity
// SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.8.0 <0.9.0;

import "@openzeppelin/contracts/utils/introspection/IERC165.sol";

interface IERCXNFT is IERC165 {
    /// @dev This emits when ownership of any NFT changes by any mechanism.
    ///  This event emits when NFTs are created (`from` == 0) and destroyed
    ///  (`to` == 0). Exception: during contract creation, any number of NFTs
    ///  may be created and assigned without emitting Transfer. At the time of
    ///  any transfer, the approved address for that NFT (if any) is reset to none.
    event Transfer(
        address indexed from,
        address indexed to,
        uint256 indexed tokenId
    );

    /// @notice Find the owner of an NFT
    /// @dev NFTs assigned to zero address are considered invalid, and queries
    ///  about them throw
    /// @param tokenId The identifier for an NFT
    /// @return The address of the owner of the NFT
    function ownerOf(uint256 tokenId) external view returns (address);
}
```

The authenticity of a wrapped NFT is conferred by the wrapping contract’s ownership of the original NFT according to the original contract. This MUST be verified by clients by querying the original contract.

Clients respecting this specification SHALL NOT distribute any utility to smart contracts that implement the ERCX interface. Instead, they MUST distribute it to the wallet that the ERCX contract points them to.

## Rationale

####

To maximize the future compatibility of the wrapping contract, we first defined a canonical NFT interface. We created ERCXNFT, an interface implicitly implemented by virtually all popular NFT contracts, including all deployed contracts that are ERC-721 compliant. This interface represents the essence of an NFT: a mapping from a token identifier to the address of a singular owner, represented by the simple function ownerOf(uint256 tokenId) returns (address owner).

The core of our proposal is the ERCX interface, an interface for a standard NFT wrapping contract. ERCX was designed such that there is a function mapping every wrapped original NFT to one NFT minted by the wrapping contract, thus maintaining the core invariant that every original NFT is only owned by exactly one wallet. As such, we defined ERCX to wrap ERCXNFTs and represented wrapped tokens as ERCXNFTs. That is, both the input and output of the wrapping are ERCXNFTs. In order to find the wrapped NFT that corresponds to a given original NFT, clients use the `tokenIdOf` function declared in the ERCX interface.

By declaring this function to clients and enforcing that ERCX implements ERCXNFT, we have ensured that our wrapping standard is highly interoperable with other parts of the NFT ecosystem. This design means that all wrapped NFTs are themselves first-class NFTs, and can be used with any contract designed to interact with ERCXNFTs. This allows for seamless integration into existing applications, including the composability of NFT wrapping contracts - a wrapped NFT can itself be wrapped by either the same wrapping contract or others, creating a chain of ownership that terminates with the address of the current owner.

The primary other design that we considered for ERCX was declaring only the function ownerOf(address tokenContract, uint256 externalTokenId) returns (address owner), which is the minimal function to redirect ownership of an external token. However, this design would sacrifice the interoperability guarantee, since there is no requirement that this representation of redirected ownership is itself an NFT. We thought it was highly valuable to ensure that both the input and the output of an ERCX wrapper was an NFT, so elected to require ERCX to implement ERCXNFT and expose the tokenId of wrapped NFTs to clients.

## Backwards Compatibility

The ERCXNFT standard is backwards compatible with ERC-721, as ERC-721 implicitly extends ERCXNFT. This means that the ERCX standard, which wraps NFTs that implement ERCXNFT, is fully backwards compatible with ERC721.

## Reference Implementation

```solidity
// SPDX-License-Identifier: UNLICENSED

pragma solidity >=0.8.0 <0.9.0;

import "./IERCX.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract ERC721Wrapper is IERCX, ERC721, IERC721Receiver {
    mapping(address => mapping(uint256 => uint256)) private _tokenIds;

    uint256 private counter;

    constructor() ERC721("", "") {}

    function tokenIdOf(address tokenContract, uint256 externalTokenId)
        public
        view
        override
        returns (uint256)
    {
        return _tokenIds[tokenContract][externalTokenId];
    }

    function ownerOf(uint256 tokenId)
        public
        view
        override(IERCXNFT, ERC721)
        returns (address)
    {
        return super.ownerOf(tokenId);
    }

    function ownerOf(address tokenContract, uint256 externalTokenId)
        public
        view
        override
        returns (address)
    {
        return ownerOf(tokenIdOf(tokenContract, externalTokenId));
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(IERC165, ERC721)
        returns (bool)
    {
        return
            interfaceId == type(IERCX).interfaceId ||
            interfaceId == type(IERC721Receiver).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function _increment() internal returns (uint256) {
        unchecked {
            counter += 1;
        }
        return counter;
    }

    function _wrap(
        address tokenContract,
        uint256 externalTokenId,
        address from
    ) internal {
        IERC721(tokenContract).approve(from, externalTokenId);
        uint256 tokenId = _increment();
        _tokenIds[tokenContract][externalTokenId] = tokenId;
        _safeMint(from, tokenId);
        emit Wrap(tokenContract, externalTokenId, tokenId);
    }

    function onERC721Received(
        address,
        address from,
        uint256 tokenId,
        bytes calldata
    ) external override returns (bytes4) {
        _wrap(_msgSender(), tokenId, from);
        return IERC721Receiver.onERC721Received.selector;
    }
}
```
```solidity
pragma solidity >=0.8.0 <0.9.0;
//SPDX-License-Identifier: MIT

import "./IERCX.sol";
import "./IERCXNFT.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol";

contract GetOwner {
    function getOwner(
        IERCXNFT tokenContract,
        uint256 tokenId,
        uint256 depthLimit
    ) public view returns (address owner) {
        owner = tokenContract.ownerOf(tokenId);
        if (ERC165Checker.supportsInterface(owner, type(IERCX).interfaceId)) {
            require(depthLimit > 0, "getOwner: depth limit exceeded");
            return
                getOwner(
                    IERCX(owner),
                    IERCX(owner).tokenIdOf(tokenContract, tokenId),
                    depthLimit - 1
                );
        }
    }
}
```

## Security Considerations

##### Long/Cyclical Chains of Ownership

The primary security concern is that of malicious actors creating excessively long or cyclical chains of ownership, leading applications that attempt to query for the owner of an external token to run out of gas and be unable to function. To address this, clients are expected to always query considering a `maxDepth` parameter, cutting off computation after a certain number of redirections. Our library implementation of `ownerOf` will include this parameter.

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).