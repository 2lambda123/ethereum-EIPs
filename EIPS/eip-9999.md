---
eip: <To be assigned>
title: Chain Reaction
author: Alberto Cuesta Ca√±ada (@albertocuestacanada)
discussions-to: <To be added>
status: Draft
type: Standards Track
category: ERC
created: 2021-03-06
---

## Simple Summary

This ERC provides a standard for smart contracts to chain one or more local calls to one call in another smart contract.

## Abstract

This standard is a generalization of ERC667, in which we remove:
 - The specialization to ERC20.transfer functions.
 - The duplication of functions, only one function is required per contract implementing ERC9999Caller.

In this standard we include:
 - Interfaces and processes for an ERC9999Receiver to react to a call from an ERC9999Caller, with knowledge of the previous call for a minimal gas cost.

## Motivation

[To be added]

## Specification

A chain reaction pattern integrates two smart contracts. These are called the CALLER and the RECEIVER in this EIP.

### Receiver Specification

A `receiver` of MUST implement the IERC9999Receiver interface:

```
interface IERC9999Receiver {
    function receiveControl(
        bytes calldata lastCall,
        bytes calldata thisCall
    ) external returns (bytes32);
}
```

If successful, `receiveControl` MUST return the keccak256 hash of "ERC9999Receiver.receiveControl".

The `lastCall` parameter includes the abi-encoded data of the function call that preceded `receiveControl`:
 - msg.sender
 - msg.value
 - last abi-encoded local call
 - abi-encoded output of the last local call

The `thisCall` parameter is the abi-encoded data of the function to be called in `receiver`.

### Caller Specification

A `caller` MUST call the `receiveControl` function on an IERC9999Receiver, as specified above.

## Rationale

[What I've done is to go back to the very beginning of the ERC667 discussion, and choose a different set of trade offs. From the beginning, it was assumed that the receiver of the control couldn't trust the contract in which the `transfer` was executed. From ERC3156 I know this is false.]

[In addition to that, using an adaptation of the `multicall` pattern in ENS, we can avoid duplicating every function in a contract. We can just add one function to any contract, and any function in that contract can be chained to a call in a remote contract.]

[I've also removed the restriction that the receiver of the control must be the receiver of the tokens.]

[Taking some lessons from ERC3156, we pack the details (msg.sender, msg.sig, msg.value, parameters and outputs) of the local call along with the remote call, so the receiver contract can decide what to do.]

[
The biggest upsides are:
 - External calls to a service like ERC1820 are not needed, which makes it cheaper than ERC777.
 - Callers only need to inherit a contract, making the standard easy to adopt.
 - Flexible, can be used for any contract (ERC20, ERC721, whatever).

The biggest downsides are:
 - Complexity in the receiver, which needs to verify the caller and then decode the previous call. However, this is mitigated by allowing arbitrary receivers.
 - Opacity of the transaction signed. However, given that it is a list of abi-encoded function calls, UIs should be able to decode them and show them to the user on signing.
]

## Backwards Compatibility

No backwards compatibility issues identified.

## Implementation

### ERC9999Caller Reference Implementation

```
// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.8.0;

/// @dev Contracts wishing to pass the control to ERC9999Receiver contracts must inherit this contract
contract ERC9999User {

    // Do a local call.
    // Pack its inputs (msg.sig, msg.sender, msg.value, parameters) and outputs.
    // Pass the details about the executed local call to an ERC9999Receiver, along with an abi-encoded call for the ERC9999REceiver to execute
    function chainCall(bytes calldata localCall, IERC9999Receiver receiver,  bytes calldata remoteCall) public returns(bytes[] memory results) {
        // Inspired in multicall from ENS - https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/PublicResolver.sol#L56-L64
        results = new bytes[](2);
        (bool success, bytes memory result) = address(this).delegatecall(localCall);
        require(success);
        results[0] = result;
        // Pack the local call with msg.sender, msg.value, and call output with into lastCall.
        bytes lastCall = abi.encode(msg.sender, msg.value, localCall, result);
        // Then we execute the remote call
        require(
            receiver.receiveControl(lastCall, remoteCall) == ERC9999_SUCCESS,
            "Remote call failed"
        );
        results[1] = ERC9999_SUCCESS;
        return results;
    }

    // Same as above, but do an arbitrary amount of local calls before passing control to the ERC9999Receiver.
    // Only the details of the last call executed need to be passed along.
    function chainMulticall(bytes[] calldata localCalls, IERC9999Receiver receiver,  bytes calldata remoteCall) public returns(bytes[] memory results) {
        // First we copy multicall from ENS - https://github.com/ensdomains/resolvers/blob/f7d62ab04bfe1692a4344f6f1d31ff81315a98c3/contracts/PublicResolver.sol#L56-L64
        results = new bytes[](localCalls.length + 1);
        for(uint i = 0; i < localCalls.length; i++) {
            (bool success, bytes memory result) = address(this).delegatecall(localCalls[i]);
            require(success);
            results[i] = result;
        }
        // Pack the last local call with msg.sender, msg.value, and call output with into lastCall.
        bytes lastCall = if (localCalls.length > 0) abi.encode(msg.sender, msg.value, localCalls[localCalls.length - 1], result) : 0x00;
        // Then we execute the remote call
        require(
            receiver.receiveControl(lastCall, remoteCall) == ERC9999_SUCCESS,
            "Remote call failed"
        );
        results[localCalls.length] = ERC9999_SUCCESS;
        return results;
    }
}
```

### ERC9999 Receiver Reference Implementation

```
/// @dev Contracts wishing to receive the control from ERC9999 contracts must implement this interface
interface ERC9999Receiver {

    // Recommended implementation:
    // 1. If the data from the lastCall is going to be decoded, verify that msg.sender is trusted.
    // 2. Extract lastCallMsgSender, lastCallMsgValue, lastCall and bytes lastCallOutput
    // 3. Verify that the first 4 bytes of lastCall are known to this contract, and therefore allows decoding lastCallParameters and bytes lastCallOutput
    // 4. Do whatever needs to be done
    // 5. return keccak256(ERC9999.receiveControl)
    function receiveControl(bytes calldata lastCall, bytes calldata thisCall) public returns(bytes32);
}
```

## Security Considerations

### Verification of callback arguments

The `lastCall` of `receiveControl` is expected to reflect the conditions of the previous call, but cannot be trusted unconditionally. To trust the veracity of `lastCall` the `receiver` must match `msg.sender` against a list of trusted callers.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
