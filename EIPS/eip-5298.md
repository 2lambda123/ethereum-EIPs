---
eip: 5298
title: ENS as Token Holder
description: An interface for a smart contract acting as a "trust" that holds tokens by ENS name.
author: Zainan Victor Zhou (@xinbenlv)
discussions-to: https://ethereum-magicians.org/t/erc-eip-5198-ens-as-token-holder/10374
status: Draft
type: Standards Track
category: ERC
created: 2022-07-12
requires: 137, 721, 1155
---

## Abstract
An interface for smart contract to become a holder of tokens by honoring ENS ownership.
This specification supports [EIP-721](./eip-721.md) and [EIP-1155](./eip-1155.md) tokens and is expandable to future token standard or other standard.

## Motivation
Currently, if someone wants to receive a token, they have to set up a wallet address. By creating a smart contract that conforms to this interface specification, it is possible to decouple the transfer of ownership from the existence of wallet addresses.

## Specification

1. Any conforming smart contract must conform to `ERC721TokenReceiver` defined in [EIP-721](./eip-721.md) and `ERC1155TokenReceiver` defined in [EIP-1155](./eip-1155.md).

```solidity
interface IERC_ENS_AS_HOLDER is ERC721Receiver, ERC1155Receiver {
}
```

## Rationale

1. We choose ENS because it's a scoped ownership namespace.
This ERC shall also be able to work in other scoped ownership namespace approach.

## Backwards Compatibility

No backward compatibility issues were found.

## Reference Implementation

```solidity
// ALL CODE HERE IS WRITEN DURING ETHSF HACKATHON 2022
// AND IS NOT MEANT TO BE USED IN PRODUCTION

pragma solidity ^0.8.9;
import "@ensdomains/ens-contracts/contracts/registry/ENS.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
// Import ownershiop
import "@openzeppelin/contracts/access/Ownable.sol";

struct TokenHolding {
    address contractAddress;
    uint256 tokenId;
}

// TODO consider how to handle ERC1155 when amount is involved and can be splitted by multiple owners
contract FirstENSBankAndTrust is IERC721Receiver, Ownable {
    // Same address for Mainet, Ropsten, Rinkerby, Gorli and other networks;
    address constant DEFAULT_GLOBAL_ENS = 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e;
    address private ensAddress = DEFAULT_GLOBAL_ENS;
    bytes4 constant ERC721_RECEIVER_MAGICWORD = bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"));

    mapping(bytes32 => TokenHolding[]) public erc721NodeToTokenMap;
    mapping(bytes32/*hash of TokenHolding*/ => bytes32/*node of owner*/) public erc721TokenToNodeMap;
    mapping(bytes32/*hash of TokenHolding*/ => mapping(bytes32/*node of owner*/=> uint256)) public erc721NodeToHoldingIndex;

    function getENS() public view returns (ENS) {
        return ENS(ensAddress);
    }

    function setENS(address newENSAddress) public onlyOwner {
        ensAddress = newENSAddress;
    }

    // @dev This function is called by the owner of the token to approve the transfer of the token
    // @param data MUST BE the ENS node of the intended token receiver this ENSHoldingServiceForNFT is holding on behalf of.
    function onERC721Received(
        address operator,
        address /*from*/,
        uint256 tokenId,
        bytes calldata data
    ) external override returns (bytes4) {
        require(data.length == 32, "ENSTokenHolder: last data field must be ENS node.");
        // --- START WARNING ---
        // DO NOT USE THIS IN PROD
        // this is just a demo purpose of using extraData for node information
        // In prod, you should use a struct to store the data. struct should clearly identify the data is for ENS
        // rather than anything else.
        bytes32 ensNode = bytes32(data[0:32]);
        // --- END OF WARNING ---

        addToHolding(ensNode, operator, tokenId);
        return ERC721_RECEIVER_MAGICWORD;
    }

    function addToHolding(bytes32 ensNode, address operator, uint256 tokenId) internal {
        bytes32 tokenHash = keccak256(abi.encodePacked(operator, tokenId));
        erc721NodeToHoldingIndex[ensNode][tokenHash] = erc721NodeToTokenMap[ensNode].length;
        erc721NodeToTokenMap[ensNode]
            .push(TokenHolding(msg.sender, tokenId));
        erc721TokenToNodeMap[tokenHash] = ensNode;
    }

    function removeFromHolding(bytes32 ensNode, address operator, uint256 tokenId) internal {
        bytes32 tokenHash = keccak256(abi.encodePacked(operator, tokenId));
        require(erc721TokenToNodeMap[tokenHash] == ensNode, "ENSTokenHolder: token not in holding");
        uint256 index = erc721NodeToHoldingIndex[ensNode][tokenHash];
        uint256 lastIndex = erc721NodeToTokenMap[ensNode].length - 1;
        TokenHolding memory lastTokenHolding = erc721NodeToTokenMap[ensNode][lastIndex];
        erc721NodeToTokenMap[ensNode][index] = lastTokenHolding;
        bytes32 lastTokenHoldingHash = keccak256(abi.encodePacked(lastTokenHolding.contractAddress, lastTokenHolding.tokenId));
        erc721NodeToHoldingIndex[ensNode][lastTokenHoldingHash] = index;
        erc721NodeToTokenMap[ensNode].pop();
        delete erc721NodeToHoldingIndex[ensNode][tokenHash];
        delete erc721TokenToNodeMap[tokenHash];
    }

    function claimTo(address to, bytes32 ensNode, address operator, uint256 tokenId) public {
        require(getENS().owner(ensNode) == msg.sender, "ENSTokenHolder: node not owned by sender");
        removeFromHolding(ensNode, operator, tokenId);
        IERC721(operator).safeTransferFrom(address(this), to, tokenId);
    }
}
```

## Test Cases

```ts
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import { expect } from "chai";
import { ethers } from "hardhat";

describe("TheResolver", function () {
    async function deployFixture() {
        // Contracts are deployed using the first signer/account by default
        const [owner, alice, bob, charlie] = await ethers.getSigners();

        const FirstENSBankAndTrust = await ethers.getContractFactory("FirstENSBankAndTrust");
        const firstENSBankAndTrust = await FirstENSBankAndTrust.deploy();

        const ENSForTesting = await ethers.getContractFactory("ENSForTesting");
        const ensForTesting = await ENSForTesting.deploy();

        const ERC721ForTesting = await ethers.getContractFactory("ERC721ForTesting");
        const erc721ForTesting = await ERC721ForTesting.deploy();

        await firstENSBankAndTrust.setENS(ensForTesting.address);
        expect(await firstENSBankAndTrust.getENS()).to.equal(ensForTesting.address);

        return {
            firstENSBankAndTrust,
            ensForTesting,
            erc721ForTesting,
            owner,
            alice, bob, charlie,
        };
    }

    describe("Receive and Claim Token", function () {
        const fakeTokenId = 3;
        const fakeReceiverENS = "bob.xinbenlvethsf.eth";
        const fakeReceiverENSNamehash = ethers.utils.namehash(fakeReceiverENS);
        it("Should ACCEPT transfer if a node is specified.", async function () {
            const {
                firstENSBankAndTrust,
                erc721ForTesting,
                owner, alice, bob, charlie
            } = await loadFixture(deployFixture);
            await erc721ForTesting.mint(charlie.address, fakeTokenId);
            expect(await erc721ForTesting.ownerOf(fakeTokenId)).to.equal(charlie.address);
            await erc721ForTesting.connect(charlie)["safeTransferFrom(address,address,uint256,bytes)"](
                charlie.address,
                firstENSBankAndTrust.address,
                fakeTokenId,
                ethers.utils.arrayify(fakeReceiverENSNamehash)
            );

            expect(await erc721ForTesting.ownerOf(fakeTokenId)).to.equal(firstENSBankAndTrust.address);
        });

        it("Should REJECT transfer if a node is NOT specified.", async function () {
            const {
                firstENSBankAndTrust,
                erc721ForTesting,
                owner, alice, bob, charlie
            } = await loadFixture(deployFixture);
            await erc721ForTesting.mint(charlie.address, fakeTokenId);
            expect(await erc721ForTesting.ownerOf(fakeTokenId)).to.equal(charlie.address);
            await expect(erc721ForTesting.connect(charlie)["safeTransferFrom(address,address,uint256,bytes)"](
                charlie.address, firstENSBankAndTrust.address, fakeTokenId, []))
                .to.be.rejectedWith("ENSTokenHolder: last data field must be ENS node.");
        });

        it("Should REJECT claimTo if ENS owner is not msg.sender", async function () {

            const {
                firstENSBankAndTrust,
                erc721ForTesting,
                ensForTesting,
                owner: deployer, alice, bob, charlie
            } = await loadFixture(deployFixture);
            // Steps of testing:
            // mint to charlie
            // charlie send to ENSTrust and recorded under bob.xinbenlvethsf.eth
            // bob try to claimTo alice, first time it should be rejected
            // bob then set the ENS record
            // bob claim to alice, second time it should be accepted

            // mint to charlie
            await erc721ForTesting.mint(charlie.address, fakeTokenId);

            // charlie send to ENSTrust and recorded under bob.xinbenlvethsf.eth
            await erc721ForTesting.connect(charlie)["safeTransferFrom(address,address,uint256,bytes)"](
                charlie.address, firstENSBankAndTrust.address,
                fakeTokenId,
                fakeReceiverENSNamehash
            );

            // bob try to claimTo alice, first time it should be rejected
            await expect(firstENSBankAndTrust.connect(bob).claimTo(
                alice.address,
                fakeReceiverENSNamehash,
                firstENSBankAndTrust.address,
                fakeTokenId
                ))
                .to.be.rejectedWith("ENSTokenHolder: node not owned by sender");

            // bob then set the ENS record
            await ensForTesting.setOwner(
                fakeReceiverENSNamehash, bob.address
            );

            // bob claim to alice, second time it should be accepted
            await expect(firstENSBankAndTrust.connect(bob).claimTo(
                alice.address,
                fakeReceiverENSNamehash,
                erc721ForTesting.address,
                fakeTokenId
            ));
        });
    });
});
```

## Security Considerations
Needs discussion

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).
