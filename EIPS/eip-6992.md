---
eip: 6992
title: ECC DSS signatures
description: An opcode to verify ECC DSS signatures.
author: Simon James (@JKincorperated)
discussions-to: https://ethereum-magicians.org/t/draft-eip-6992-ecc-dss-signatures
status: Draft
type: Standards Track
category: Core
created: 2023-04-25
---

## Abstract

This EIP allows for smart contracts to verify DSS signatures.

## Motivation

This EIP allows for check signatures which should allow for an smoother transition from web2 to web3. While it might seem counter-intuitive to defeat the "true decentralization" of ethereum it should prove to have some major advantages like polling external data sources or creating random data while verifing data authenticity.

## Specification

### Precompiled Contract

Precompiled Contract Address : 0x0a
Gas cost: 15000 (minimum)
Inputs:

- Body (string): A selection of data.
- Signature (bytes): The signature of the data
- PublicKey (string): An ECC P-256 public key in PEM format

Output:

- Verified (bool): True if the data is correctly signed.

Description:
This contract must encode the data to bytes using utf-8 and then must hash the Body field with the SHA256. Then, the contract should verify against the ECC P-256 public key which should be used to verify the signature against the data using the fips-186-3 DSS signing algorithm.

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

## Rationale

TBD

## Backwards Compatibility

No backward compatibility issues found.

## Test Cases

Opcode : 0xa5

(before) ["Hello World", 0x1234567890, "[validpublickey]"]
(after)  [... , true]

In this sense the server should have made a DNS query to the subdomain "\_domainkey.example.com".

## Reference Implementation

Example solidity contract for verification

```

// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.18;

contract Example {
    function randomNumber(string calldata data, bytes calldata hash) public {
        if (!verifySignature(data, hash, "validkey")) {
            revert();
        } else {
            // Very secret code here
        }
    } 

    function verifySignature(string calldata data, bytes calldata hash, string memory key) private returns (bool) {
        (bool ok, bytes memory out) = address(10).staticcall(data, hash, key);
        require(ok);
        return out;
    }
}

```

## Security Considerations

Needs discussion.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
