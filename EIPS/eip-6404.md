---
eip: 6404
title: SSZ transactions, receipts, and withdrawals
description: Migration of MPT commitments for transactions, receipts, and withdrawals to SSZ
author: Etan Kissling (@etan-status)
discussions-to: https://ethereum-magicians.org/t/eip-6404-ssz-transactions-receipts-and-withdrawals/12783
status: Draft
type: Standards Track
category: Core
created: 2023-01-30
requires: 155, 658, 1559, 2718, 2930, 4844, 4895
---

## Abstract

This EIP defines a migration process of existing Merkle-Patricia Trie (MPT) commitments for transactions, receipts, and withdrawals to SSZ.

## Motivation

While the consensus `ExecutionPayload` and the execution block structure map to each other conceptually, they are encoded differently. This EIP aims to align the encoding of their fields, taking advantage of the more modern SSZ format. This brings several advantages:

1. **Reducing complexity:** Merkle-Patricia Tries (MPT) are hard to work with. Replacing them with SSZ leaves only the state trie in the legacy MPT format.

2. **Better for smart contracts:** The SSZ format is optimized for production and verification of merkle proofs. It allows proving specific fields of containers and allows chunked processing, e.g., to support handling transactions that do not fit into calldata.

3. **Better for light clients:** Light clients with access to the consensus `ExecutionPayload` no longer need to obtain the matching execution block header to verify proofs rooted in `transactions_root` or `withdrawals_root`. Note that the `receipts_root` is currently represented as a MPT root across both execution and consensus.

4. **Reducing ambiguity:** The names `transactions_root` and `withdrawals_root` are currently used to refer to different roots. The execution block header refers to a MPT root, the consensus `ExecutionPayloadHeader` refers to a SSZ root.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### SSZ

#### `Optional[T]`

A new [SSZ type](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/ssz/simple-serialize.md) is introduced to represent `Optional[T]` values.

- If value is `None`, serialize as `[]`, and merkleize as `List[T, 1]` with length `0`.
- If value is not `None`, serialize as `T`, and merkleize as `List[T, 1]` with length `1`.
- Serialize `Optional[T]` as variable-size object (create offset-table entry in enclosing containers).

#### Fixed capacity `Container` (TBD)

The merkleization for SSZ `Container` structures generates a tree of minimum depth to contain all leaves. This is problematic whenever the number of leaves changes to require a different power of 2, as all `GeneralizedIndex` values change.

SSZ `Container` structures should be annotated with a maximum capacity, similar to SSZ `List`. Unused space would be zero-extended accordingly.

TBD

### Transactions

This design proposes a single normalized `Transaction` type. To include a transaction from an earlier type into a block, it needs to be migrated using `upgrade_signed_rlp_transaction_to_ssz`. For the purpose of signature validation, the originally signed transaction hash can be recomputed using `get_transaction_sighash`. For applications that need a perpetual identifier, `get_transaction_id` can be used.

#### Hash version

For the purpose of transaction signature validation, it is necessary to recover the originally signed transaction hash. A new enumeration is introduced to indicate the original transaction hashing method. Note that this is different from the [EIP-2718](./eip-2718.md) transaction type, as legacy transactions may have been signed using different methods. The [EIP-2718](./eip-2718.md) transaction type is still used to encapsule different transaction formats on the network.

| Name | SSZ equivalent | Description |
| - | - | - |
| `TxHashVersion` | `uint8` | Original hashing method used for signing the transaction

| Name | Value | Description |
| - | - | - |
| `TX_HASH_VERSION_LEGACY` | `TxHashVersion(0x00)` | Replayable [`LegacyTransaction`](./eip-2718.md#transactions) |
| `TX_HASH_VERSION_EIP155` | `TxHashVersion(0x01)` | [EIP-155](./eip-155.md) `LegacyTransaction` |
| `TX_HASH_VERSION_EIP2930` | `TxHashVersion(0x02)` | [EIP-2930](./eip-2930.md#definitions) transaction |
| `TX_HASH_VERSION_EIP1559` | `TxHashVersion(0x03)` | [EIP-1559](./eip-1559.md#specification) transaction |
| `TX_HASH_VERSION_EIP4844` | `TxHashVersion(0x04)` | [EIP-4844](./eip-4844.md#parameters) transaction |

#### Execution block changes (Transactions)

A new `Transaction` SSZ container is introduced to represent transactions.

| Name | SSZ equivalent |
| - | - |
| [`BLSFieldElement`](./eip-4844.md#type-aliases) | `uint256` |
| [`VersionedHash`](./eip-4844.md#type-aliases) | `Bytes32` |
| [`KZGCommitment`](./eip-4844.md#type-aliases) | `Bytes48` |
| [`KZGProof`](./eip-4844.md#type-aliases) | `Bytes48` |

| Name | Value |
| - | - |
| [`FIELD_ELEMENTS_PER_BLOB`](./eip-4844.md#parameters) | `uint64(2**12)` (= 4,096) |
| [`MAX_VERSIONED_HASHES_LIST_SIZE`](./eip-4844.md#parameters) | `uint64(2**24)` (= 16,777,216) |
| [`MAX_CALLDATA_SIZE`](./eip-4844.md#parameters) | `uint64(2**24)` (= 16,777,216) |
| [`MAX_ACCESS_LIST_SIZE`](./eip-4844.md#parameters) | `uint64(2**24)` (= 16,777,216) |
| [`MAX_ACCESS_LIST_STORAGE_KEYS`](./eip-4844.md#parameters) | `uint64(2**24)` (= 16,777,216) |
| [`MAX_TX_WRAP_KZG_COMMITMENTS`](./eip-4844.md#parameters) | `uint64(2**24)` (= 16,777,216) |
| [`LIMIT_BLOBS_PER_TX`](./eip-4844.md#parameters) | `uint64(2**24)` (= 16,777,216) |

```python
class AccessTuple(Container):
    address: Address
    storage_keys: List[Hash, MAX_ACCESS_LIST_STORAGE_KEYS]

class Transaction(Container):
    chain_id: uint64  # EIP-155
    nonce: uint64
    max_priority_fee_per_gas: uint256  # EIP-1559
    max_fee_per_gas: uint256  # aka `gasprice`
    gas_limit: uint64  # aka `startgas`
    to: Optional[Address]  # None: deploy contract
    value: uint256
    data: ByteList[MAX_CALLDATA_SIZE]
    access_list: List[AccessTuple, MAX_ACCESS_LIST_SIZE]  # EIP-2930
    blob_versioned_hashes: List[VersionedHash, MAX_VERSIONED_HASHES_LIST_SIZE]  # EIP-4844

class ECDSASignature(Container):
    y_parity: boolean  # EIP-2930
    r: uint256
    s: uint256

class SignedTransaction(Container):
    tx: Transaction
    signature: ECDSASignature
    hash_version: TxHashVersion

class BlobTransactionExtension(Container):
    blob_kzgs: List[KZGCommitment, MAX_TX_WRAP_KZG_COMMITMENTS]
    blobs: List[Vector[BLSFieldElement, FIELD_ELEMENTS_PER_BLOB], LIMIT_BLOBS_PER_TX]
    kzg_aggregated_proof: KZGProof

class TransactionPayload(Container):
    signed_tx: SignedTransaction
    blob: Optional[BlobTransactionExtension]  # EIP-4844
```

On the network, `TransactionPayload` is preceded by a single byte, [`BLOB_TX_TYPE`](./eip-4844.md#parameters) to distinguish from other transaction formats according to [EIP-2718](./eip-2718.md), regardless of the inner `signed_tx.hash_version`.

#### Consensus `ExecutionPayload` changes (Transactions)

The [consensus `ExecutionPayload`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/beacon-chain.md#executionpayload) is updated to replace the existing [consensus `Transaction`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/bellatrix/beacon-chain.md#custom-types) container with the new `SignedTransaction` container.

| Name | Value | Description |
| - | - | - |
| [`MAX_TRANSACTIONS_PER_PAYLOAD`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/bellatrix/beacon-chain.md#execution) | `uint64(2**20)` (= 1,048,576) | Maximum amount of transactions allowed in each block |

```python
class ExecutionPayload(Container):
    ...
    transactions: List[SignedTransaction, MAX_TRANSACTIONS_PER_PAYLOAD]  # Formerly, `Transaction`
    ...
```

#### Execution block header changes (Transactions)

The execution block header's `transactions_root` is updated to match the consensus `ExecutionPayloadHeader`.

To compute the new `transactions_root`, the list of individual `SignedTransaction` containers is represented as a SSZ `List`.

```python
block_header.transactions_root == hash_tree_root(List[SignedTransaction, MAX_TRANSACTIONS_PER_PAYLOAD](
    transaction_0,
    transaction_1,
    transaction_2,
    ...
))
```

##### Transaction validation

```python
def get_transaction_sighash(tx: Transaction, hash_version: TxHashVersion) -> bytes:
    if hash_version == TX_HASH_VERSION_EIP4844:
        return keccak([0x05] + hash_tree_root(tx))

    assert len(tx.blob_versioned_hashes) == 0

    if hash_version == TX_HASH_VERSION_EIP1559:
        schema = (
            (big_endian_int, tx.chain_id),
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_priority_fee_per_gas),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (List([Binary[20, 20], List([Binary[32, 32]])]), [
                (access_tuple.address, access_tuple.storage_keys) for access_tuple in tx.access_list
            ]),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak([0x02] + rlp.encode(values, sedes))

    assert tx.max_priority_fee_per_gas == tx.max_fee_per_gas

    if hash_version == TX_HASH_VERSION_EIP2930:
        schema = (
            (big_endian_int, tx.chain_id),
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (List([Binary[20, 20], List([Binary[32, 32]])]), [
                (access_tuple.address, access_tuple.storage_keys) for access_tuple in tx.access_list
            ]),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak([0x01] + rlp.encode(values, sedes))

    assert len(tx.access_list) == 0

    if hash_version == TX_HASH_VERSION_EIP155:
        schema = (
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (big_endian_int, tx.chain_id),
            (big_endian_int, 0),
            (big_endian_int, 0),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak(rlp.encode(values, sedes))

    assert tx.chain_id == 0

    if hash_version == TX_HASH_VERSION_LEGACY:
        schema = (
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak(rlp.encode(values, sedes))

    assert False
```

```python
def get_transaction_id(signed_tx: SignedTransaction) -> bytes:
    hash_version = signed_tx.hash_version

    if hash_version == TX_HASH_VERSION_EIP4844:
        return keccak([0x05] + hash_tree_root(signed_tx))

    assert len(tx.blob_versioned_hashes) == 0

    if hash_version == TX_HASH_VERSION_EIP1559:
        schema = (
            (big_endian_int, tx.chain_id),
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_priority_fee_per_gas),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (List([Binary[20, 20], List([Binary[32, 32]])]), [
                (access_tuple.address, access_tuple.storage_keys) for access_tuple in tx.access_list
            ]),
            (big_endian_int, 1 if signed_tx.signature.y_parity else 0),
            (big_endian_int, signed_tx.signature.r),
            (big_endian_int, signed_tx.signature.s),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak([0x02] + rlp.encode(values, sedes))

    assert tx.max_priority_fee_per_gas == tx.max_fee_per_gas

    if hash_version == TX_HASH_VERSION_EIP2930:
        schema = (
            (big_endian_int, tx.chain_id),
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (List([Binary[20, 20], List([Binary[32, 32]])]), [
                (access_tuple.address, access_tuple.storage_keys) for access_tuple in tx.access_list
            ]),
            (big_endian_int, 1 if signed_tx.signature.y_parity else 0),
            (big_endian_int, signed_tx.signature.r),
            (big_endian_int, signed_tx.signature.s),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak([0x01] + rlp.encode(values, sedes))

    assert len(tx.access_list) == 0

    if hash_version == TX_HASH_VERSION_EIP155:
        schema = (
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (big_endian_int, (1 if signed_tx.signature.y_parity else 0) + tx.chain_id * 2 + 35),
            (big_endian_int, signed_tx.signature.r),
            (big_endian_int, signed_tx.signature.s),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak(rlp.encode(values, sedes))

    assert tx.chain_id == 0

    if hash_version == TX_HASH_VERSION_LEGACY:
        schema = (
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (big_endian_int, (1 if signed_tx.signature.y_parity else 0) + 27),
            (big_endian_int, signed_tx.signature.r),
            (big_endian_int, signed_tx.signature.s),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak(rlp.encode(values, sedes))

    assert False
```

```python
def validate_transaction_payload(payload: TransactionPayload):
    if payload.signed_tx.hash_version < TX_HASH_VERSION_EIP4844:
        assert len(payload.signed_tx.tx.blob_versioned_hashes) == 0

    if payload.signed_tx.hash_version < TX_HASH_VERSION_EIP1559:
        assert payload.signed_tx.tx.max_priority_fee_per_gas == payload.signed_tx.tx.max_fee_per_gas

    if payload.signed_tx.hash_version < TX_HASH_VERSION_EIP2930:
        assert len(payload.signed_tx.tx.access_list) == 0

    if payload.signed_tx.hash_version < TX_HASH_VERSION_EIP155:
        assert payload.signed_tx.tx.chain_id == 0

    if len(payload.signed_tx.tx.blob_versioned_hashes) == 0:
        assert payload.blob is None
    else:
        assert payload.blob is not None

        # Based on EIP-4844 logic
        versioned_hashes = payload.signed_tx.tx.blob_versioned_hashes
        commitments = payload.blob.blob_kzgs
        blobs = payload.blob.blobs
        # note: assert blobs are not malformatted
        assert len(versioned_hashes) == len(commitments) == len(blobs)

        # Verify that commitments match the blobs by checking the KZG proof
        assert verify_aggregate_kzg_proof(blobs, commitments, payload.blob.kzg_aggregated_proof)

        # Now that all commitments have been verified, check that versioned_hashes matches the commitments
        for versioned_hash, commitment in zip(versioned_hashes, commitments):
            assert versioned_hash == kzg_to_versioned_hash(commitment)
```

##### Upgrading transactions to SSZ

```python
def upgrade_signed_rlp_transaction_to_ssz(rlp_encoded_tx: bytes) -> SignedTransaction:
    tx_type = rlp_encoded_tx[0]  # EIP-2718 transaction type

    if tx_type == 0x02:
        class SignedEIP1559Transaction(rlp.Serializable):
            fields = (
                ('chain_id', big_endian_int),
                ('nonce', big_endian_int),
                ('max_priority_fee_per_gas', big_endian_int),
                ('max_fee_per_gas', big_endian_int),
                ('gas_limit', big_endian_int),
                ('destination', binary),
                ('amount', big_endian_int),
                ('data', binary),
                ('access_list', List([Binary[20, 20], List([Binary[32, 32]])])),
                ('signature_y_parity', big_endian_int),
                ('signature_r', big_endian_int),
                ('signature_s', big_endian_int),
            )
        pre = SignedEIP1559Transaction.deserialize(rlp_encoded_tx[1:])

        return SignedTransaction(
            tx=Transaction(
                chain_id=pre.chain_id,
                nonce=pre.nonce,
                max_priority_fee_per_gas=pre.max_priority_fee_per_gas,
                max_fee_per_gas=pre.max_fee_per_gas,
                gas_limit=pre.gas_limit,
                to=Address(pre.destination) if len(pre.destination) > 0 else None,
                value=pre.amount,
                data=pre.data,
                access_list=[AccessTuple(
                    address=access_tuple[0],
                    storage_keys=access_tuple[1],
                ) for access_tuple in pre.access_list],
            ),
            signature=ECDSASignature(
                y_parity=pre.signature_y_parity != 0,
                r=pre.signature_r,
                s=pre.signature_s,
            ),
            hash_version=TX_HASH_VERSION_EIP1559,
        )

    if tx_type == 0x01:
        class SignedEIP2930Transaction(rlp.Serializable):
            fields = (
                ('chainId', big_endian_int),
                ('nonce', big_endian_int),
                ('gasPrice', big_endian_int),
                ('gasLimit', big_endian_int),
                ('to', binary),
                ('value', big_endian_int),
                ('data', binary),
                ('accessList', List([Binary[20, 20], List([Binary[32, 32]])])),
                ('signatureYParity', big_endian_int),
                ('signatureR', big_endian_int),
                ('signatureS', big_endian_int),
            )
        pre = SignedEIP2930Transaction.deserialize(rlp_encoded_tx[1:])

        return SignedTransaction(
            tx=Transaction(
                chain_id=pre.chainId,
                nonce=pre.nonce,
                max_priority_fee_per_gas=pre.gasPrice,
                max_fee_per_gas=pre.gasPrice,
                gas_limit=pre.gasLimit,
                to=Address(pre.to) if len(pre.to) > 0 else None,
                value=pre.value,
                data=pre.data,
                access_list=[AccessTuple(
                    address=access_tuple[0],
                    storage_keys=access_tuple[1],
                ) for access_tuple in pre.accessList],
            ),
            signature=ECDSASignature(
                y_parity=pre.signatureYParity != 0,
                r=pre.signatureR,
                s=pre.signatureS,
            ),
            hash_version=TX_HASH_VERSION_EIP2930,
        )

    if 0xc0 <= tx_type <= 0xfe:
        (nonce, gasprice, startgas, to, value, data, chainid, 0, 0)

        class SignedLegacyTransaction(rlp.Serializable):
            fields = (
                ('nonce', big_endian_int),
                ('gasprice', big_endian_int),
                ('startgas', big_endian_int),
                ('to', binary),
                ('value', big_endian_int),
                ('data', binary),
                ('v', big_endian_int),
                ('r', big_endian_int),
                ('s', big_endian_int),
            )
        pre = SignedLegacyTransaction.deserialize(rlp_encoded_tx)

        if pre.v not in (27, 28):
            return SignedTransaction(
                tx=Transaction(
                    chain_id=(pre.v - 35) >> 1,
                    nonce=pre.nonce,
                    max_priority_fee_per_gas=pre.gasprice,
                    max_fee_per_gas=pre.gasprice,
                    gas_limit=pre.startgas,
                    to=Address(pre.to) if len(pre.to) > 0 else None,
                    value=pre.value,
                    data=pre.data,
                ),
                signature=ECDSASignature(
                    y_parity=((pre.v - 35) & 0x1) != 0,
                    r=pre.r,
                    s=pre.s,
                ),
                hash_version=TX_HASH_VERSION_EIP155,
            )

        return SignedTransaction(
            tx=Transaction(
                nonce=pre.nonce,
                max_priority_fee_per_gas=pre.gasprice,
                max_fee_per_gas=pre.gasprice,
                gas_limit=pre.startgas,
                to=Address(pre.to) if len(pre.to) > 0 else None,
                value=pre.value,
                data=pre.data,
            ),
            signature=ECDSASignature(
                y_parity=((pre.v - 27) & 0x1) != 0,
                r=pre.r,
                s=pre.s,
            ),
            hash_version=TX_HASH_VERSION_LEGACY,
        )

    assert False
```

### Receipts

| Name | SSZ equivalent |
| - | - |
| `Topic` | `Bytes32` |

| Name | Value |
| - | - |
| [`BYTES_PER_LOGS_BLOOM`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/bellatrix/beacon-chain.md#execution) | `uint64(2**8)` (= 256) |
| `MAX_TOPICS_PER_LOG` | `uint64(2**24)` (= 16,777,216) |
| `MAX_LOG_DATA_SIZE` | `uint64(2**24)` (= 16,777,216) |
| `MAX_LOGS_PER_RECEIPT` | `uint64(2**24)` (= 16,777,216) |
| `MAX_RECEIPTS_PER_PAYLOAD` | `uint64(2**20)` (= 1,048,576) | Maximum amount of receipts allowed in each block |

```python
class Log(Container):
    address: Address
    topics: List[Topic, MAX_TOPICS_PER_LOG]
    data: ByteVector[MAX_LOG_DATA_SIZE]

class Receipt(Container):
    status: uint256  # EIP-658
    cumulative_transaction_gas_used: uint64
    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]
    logs: List[Log, MAX_LOGS_PER_RECEIPT]
```

The `blocks.receipts_root` is updated to a SSZ root. To compute the new `receipts_root`, the list of individual `Receipt` containers is represented as a SSZ `List`.

```python
block.receipts_root == hash_tree_root(List[Receipt, MAX_RECEIPTS_PER_PAYLOAD](
    receipt_0,
    receipt_1,
    receipt_2,
    ...
))
```

#### Consensus `ExecutionPayload` changes (Receipts)

The [consensus `ExecutionPayload`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/beacon-chain.md#executionpayload) and [consensus `ExecutionPayloadHeader`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/beacon-chain.md#executionpayloadheader) are updated to take account the new consensus `receipts_root` type.

```python
class ExecutionPayload(Container):
    ...
    receipts_root: Root  # Formerly, `Bytes32`
    ...


class ExecutionPayloadHeader(Container):
    ...
    receipts_root: Root  # Formerly, `Bytes32`
    ...
```

#### Execution block header changes (Receipts)

The execution block header's `receipts_root` is updated to match the consensus `ExecutionPayloadHeader`.

```python
block_header.receipts_root = block.receipts_root
```

### Withdrawals

#### Execution block changes (Withdrawals)

The individual [`Withdrawal` objects](./eip-4895.md) within the execution block's `withdrawals` list are now represented as SSZ `Container`s, matching the definition of the [consensus-specs `Withdrawal`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/capella/beacon-chain.md#withdrawal).

```python
class Withdrawal(Container):
    index: WithdrawalIndex
    validator_index: ValidatorIndex
    address: ExecutionAddress
    amount: Gwei
```

The `blocks.withdrawals` list remains RLP encoded:

```python
block.withdrawals = RLP([
    SSZ.encode(withdrawal_0),
    SSZ.encode(withdrawal_1),
    SSZ.encode(withdrawal_2),
    ...
])
```

#### Execution block header changes (Withdrawals)

The execution block header's `withdrawals_root` is updated to the `withdrawals_root` definition of the [consensus-specs `ExecutionPayloadHeader`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/beacon-chain.md#executionpayloadheader).

To compute the new `withdrawals_root`, the list of individual `Withdrawal` containers is represented as a SSZ `List`.

| Name | Value | Description |
| - | - | - |
| [`MAX_WITHDRAWALS_PER_PAYLOAD`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/capella/beacon-chain.md#execution) | `uint64(2**4)` (= 16) | Maximum amount of withdrawals allowed in each block |

```python
block_header.withdrawals_root == hash_tree_root(List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD](
    withdrawal_0,
    withdrawal_1,
    withdrawal_2,
    ...
))
```

### Deposits

Same as withdrawals, but ideally we have SSZ by the time deposits arrive.

Also, if more MPT are introduced by other EIP, same story.

## Rationale

### Why not multiple `Transaction` containers?

- **Superset of all existing transaction types:** The new `Transaction` container supports all existing transaction types. There is no new functionality that was previously disallowed. `Transaction` containers that are created from importing legacy transaction types use default values for fields that were added later.

- **Static merkle tree shape:** Compared to approaches based on SSZ `Union`, it is not necessary to branch on `hash_version` to determine the `GeneralizedIndex` for common fields. For example, a proof for a `Transaction`'s `value` field always has the exact same structure.

- **Shorter merkle proofs:** Compared to approaches based on SSZ `Onion` (merkleized as \[o]bject, serialized as u\[nion]), there is less nesting in the merkle tree. This makes proofs shorter (32 bytes per nesting level)

- **Easy to deprecate legacy transactions:** If a transaction type is no longer allowed, the tree shape remains static. In non-archive settings, the `upgrade_signed_rlp_transaction_to_ssz`, `get_transaction_id` and `get_transaction_sighash` functions can be adjusted to drop support for legacy transaction types.

- **Discourage legacy transaction types:** There are no block size benefits to use a legacy transaction type anymore. A penalty fee could be charged to new legacy transactions to promote timely upgrade to latest `Transaction` format.

- **Prior art:** Multiple modules of Ethereum already process common fields in a unified way. The consensus pytests use `is_post_fork` to conditionally enable logic. The execution JSON-RPC reports transaction fields under the same name regardless of type. The consensus light client protocol incorporates a very similar mechanism for upgrading consensus `ExecutionPayloadHeader` to later formats: [`get_transaction_sighash` equivalent](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/light-client/sync-protocol.md#modified-get_lc_execution_root) / [`upgrade_to_latest` equivalent](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/light-client/full-node.md#modified-block_to_light_client_header).

## Backwards Compatibility

Applications that solely rely on the legacy RLP encoding but do not rely on the MPT commitment in the block header can still be used through a re-encoding proxy.

Applications that rely on the replaced MPT root commitments in the block header can no longer find that information. Analysis is required whether affected applications have a migration path available. If major applications can't migrate, can keep the legacy MPT commitment in the header for now, and introduce the new SSZ trees next to them.

- **Transactions:** The txid is commonly used by block explorers. A helper function `get_transaction_id` is specified to replicate historic transaction IDs.

- **Receipts:** The concept of a "receipt ID" is not commonly used. There is also no JSON-RPC endpoint to obtain a receipts proof. It is not expected that major applications rely on the legacy MPT for receipts.

- **Withdrawals:** Withdrawals were introduced in Capella/Shanghai. It is not expected that major applications rely on the legacy MPT for withdrawals.

## Test Cases

### SSZ tests (Transactions)

```python
# Without EIP-4844 blobs
SSZ.encode(TransactionPayload(
    signed_tx=SignedTransaction(
        tx=Transaction(
            chain_id=uint64(0x07),
            nonce=uint64(0x0a),
            max_priority_fee_per_gas=uint256(0x0f),
            max_fee_per_gas=uint256(0x04),
            gas_limit=uint64(0x05),
            to=fromhex("0000000000000000000000000000000000000008"),
            value=uint256(0x06),
            data=[0x09],
            access_list=[
                AccessTuple(
                    address=fromhex("000000000000000000000000000000000000000b"),
                    storage_keys=[
                        fromhex("000000000000000000000000000000000000000000000000000000000000000c"),
                        fromhex("000000000000000000000000000000000000000000000000000000000000000d"),
                    ],
                ),
                AccessTuple(
                    address=fromhex("000000000000000000000000000000000000000e"),
                ),
            ],
        ),
        signature=ECDSASignature(
            y_parity=true,
            r=uint256(0x02),
            s=uint256(0x03),
        ),
        hash_version=TxHashVersion(0x04),
    ),
)) == fromhex(
    # offset(payload.signed_tx)
    "08000000" +
    # offset(payload.blob)  (unused)
    "63010000" +
    # offset(signed_tx.tx)
    "46000000" +
    # signed_tx.signature
    "01" +
    "0200000000000000000000000000000000000000000000000000000000000000" +
    "0300000000000000000000000000000000000000000000000000000000000000" +
    # signed_tx.hash_version
    "04" +
    # tx.chain_id
    "0700000000000000" +
    # tx.nonce
    "0a00000000000000" +
    # tx.max_priority_fee_per_gas
    "0f00000000000000000000000000000000000000000000000000000000000000" +
    # tx.max_fee_per_gas
    "0400000000000000000000000000000000000000000000000000000000000000" +
    # tx.gas_limit
    "0500000000000000" +
    # offset(tx.to)
    "88000000" +
    # tx.value
    "0600000000000000000000000000000000000000000000000000000000000000" +
    # offset(tx.data)
    "9c000000" +
    # offset(tx.access_list)
    "9d000000" +
    # offset(tx.blob_versioned_hashes)  (unused)
    "15010000" +
    # tx.to
    "0000000000000000000000000000000000000008" +
    # tx.data
    "09" +
    # offset(tx.access_tuple[0])
    "08000000" +
    # offset(tx.access_tuple[1])
    "60000000" +
    # access_tuple[0].address
    "000000000000000000000000000000000000000b" +
    # offset(access_tuple[0].storage_keys)
    "18000000" +
    # access_tuple[0].storage_keys[0]
    "000000000000000000000000000000000000000000000000000000000000000c" +
    # access_tuple[0].storage_keys[1]
    "000000000000000000000000000000000000000000000000000000000000000d" +
    # access_tuple[1].address
    "000000000000000000000000000000000000000e" +
    # offset(access_tuple[1].storage_keys)
    "18000000"
)

# With EIP-4844 blobs
SSZ.encode(TransactionPayload(
    signed_tx=SignedTransaction(
        tx=Transaction(
            chain_id=uint64(0x07),
            nonce=uint64(0x0a),
            max_priority_fee_per_gas=uint256(0x0f),
            max_fee_per_gas=uint256(0x04),
            gas_limit=uint64(0x05),
            to=fromhex("0000000000000000000000000000000000000008"),
            value=uint256(0x06),
            data=[0x09],
            access_list=[
                AccessTuple(
                    address=fromhex("000000000000000000000000000000000000000b"),
                    storage_keys=[
                        fromhex("000000000000000000000000000000000000000000000000000000000000000c"),
                        fromhex("000000000000000000000000000000000000000000000000000000000000000d"),
                    ],
                ),
                AccessTuple(
                    address=fromhex("000000000000000000000000000000000000000e"),
                ),
            ],
            blob_versioned_hashes=[
                fromhex("0000000000000000000000000000000000000000000000000000000000000010"),
            ],
        ),
        signature=ECDSASignature(
            y_parity=true,
            r=uint256(0x02),
            s=uint256(0x03),
        ),
        hash_version=TxHashVersion(0x04),
    ),
    blob=BlobTransactionExtension(
        blob_kzgs=[
            [0x11] + [0x00] * 47,
        ],
        blobs=[
            [[uint256(0x12)] + [uint256(0x00)] * 4_095],
        ],
        kzg_aggregated_proof=[0x13] + [0x00] * 47,
    )
)) == fromhex(
    # offset(payload.signed_tx)
    "08000000" +
    # offset(payload.blob)
    "83010000" +
    # offset(signed_tx.tx)
    "46000000" +
    # signed_tx.signature
    "01" +
    "0200000000000000000000000000000000000000000000000000000000000000" +
    "0300000000000000000000000000000000000000000000000000000000000000" +
    # signed_tx.hash_version
    "04" +
    # tx.chain_id
    "0700000000000000" +
    # tx.nonce
    "0a00000000000000" +
    # tx.max_priority_fee_per_gas
    "0f00000000000000000000000000000000000000000000000000000000000000" +
    # tx.max_fee_per_gas
    "0400000000000000000000000000000000000000000000000000000000000000" +
    # tx.gas_limit
    "0500000000000000" +
    # offset(tx.to)
    "88000000" +
    # tx.value
    "0600000000000000000000000000000000000000000000000000000000000000" +
    # offset(tx.data)
    "9c000000" +
    # offset(tx.access_list)
    "9d000000" +
    # offset(tx.blob_versioned_hashes)
    "15010000" +
    # tx.to
    "0000000000000000000000000000000000000008" +
    # tx.data
    "09" +
    # offset(tx.access_tuple[0])
    "08000000" +
    # offset(tx.access_tuple[1])
    "60000000" +
    # access_tuple[0].address
    "000000000000000000000000000000000000000b" +
    # offset(access_tuple[0].storage_keys)
    "18000000" +
    # access_tuple[0].storage_keys[0]
    "000000000000000000000000000000000000000000000000000000000000000c" +
    # access_tuple[0].storage_keys[1]
    "000000000000000000000000000000000000000000000000000000000000000d" +
    # access_tuple[1].address
    "000000000000000000000000000000000000000e" +
    # offset(access_tuple[1].storage_keys)
    "18000000" +
    # blob_versioned_hashes[0]
    "0000000000000000000000000000000000000000000000000000000000000010" +
    # offset(blob.blob_kzgs)
    "38000000" +
    # offset(blob.blobs)
    "68000000" +
    # blob.kzg_aggregated_proof
    "130000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
    # blob.blob_kzgs[0]
    "110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" +
    # blob.blobs[0]
    "1200000000000000000000000000000000000000000000000000000000000000" +
    "0000000000000000000000000000000000000000000000000000000000000000" +
    "0000000000000000000000000000000000000000000000000000000000000000" +
    ...
    "0000000000000000000000000000000000000000000000000000000000000000"
)
```

### SSZ tests (Receipts)

TBD

### SSZ tests (Withdrawals)

```python
withdrawal = Withdrawal(
    index=WithdrawalIndex(0x0123),
    validator_index=ValidatorIndex(0x4567),
    address=fromhex("0001020304050607080910111213141516171819"),
    amount=Gwei(0x89ab),
)

SSZ.encode(withdrawal) == fromhex(
    "2301000000000000" +
    "6745000000000000" +
    "0001020304050607080910111213141516171819" +
    "ab89000000000000"
)

hash_tree_root(withdrawal) == sha256(
    sha256(fromhex(
        "2301000000000000000000000000000000000000000000000000000000000000" +
        "6745000000000000000000000000000000000000000000000000000000000000")) +
    sha256(fromhex(
        "0001020304050607080910111213141516171819000000000000000000000000" +
        "ab89000000000000000000000000000000000000000000000000000000000000"))
) == fromhex("af8247942122ba68d69d2784dfd9994fa16681ff6feb2680d7922c61a899a20d")
```

```python
withdrawals = List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD](withdrawal_0, withdrawal_1, withdrawal_2)

block_header.withdrawals_root == hash_tree_root(withdrawals) == sha256(
    sha256(
        sha256(
            sha256(
                sha256(hash_tree_root(withdrawal_0) + hash_tree_root(withdrawal_1)) +
                sha256(hash_tree_root(withdrawal_2) + hash_tree_root(Withdrawal()))) +
            sha256(
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal())) +
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal())))) +
        sha256(
            sha256(
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal())) +
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal()))) +
            sha256(
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal())) +
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal()))))) +
    fromhex("0300000000000000000000000000000000000000000000000000000000000000")  # len
)
```

## Reference Implementation

TBD

## Security Considerations

None

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
