---
eip: 6404
title: SSZ transactions, receipts, and withdrawals
description: Migration of MPT commitments for transactions, receipts, and withdrawals to SSZ
author: Etan Kissling (@etan-status)
discussions-to: https://ethereum-magicians.org/t/eip-6404-ssz-transactions-receipts-and-withdrawals/12783
status: Draft
type: Standards Track
category: Core
created: 2023-01-30
requires: 155, 658, 1559, 2718, 2930, 4844, 4895
---

## Abstract

This EIP defines a migration process of existing Merkle-Patricia Trie (MPT) commitments for transactions, receipts, and withdrawals to SSZ.

## Motivation

While the consensus `ExecutionPayload` and the execution block structure map to each other conceptually, they are encoded differently. This EIP aims to align the encoding of their fields, taking advantage of the more modern SSZ format. This brings several advantages:

1. **Reducing complexity:** Merkle-Patricia Tries (MPT) are hard to work with. Replacing them with SSZ leaves only the state trie in the legacy MPT format.

2. **Better for smart contracts:** The SSZ format is optimized for production and verification of merkle proofs. It allows proving specific fields of containers and allows chunked processing, e.g., to support handling transactions that do not fit into calldata.

3. **Better for light clients:** Light clients with access to the consensus `ExecutionPayload` no longer need to obtain the matching execution block header to verify proofs rooted in `transactions_root` or `withdrawals_root`. Note that the `receipts_root` is currently represented as a MPT root across both execution and consensus.

4. **Reducing ambiguity:** The names `transactions_root` and `withdrawals_root` are currently used to refer to different roots. The execution block header refers to a MPT root, the consensus `ExecutionPayloadHeader` refers to a SSZ root.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### SSZ

#### `Optional[T]`

A new [SSZ type](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/ssz/simple-serialize.md) is introduced to represent `Optional[T]` values.

- If value is `None`, serialize as `[]`, and merkleize as `List[T, 1]` with length `0`.
- If value is not `None`, serialize as `T`, and merkleize as `List[T, 1]` with length `1`.
- Serialize `Optional[T]` as variable-size object (create offset-table entry in enclosing containers).

### Transactions

This design proposes a single normalized `Transaction` type. To include a transaction from an earlier type into a block, it needs to be migrated using `upgrade_signed_rlp_transaction_to_ssz`. For the purpose of signature validation, the originally signed transaction hash can be recomputed using `get_transaction_sighash`. For applications that need a perpetual identifier, `get_transaction_hash` can be used.

#### Hash version

For the purpose of transaction signature validation, it is necessary to recover the originally signed transaction hash. A new enumeration is introduced to indicate the original transaction hashing method. Note that this is different from the [EIP-2718](./eip-2718.md) transaction type, as legacy transactions may have been signed using different methods. The [EIP-2718](./eip-2718.md) transaction type is still used to encapsule different transaction formats on the network.

| Name | SSZ equivalent | Description |
| - | - | - |
| `TxHashVersion` | `uint8` | Original hashing method used for signing the transaction

| Name | Value | Description |
| - | - | - |
| `TX_HASH_VERSION_LEGACY` | `TxHashVersion(0x03)` | Replayable [`LegacyTransaction`](./eip-2718.md#transactions) |
| `TX_HASH_VERSION_EIP155` | `TxHashVersion(0x04)` | [EIP-155](./eip-155.md) `LegacyTransaction` |
| `TX_HASH_VERSION_EIP2930` | `TxHashVersion(0x01)` | [EIP-2930](./eip-2930.md#definitions) transaction |
| `TX_HASH_VERSION_EIP1559` | `TxHashVersion(0x02)` | [EIP-1559](./eip-1559.md#specification) transaction |
| `TX_HASH_VERSION_EIP4844` | `TxHashVersion(0x05)` | [EIP-4844](./eip-4844.md#parameters) transaction |

#### [EIP-2718](./eip-2718.md) transaction types

The values `0x00`, `0x03`, and `0x04` are marked as reserved [EIP-2718](./eip-2718.md) transaction types.

- `0x00` is reserved to avoid ambiguity with `type` in the execution JSON-RPC API, where `0x00` denotes a `LegacyTransaction` with chain ID encoded into the `v` value of the signature according to [EIP-155](./eip-155.md). Transactions of type `0x03` and `0x04` may be represented as `0x00` for backwards compatibility reasons.
- `0x03` and `0x04` are reserved to avoid ambiguity with `TX_HASH_VERSION_LEGACY` and `TX_HASH_VERSION_EIP155`.

#### Consensus `ExecutionPayload` changes (Transactions)

The existing [consensus `Transaction`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/bellatrix/beacon-chain.md#custom-types) container represents transactions as opaque, serialized [`EIP-2718`](./eip-2718.md) typed transactions. Once this EIP activates, this definition is replaced with a new `SignedTransaction` SSZ container.

| Name | SSZ equivalent |
| - | - |
| [`VersionedHash`](./eip-4844.md#type-aliases) | `Bytes32` |

| Name | Value |
| - | - |
| [`MAX_VERSIONED_HASHES_LIST_SIZE`](./eip-4844.md#parameters) | `uint64(2**24)` (= 16,777,216) |

```python
class AccessTuple(Container):
    address: Address
    storage_keys: List[Hash, MAX_ACCESS_LIST_STORAGE_KEYS]

class Transaction(Container):
    chain_id: uint64  # EIP-155
    nonce: uint64
    max_priority_fee_per_gas: uint256  # EIP-1559
    max_fee_per_gas: uint256  # aka `gasprice`
    gas_limit: uint64  # aka `startgas`
    to: Optional[Address]  # None: deploy contract
    value: uint256
    data: ByteList[MAX_CALLDATA_SIZE]
    access_list: List[AccessTuple, MAX_ACCESS_LIST_SIZE]  # EIP-2930
    max_fee_per_data_gas: uint256  # EIP-4844
    blob_versioned_hashes: List[VersionedHash, MAX_VERSIONED_HASHES_LIST_SIZE]  # EIP-4844

class ECDSASignature(Container):
    y_parity: boolean  # EIP-2930
    r: uint256
    s: uint256

class SignedTransaction(Container):
    tx: Transaction
    signature: ECDSASignature
    hash_version: TxHashVersion
```

The [consensus `ExecutionPayload`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/beacon-chain.md#executionpayload) is updated to use the new `SignedTransaction` SSZ container.

Furthermore, it is extended with a new `transaction_hashes_root` field to commit to the perpetual transaction hashes within the block.

| Name | Value | Description |
| - | - | - |
| [`MAX_TRANSACTIONS_PER_PAYLOAD`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/bellatrix/beacon-chain.md#execution) | `uint64(2**20)` (= 1,048,576) | Maximum amount of transactions allowed in each block |

```python
class ExecutionPayload(Container):
    ...
    transactions: List[SignedTransaction, MAX_TRANSACTIONS_PER_PAYLOAD]
    ...
    transaction_hashes_root: Root
```

To compute the new `transaction_hashes_root`, the list of the transaction hashes of individual `SignedTransaction` containers is represented as a SSZ `List`.

```python
payload.transaction_hashes_root = hash_tree_root(List[Hash32, MAX_TRANSACTIONS_PER_PAYLOAD](
    get_transaction_hash(transaction_0),
    get_transaction_hash(transaction_1),
    get_transaction_hash(transaction_2),
    ...
))
```

#### Consensus `ExecutionPayloadHeader` changes (Transactions)

The [consensus `ExecutionPayloadHeader`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/beacon-chain.md#executionpayloadheader) is updated for the new `ExecutionPayload.transactions` definition.

Likewise, it is extended with a new `transaction_hashes_root` field matching the new `ExecutionPayload.transaction_hashes_root` definition.

```python
payload_header.transactions_root = hash_tree_root(payload.transactions)
payload_header.transaction_hashes_root = payload.transaction_hashes_root
```

#### Execution block header changes (Transactions)

The [execution block header's `txs-root`](https://github.com/ethereum/devp2p/blob/bd17dac4228c69b6379644355f373669f74952cd/caps/eth.md#block-encoding-and-validity) is updated to match the consensus `ExecutionPayloadHeader.transactions_root`.

Furthermore, the execution block header is extended with a new `txs-hashes-root` field matching the `ExecutionPayloadHeader.transaction_hashes_root` definition.

#### Transaction helpers

```python
def get_transaction_sighash(tx: Transaction, hash_version: TxHashVersion) -> bytes:
    if hash_version == TX_HASH_VERSION_EIP4844:
        return keccak([0x05] + SSZ.encode(tx))

    assert tx.max_fee_per_data_gas == 0
    assert len(tx.blob_versioned_hashes) == 0

    if hash_version == TX_HASH_VERSION_EIP1559:
        schema = (
            (big_endian_int, tx.chain_id),
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_priority_fee_per_gas),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (List([Binary[20, 20], List([Binary[32, 32]])]), [
                (access_tuple.address, access_tuple.storage_keys) for access_tuple in tx.access_list
            ]),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak([0x02] + rlp.encode(values, sedes))

    assert tx.max_priority_fee_per_gas == tx.max_fee_per_gas

    if hash_version == TX_HASH_VERSION_EIP2930:
        schema = (
            (big_endian_int, tx.chain_id),
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (List([Binary[20, 20], List([Binary[32, 32]])]), [
                (access_tuple.address, access_tuple.storage_keys) for access_tuple in tx.access_list
            ]),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak([0x01] + rlp.encode(values, sedes))

    assert len(tx.access_list) == 0

    if hash_version == TX_HASH_VERSION_EIP155:
        schema = (
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (big_endian_int, tx.chain_id),
            (big_endian_int, 0),
            (big_endian_int, 0),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak(rlp.encode(values, sedes))

    assert tx.chain_id == 0

    if hash_version == TX_HASH_VERSION_LEGACY:
        schema = (
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return keccak(rlp.encode(values, sedes))

    assert False
```

```python
def encode_signed_transaction(signed_tx: SignedTransaction) -> bytes:
    hash_version = signed_tx.hash_version

    if hash_version == TX_HASH_VERSION_EIP4844:
        return [0x05] + SSZ.encode(signed_tx)

    assert tx.max_fee_per_data_gas == 0
    assert len(tx.blob_versioned_hashes) == 0

    if hash_version == TX_HASH_VERSION_EIP1559:
        schema = (
            (big_endian_int, tx.chain_id),
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_priority_fee_per_gas),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (List([Binary[20, 20], List([Binary[32, 32]])]), [
                (access_tuple.address, access_tuple.storage_keys) for access_tuple in tx.access_list
            ]),
            (big_endian_int, 1 if signed_tx.signature.y_parity else 0),
            (big_endian_int, signed_tx.signature.r),
            (big_endian_int, signed_tx.signature.s),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return [0x02] + rlp.encode(values, sedes)

    assert tx.max_priority_fee_per_gas == tx.max_fee_per_gas

    if hash_version == TX_HASH_VERSION_EIP2930:
        schema = (
            (big_endian_int, tx.chain_id),
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (List([Binary[20, 20], List([Binary[32, 32]])]), [
                (access_tuple.address, access_tuple.storage_keys) for access_tuple in tx.access_list
            ]),
            (big_endian_int, 1 if signed_tx.signature.y_parity else 0),
            (big_endian_int, signed_tx.signature.r),
            (big_endian_int, signed_tx.signature.s),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return [0x01] + rlp.encode(values, sedes)

    assert len(tx.access_list) == 0

    if hash_version == TX_HASH_VERSION_EIP155:
        schema = (
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (big_endian_int, (1 if signed_tx.signature.y_parity else 0) + tx.chain_id * 2 + 35),
            (big_endian_int, signed_tx.signature.r),
            (big_endian_int, signed_tx.signature.s),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return rlp.encode(values, sedes)

    assert tx.chain_id == 0

    if hash_version == TX_HASH_VERSION_LEGACY:
        schema = (
            (big_endian_int, tx.nonce),
            (big_endian_int, tx.max_fee_per_gas),
            (big_endian_int, tx.gas_limit),
            (binary, tx.to if tx.to is not None else []),
            (big_endian_int, tx.value),
            (binary, tx.data),
            (big_endian_int, (1 if signed_tx.signature.y_parity else 0) + 27),
            (big_endian_int, signed_tx.signature.r),
            (big_endian_int, signed_tx.signature.s),
        )
        sedes = List([schema for schema, _ in schema])
        values = [value for _, value in schema]

        return rlp.encode(values, sedes)

    assert False
```

```python
def get_transaction_hash(signed_tx: SignedTransaction) -> bytes:
    return keccak(encode_signed_transaction(signed_tx))
```

```python
def validate_transaction(signed_tx: SignedTransaction):
    hash_version = signed_tx.hash_version

    if hash_version == TX_HASH_VERSION_EIP4844:
        return
    assert signed_tx.tx.max_fee_per_data_gas == 0
    assert len(signed_tx.tx.blob_versioned_hashes) == 0

    if hash_version == TX_HASH_VERSION_EIP1559:
        return
    assert signed_tx.tx.max_priority_fee_per_gas == signed_tx.tx.max_fee_per_gas

    if hash_version == TX_HASH_VERSION_EIP2930:
        return
    assert len(signed_tx.tx.access_list) == 0

    if hash_version == TX_HASH_VERSION_EIP155:
        return
    assert signed_tx.tx.chain_id == 0

    if hash_Version == TX_HASH_VERSION_LEGACY:
        return
    assert False
```

```python
def decode_signed_transaction(encoded_signed_tx: bytes) -> SignedTransaction:
    tx_type = encoded_signed_tx[0]  # EIP-2718 transaction type

    if tx_type == 0x05:
        class BlobTransaction(Container):
            chain_id: uint256
            nonce: uint64
            max_priority_fee_per_gas: uint256
            max_fee_per_gas: uint256
            gas: uint64
            to: Union[None, Address] # Address = Bytes20
            value: uint256
            data: ByteList[MAX_CALLDATA_SIZE]
            access_list: List[AccessTuple, MAX_ACCESS_LIST_SIZE]
            max_fee_per_data_gas: uint256
            blob_versioned_hashes: List[VersionedHash, MAX_VERSIONED_HASHES_LIST_SIZE]

        class SignedBlobTransaction(Container):
            message: BlobTransaction
            signature: ECDSASignature

        pre = SSZ.decode(encoded_signed_tx[1:])

        return SignedTransaction(
            tx=Transaction(
                chain_id=pre.message.chain_id,
                nonce=premessage.nonce,
                max_priority_fee_per_gas=pre.message.max_priority_fee_per_gas,
                max_fee_per_gas=premessage.max_fee_per_gas,
                gas_limit=pre.message.gas,
                to=pre.message.to,
                value=pre.message.value,
                data=pre.message.data,
                access_list=pre.message.access_list,
                max_fee_per_data_gas=pre.message.max_fee_per_data_gas,
                blob_versioned_hashes=pre.message.blob_versioned_hashes,
            ),
            signature=pre.signature,
            hash_version=TX_HASH_VERSION_EIP4844,
        )

    if tx_type == 0x02:
        class SignedEIP1559Transaction(rlp.Serializable):
            fields = (
                ('chain_id', big_endian_int),
                ('nonce', big_endian_int),
                ('max_priority_fee_per_gas', big_endian_int),
                ('max_fee_per_gas', big_endian_int),
                ('gas_limit', big_endian_int),
                ('destination', binary),
                ('amount', big_endian_int),
                ('data', binary),
                ('access_list', List([Binary[20, 20], List([Binary[32, 32]])])),
                ('signature_y_parity', big_endian_int),
                ('signature_r', big_endian_int),
                ('signature_s', big_endian_int),
            )
        pre = SignedEIP1559Transaction.deserialize(encoded_signed_tx[1:])

        return SignedTransaction(
            tx=Transaction(
                chain_id=pre.chain_id,
                nonce=pre.nonce,
                max_priority_fee_per_gas=pre.max_priority_fee_per_gas,
                max_fee_per_gas=pre.max_fee_per_gas,
                gas_limit=pre.gas_limit,
                to=Address(pre.destination) if len(pre.destination) > 0 else None,
                value=pre.amount,
                data=pre.data,
                access_list=[AccessTuple(
                    address=access_tuple[0],
                    storage_keys=access_tuple[1],
                ) for access_tuple in pre.access_list],
            ),
            signature=ECDSASignature(
                y_parity=pre.signature_y_parity != 0,
                r=pre.signature_r,
                s=pre.signature_s,
            ),
            hash_version=TX_HASH_VERSION_EIP1559,
        )

    if tx_type == 0x01:
        class SignedEIP2930Transaction(rlp.Serializable):
            fields = (
                ('chainId', big_endian_int),
                ('nonce', big_endian_int),
                ('gasPrice', big_endian_int),
                ('gasLimit', big_endian_int),
                ('to', binary),
                ('value', big_endian_int),
                ('data', binary),
                ('accessList', List([Binary[20, 20], List([Binary[32, 32]])])),
                ('signatureYParity', big_endian_int),
                ('signatureR', big_endian_int),
                ('signatureS', big_endian_int),
            )
        pre = SignedEIP2930Transaction.deserialize(encoded_signed_tx[1:])

        return SignedTransaction(
            tx=Transaction(
                chain_id=pre.chainId,
                nonce=pre.nonce,
                max_priority_fee_per_gas=pre.gasPrice,
                max_fee_per_gas=pre.gasPrice,
                gas_limit=pre.gasLimit,
                to=Address(pre.to) if len(pre.to) > 0 else None,
                value=pre.value,
                data=pre.data,
                access_list=[AccessTuple(
                    address=access_tuple[0],
                    storage_keys=access_tuple[1],
                ) for access_tuple in pre.accessList],
            ),
            signature=ECDSASignature(
                y_parity=pre.signatureYParity != 0,
                r=pre.signatureR,
                s=pre.signatureS,
            ),
            hash_version=TX_HASH_VERSION_EIP2930,
        )

    if 0xc0 <= tx_type <= 0xfe:
        class SignedLegacyTransaction(rlp.Serializable):
            fields = (
                ('nonce', big_endian_int),
                ('gasprice', big_endian_int),
                ('startgas', big_endian_int),
                ('to', binary),
                ('value', big_endian_int),
                ('data', binary),
                ('v', big_endian_int),
                ('r', big_endian_int),
                ('s', big_endian_int),
            )
        pre = SignedLegacyTransaction.deserialize(encoded_signed_tx)

        if pre.v not in (27, 28):
            return SignedTransaction(
                tx=Transaction(
                    chain_id=(pre.v - 35) >> 1,
                    nonce=pre.nonce,
                    max_priority_fee_per_gas=pre.gasprice,
                    max_fee_per_gas=pre.gasprice,
                    gas_limit=pre.startgas,
                    to=Address(pre.to) if len(pre.to) > 0 else None,
                    value=pre.value,
                    data=pre.data,
                ),
                signature=ECDSASignature(
                    y_parity=((pre.v - 35) & 0x1) != 0,
                    r=pre.r,
                    s=pre.s,
                ),
                hash_version=TX_HASH_VERSION_EIP155,
            )

        return SignedTransaction(
            tx=Transaction(
                nonce=pre.nonce,
                max_priority_fee_per_gas=pre.gasprice,
                max_fee_per_gas=pre.gasprice,
                gas_limit=pre.startgas,
                to=Address(pre.to) if len(pre.to) > 0 else None,
                value=pre.value,
                data=pre.data,
            ),
            signature=ECDSASignature(
                y_parity=((pre.v - 27) & 0x1) != 0,
                r=pre.r,
                s=pre.s,
            ),
            hash_version=TX_HASH_VERSION_LEGACY,
        )

    assert False
```

### Receipts

Each receipt is linked to the transaction at the same sequential index within a block. The underlying [EIP-2718](./eip-2718.md) transaction type can be inferred from the corresponding transaction.

#### Consensus `ExecutionPayload` changes (Receipts)

A new `Receipt` SSZ container is introduced to represent receipts.

| Name | SSZ equivalent |
| - | - |
| `Topic` | `Bytes32` |

| Name | Value |
| - | - |
| [`BYTES_PER_LOGS_BLOOM`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/bellatrix/beacon-chain.md#execution) | `uint64(2**8)` (= 256) |
| `MAX_TOPICS_PER_LOG` | `uint64(2**24)` (= 16,777,216) |
| `MAX_LOG_DATA_SIZE` | `uint64(2**24)` (= 16,777,216) |
| `MAX_LOGS_PER_RECEIPT` | `uint64(2**24)` (= 16,777,216) |
| `MAX_RECEIPTS_PER_PAYLOAD` | `uint64(2**20)` (= 1,048,576) | Maximum amount of receipts allowed in each block |

```python
class ReceiptLog(Container):
    address: Address
    topics: List[Topic, MAX_TOPICS_PER_LOG]
    data: ByteVector[MAX_LOG_DATA_SIZE]

class Receipt(Container):
    status: uint256  # EIP-658
    cumulative_transaction_gas_used: uint64
    logs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]
    logs: List[ReceiptLog, MAX_LOGS_PER_RECEIPT]
```

The [consensus `ExecutionPayload`'s `receipts_root`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/beacon-chain.md#executionpayload) now refers to an SSZ [`Root`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/phase0/beacon-chain.md#custom-types) instead of an MPT [`Hash32`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/phase0/beacon-chain.md#custom-types).

```python
class ExecutionPayload(Container):
    ...
    receipts_root: Root
    ...
```

To compute the new `receipts_root`, the list of individual `Receipt` containers is represented as a SSZ `List`.

```python
payload.receipts_root = hash_tree_root(List[Receipt, MAX_TRANSACTIONS_PER_PAYLOAD](
    receipt_0,
    receipt_1,
    receipt_2,
    ...
))
```

#### Consensus `ExecutionPayloadHeader` changes (Receipts)

The [consensus `ExecutionPayloadHeader`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/beacon-chain.md#executionpayloadheader) is updated for the new `ExecutionPayload.receipts_root` definition.

```python
class ExecutionPayloadHeader(Container):
    ...
    receipts_root: Root
    ...
```

```python
payload_header.receipts_root = payload.receipts_root
```

#### Execution block header changes (Receipts)

The [execution block header's `receipts-root`](https://github.com/ethereum/devp2p/blob/bd17dac4228c69b6379644355f373669f74952cd/caps/eth.md#block-encoding-and-validity) is updated to match the consensus `ExecutionPayloadHeader.receipts_root`.

#### Receipt helpers

```python
def encode_receipt(receipt: Receipt, hash_version: TxHashVersion) -> bytes:
    schema = (
        (big_endian_int, receipt.status),
        (big_endian_int, receipt.cumulative_transaction_gas_used),
        (Binary[256, 256], receipt.logs_bloom),
        (List([Binary[20, 20], List([Binary[32, 32]]), Binary[0, uint64(2**24)]]), [
            (log.address, log.topics, log.data) for log in receipt.logs
        ]),
    )
    sedes = List([schema for schema, _ in schema])
    values = [value for _, value in schema]
    encoded = rlp.encode(values, sedes)

    if hash_version == TX_HASH_VERSION_EIP4844:
        return [0x05] + encoded
    if hash_version == TX_HASH_VERSION_EIP1559:
        return [0x02] + encoded
    if hash_version == TX_HASH_VERSION_EIP2930:
        return [0x01] + encoded
    if hash_version == TX_HASH_VERSION_EIP155:
        return encoded
    if hash_Version == TX_HASH_VERSION_LEGACY:
        return encoded
    assert False
```

```python
def decode_receipt(encoded_receipt: bytes) -> Receipt:
    tx_type = encoded_receipt[0]

    class RLPReceipt(rlp.Serializable):
        fields = (
            ('status', big_endian_int),
            ('cumulative_transaction_gas_used', big_endian_int),
            ('logs_bloom', Binary[256, 256]),
            ('logs', List([Binary[20, 20], List([Binary[32, 32]]), Binary[0, uint64(2**24)]])),
        )
    if tx_type == 0x05:
        pre = RLPReceipt.deserialize(encoded_receipt[1:])
    elif tx_type == 0x02:
        pre = RLPReceipt.deserialize(encoded_receipt[1:])
    elif tx_type == 0x01:
        pre = RLPReceipt.deserialize(encoded_receipt[1:])
    elif 0xc0 <= tx_type <= 0xfe:
        pre = RLPReceipt.deserialize(encoded_receipt)
    else:
        assert False

    return Receipt(
        status=pre.status,
        cumulative_transaction_gas_used=pre.cumulative_transaction_gas_used,
        logs_bloom=pre.logs_bloom,
        logs=[ReceiptLog(
            address=log[0],
            topics=log[1],
            data=log[2],
        ) for log in pre.logs],
    )
```

### Withdrawals

#### Execution block header changes (Withdrawals)

The existing consensus [`Withdrawal`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/capella/beacon-chain.md#withdrawal) SSZ container is used to represent withdrawals.

```python
class Withdrawal(Container):
    index: WithdrawalIndex
    validator_index: ValidatorIndex
    address: ExecutionAddress
    amount: Gwei
```

The execution block header's `withdrawals-root` is updated to match the consensus [`ExecutionPayloadHeader.withdrawals_root`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/beacon-chain.md#executionpayloadheader).

| Name | Value | Description |
| - | - | - |
| [`MAX_WITHDRAWALS_PER_PAYLOAD`](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/capella/beacon-chain.md#execution) | `uint64(2**4)` (= 16) | Maximum amount of withdrawals allowed in each block |

```python
block_header.withdrawals_root == hash_tree_root(List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD](
    withdrawal_0,
    withdrawal_1,
    withdrawal_2,
    ...
))
```

#### Withdrawal helpers

```python
def encode_withdrawal(withdrawal: Withdrawal) -> bytes:
    schema = (
        (big_endian_int, withdrawal.index),
        (big_endian_int, withdrawal.validator_index),
        (Binary[20, 20], withdrawal.address),
        (big_endian_int, withdrawal.amount),
    )
    sedes = List([schema for schema, _ in schema])
    values = [value for _, value in schema]
    return rlp.encode(values, sedes)
```

```python
def decode_withdrawal(encoded_withdrawal: bytes) -> Withdrawal:
    class RLPWithdrawal(rlp.Serializable):
        fields = (
            ('index', bid_endian_int),
            ('validator_index', big_endian_int),
            ('address', Binary[20, 20]),
            ('amount', big_endian_int),
        )
    pre = RLPWithdrawal.deserialize(encoded_withdrawal)

    return Withdrawal(
        index=pre.index,
        validator_index=pre.validator_index,
        address=pre.address,
        amount=pre.amount,
    )
```

## Rationale

### Why not multiple `Transaction` containers?

- **Superset of all existing transaction types:** The new `Transaction` container supports all existing transaction types. There is no new functionality that was previously disallowed. `Transaction` containers that are created from importing legacy transaction types use default values for fields that were added later.

- **Static merkle tree shape:** Compared to approaches based on SSZ `Union`, it is not necessary to branch on `hash_version` to determine the `GeneralizedIndex` for common fields. For example, a proof for a `Transaction`'s `value` field always has the exact same structure.

- **Shorter merkle proofs:** Compared to approaches based on SSZ `Onion` (merkleized as \[o]bject, serialized as u\[nion]), there is less nesting in the merkle tree. This makes proofs shorter (32 bytes per nesting level)

- **Easy to deprecate legacy transactions:** If a transaction type is no longer allowed, the tree shape remains static. In non-archive settings, the `upgrade_signed_rlp_transaction_to_ssz`, `get_transaction_hash` and `get_transaction_sighash` functions can be adjusted to drop support for legacy transaction types.

- **Discourage legacy transaction types:** There are no block size benefits to use a legacy transaction type anymore. A penalty fee could be charged to new legacy transactions to promote timely upgrade to latest `Transaction` format.

- **Prior art:** Multiple modules of Ethereum already process common fields in a unified way. The consensus pytests use `is_post_fork` to conditionally enable logic. The execution JSON-RPC reports transaction fields under the same name regardless of type. The consensus light client protocol incorporates a very similar mechanism for upgrading consensus `ExecutionPayloadHeader` to later formats: [`get_transaction_sighash` equivalent](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/light-client/sync-protocol.md#modified-get_lc_execution_root) / [`upgrade_to_latest` equivalent](https://github.com/ethereum/consensus-specs/blob/67c2f9ee9eb562f7cc02b2ff90d92c56137944e1/specs/eip4844/light-client/full-node.md#modified-block_to_light_client_header).

### Why the need for `transaction_hashes_root`?

The perpetual transaction hash is used by many applications to uniquely identify a transaction. The `transaction_hashes_root` allows smart contracts to verify proofs about objects that are linked to the perpetual transaction hash, without having to re-hash the entire transaction according to the original `TxHashVersion`.

For example, when requesting the `Receipt` for a given transaction hash, the response could include (1) the `Receipt` itself, (2) the index of the `Receipt` within `payload.receipts`, (3) the SSZ merkle proof that the `Receipt` is indeed located at that index, (4) the SSZ merkle proof that the transaction with the same index actually has the requested perpetual transaction hash.

## Backwards Compatibility

Applications that solely rely on the legacy RLP encoding but do not rely on the MPT commitment in the block header can still be used through a re-encoding proxy.

Applications that rely on the replaced MPT root commitments in the block header can no longer find that information. Analysis is required whether affected applications have a migration path available. If major applications can't migrate, can keep the legacy MPT commitment in the header for now, and introduce the new SSZ trees next to them.

- **Transactions:** The transaction hash is commonly used by block explorers. A helper function `get_transaction_hash` is specified to replicate historic transaction IDs.

- **Receipts:** The concept of a "receipt ID" is not commonly used. There is also no JSON-RPC endpoint to obtain a receipts proof. It is not expected that major applications rely on the legacy MPT for receipts.

- **Withdrawals:** Withdrawals were introduced in Capella/Shanghai. It is not expected that major applications rely on the legacy MPT for withdrawals.

## Test Cases

### SSZ tests (Transactions)

```python
SSZ.encode(TransactionPayload(
    signed_tx=SignedTransaction(
        tx=Transaction(
            chain_id=uint64(0x07),
            nonce=uint64(0x0a),
            max_priority_fee_per_gas=uint256(0x0f),
            max_fee_per_gas=uint256(0x04),
            gas_limit=uint64(0x05),
            to=fromhex("0000000000000000000000000000000000000008"),
            value=uint256(0x06),
            data=[0x09],
            access_list=[
                AccessTuple(
                    address=fromhex("000000000000000000000000000000000000000b"),
                    storage_keys=[
                        fromhex("000000000000000000000000000000000000000000000000000000000000000c"),
                        fromhex("000000000000000000000000000000000000000000000000000000000000000d"),
                    ],
                ),
                AccessTuple(
                    address=fromhex("000000000000000000000000000000000000000e"),
                ),
            ],
        ),
        signature=ECDSASignature(
            y_parity=true,
            r=uint256(0x02),
            s=uint256(0x03),
        ),
        hash_version=TxHashVersion(0x04),
    ),
)) == fromhex(
    # offset(signed_tx.tx)
    "46000000" +
    # signed_tx.signature
    "01" +
    "0200000000000000000000000000000000000000000000000000000000000000" +
    "0300000000000000000000000000000000000000000000000000000000000000" +
    # signed_tx.hash_version
    "04" +
    # tx.chain_id
    "0700000000000000" +
    # tx.nonce
    "0a00000000000000" +
    # tx.max_priority_fee_per_gas
    "0f00000000000000000000000000000000000000000000000000000000000000" +
    # tx.max_fee_per_gas
    "0400000000000000000000000000000000000000000000000000000000000000" +
    # tx.gas_limit
    "0500000000000000" +
    # offset(tx.to)
    "a8000000" +
    # tx.value
    "0600000000000000000000000000000000000000000000000000000000000000" +
    # offset(tx.data)
    "bc000000" +
    # offset(tx.access_list)
    "bd000000" +
    # tx.max_fee_per_data_gas
    "0000000000000000000000000000000000000000000000000000000000000000" +
    # offset(tx.blob_versioned_hashes)
    "35010000" +
    # tx.to
    "0000000000000000000000000000000000000008" +
    # tx.data
    "09" +
    # offset(tx.access_tuple[0])
    "08000000" +
    # offset(tx.access_tuple[1])
    "60000000" +
    # access_tuple[0].address
    "000000000000000000000000000000000000000b" +
    # offset(access_tuple[0].storage_keys)
    "18000000" +
    # access_tuple[0].storage_keys[0]
    "000000000000000000000000000000000000000000000000000000000000000c" +
    # access_tuple[0].storage_keys[1]
    "000000000000000000000000000000000000000000000000000000000000000d" +
    # access_tuple[1].address
    "000000000000000000000000000000000000000e" +
    # offset(access_tuple[1].storage_keys)
    "18000000"
)
```

### SSZ tests (Receipts)

TBD

### SSZ tests (Withdrawals)

```python
withdrawal = Withdrawal(
    index=WithdrawalIndex(0x0123),
    validator_index=ValidatorIndex(0x4567),
    address=fromhex("0001020304050607080910111213141516171819"),
    amount=Gwei(0x89ab),
)

SSZ.encode(withdrawal) == fromhex(
    "2301000000000000" +
    "6745000000000000" +
    "0001020304050607080910111213141516171819" +
    "ab89000000000000"
)

hash_tree_root(withdrawal) == sha256(
    sha256(fromhex(
        "2301000000000000000000000000000000000000000000000000000000000000" +
        "6745000000000000000000000000000000000000000000000000000000000000")) +
    sha256(fromhex(
        "0001020304050607080910111213141516171819000000000000000000000000" +
        "ab89000000000000000000000000000000000000000000000000000000000000"))
) == fromhex("af8247942122ba68d69d2784dfd9994fa16681ff6feb2680d7922c61a899a20d")
```

```python
withdrawals = List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD](withdrawal_0, withdrawal_1, withdrawal_2)

block_header.withdrawals_root == hash_tree_root(withdrawals) == sha256(
    sha256(
        sha256(
            sha256(
                sha256(hash_tree_root(withdrawal_0) + hash_tree_root(withdrawal_1)) +
                sha256(hash_tree_root(withdrawal_2) + hash_tree_root(Withdrawal()))) +
            sha256(
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal())) +
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal())))) +
        sha256(
            sha256(
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal())) +
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal()))) +
            sha256(
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal())) +
                sha256(hash_tree_root(Withdrawal()) + hash_tree_root(Withdrawal()))))) +
    fromhex("0300000000000000000000000000000000000000000000000000000000000000")  # len
)
```

## Reference Implementation

TBD

## Security Considerations

None

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
