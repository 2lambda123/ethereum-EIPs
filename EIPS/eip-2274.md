---
eip: 2274
title: Multiple addresses range for Precompiled contracts
author: Antoine Rondelet (@AntoineRondelet)
discussions-to: https://ethereum-magicians.org/t/eip-2274-multiple-addresses-range-for-precompiled-contracts/3652
status: Draft
type: Standards Track
category: Core
requires: 1109
created: 2019-09-12
---

<!--You can leave these HTML comments in your merged EIP and delete the visible duplicate text guides, they will not appear and may be helpful to refer to if you edit it again. This is the suggested template for new EIPs. Note that an EIP number will be assigned by an editor. When opening a pull request to submit your EIP, please use an abbreviated title in the filename, `eip-draft_title_abbrev.md`. The title should be 44 characters or less.-->

## Simple Summary
<!--"If you can't explain it simply, you don't understand it well enough." Provide a simplified and layman-accessible explanation of the EIP.-->
Introduces a `vmID` number to differentiate between "mainnet precompiled contracts" and "fork specific precompiled". This allows forks to extend mainnet's execution environment at will.

## Abstract
<!--A short (~200 word) description of the technical issue being addressed.-->
This EIP follows and extends [eip-1109](https://eips.ethereum.org/EIPS/eip-1109) and aims to introduce a `vmID` argument to the `PRECOMPILEDCALL` OPCODE. Adding such argument would enable forks to be able to define their custom precompiled contracts and extend the execution environment, while keeping it straightforward to pull new changes made on mainnet and merge them. This would help keeping the various fork clients in sync with the latest development.

## Motivation
<!--The motivation is critical for EIPs that want to change the Ethereum protocol. It should clearly explain why the existing protocol specification is inadequate to address the problem that the EIP solves. EIP submissions without sufficient motivation may be rejected outright.-->
As of today, the only way for a fork of Ethereum to define custom precompiled contracts, is to follow the standard approach and introduce a new map between address and precompiled contract like done [here](https://github.com/ethereum/go-ethereum/blob/master/core/vm/contracts.go#L51-L62) and [here](https://github.com/ethereum/go-ethereum/blob/master/core/vm/contracts.go#L64-L76) for instance.

*Note:* While using consecutive addresses to declare new precompiled contracts is not required, it seems to be a good practice to avoid hazardous address collisions with user newly generated addresses (if one randomly generates a new address to be used for newly introduced precompiled, the address space will be "polluted" and checks will likely be needed to be added to make sure that no user can create a new externaly owned account for this address. Moreover, we believe that being consistent and declaring precompiled addresses hences developer experience and makes it easier to reason about the code).

It is important to notice though, that declaring precompiled addresses consecutively presents some drawbacks. In fact, any new precompiled added to Ethereum will lead to an address collision for the fork willing to fetch new updates from mainnet clients. Following the mapping of precompiled contracts of [istanbul](https://github.com/ethereum/go-ethereum/blob/master/core/vm/contracts.go#L64-L76), the only way for a fork client - having defined, say 4 new precompiled after `blake2F` (address `0x09`) - to merge mainnet new precompiled contracts is to either:
1. Add mainnet precompiled them at address `13` onward, but then custom precompiled contracts get mixed with the ones of "mainnet" and we see that repeating this process a few times can lead to some chaos in the precompiled addressing. Here again, we believe that consistency in address management is important from a design and development perspective.
2. Or, follow the addressing used on mainnet, and then add the mainnet precompiled after address `9`, and move the custom precompiled after the newly added precompiled. However, doing so would break backward compatibility and would break all deployed smart contracts calling the fork's precompiled. This is not desired at all.

While a similar approach to [eip-1352](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1352.md), which proposed to specify restricted address range for precompiled contracts, could be employed to solve the problem aforementioned, we propose here to extend [eip-1109](https://eips.ethereum.org/EIPS/eip-1109) by adding an extra argument - `vmID` - to the `PRECOMPILEDCALL` opcode. This extra argument will enable to execute the precompiled at the given address as implemented on the fork client, and thus would allow to have an EVM with different set of precompiled contracts: the ones from mainnet, and the ones from the fork.

## Specification
<!--The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Ethereum platforms (go-ethereum, parity, cpp-ethereum, ethereumj, ethereumjs, and [others](https://github.com/ethereum/wiki/wiki/Clients)).-->
This proposal is an extension of [eip-1109](https://eips.ethereum.org/EIPS/eip-1109). As a consequence, we follow the specification introduced in this initial EIP, and will only list changes we would like to add.

As opposed to EIP-1109, the OPCODE `PRECOMPILEDCALL` takes 6 words from the stack as input.
The first input stack value is `mu_s[0] = The vmID specifying in which precompiled address range is the called precompiled defined`.
The value of `vmID` is `0` for mainnet, and can be set to be `=/= 0` for any fork.

The remaining input stack values follow [eip-1109](https://eips.ethereum.org/EIPS/eip-1109).

Like in [eip-1109](https://eips.ethereum.org/EIPS/eip-1109), a `PRECOMPILEDCALL` to a regular address or regular smart contract, is considered as a call to an "undefined smart contract", so the VM MUST not execute it and the opcode must return `0x0`.

## Rationale
<!--The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages. The rationale may also provide evidence of consensus within the community, and should discuss important objections or concerns raised during discussion.-->
A few proposals inspired this one. First, [eip-1352](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1352.md) proposes to specify an Ethereum address range occupied by precompiles. As such, we see that a similar approach could be taken to split the address range dedicated to precompiled contracts into a set of addresses to be used for mainnet precompiled contracts and a set of addresses for forks precompiled. This solution has the advantage to be trivial to implement. Nevertheless, it fails to provide a nice level of abstraction, which is what this proposal aims to address. Likewise, [eip-1109](https://eips.ethereum.org/EIPS/eip-1109) and [eip-1702](https://eips.ethereum.org/EIPS/eip-1702) inspired this proposal.

## Backwards Compatibility
<!--All EIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The EIP must explain how the author proposes to deal with these incompatibilities. EIP submissions without a sufficient backwards compatibility treatise may be rejected outright.-->
This EIP requires a hardfork to be able to extend the set of OPCODES. However, it is backward compatible since no currently deployed smart contracts will be broken if this EIP was to be introduced and implemented.

## Test Cases
<!--Test cases for an implementation are mandatory for EIPs that are affecting consensus changes. Other EIPs can choose to include links to test cases if applicable.-->
Same as in [eip-1109](https://eips.ethereum.org/EIPS/eip-1109), with:
- Call to defined and undefined precompiled for different `vmID` values.

## Implementation
<!--The implementations must be completed before any EIP is given status "Final", but it need not be completed before the EIP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of "rough consensus and running code" is still useful when it comes to resolving many discussions of API details.-->
In order to support this new OPCODE and **illustrate** the point made above, we propose an **incomplete and broken** implementation below:
- In `core/vm/instructions.go` (see: [here](https://github.com/ethereum/go-ethereum/blob/master/core/vm/instructions.go)), add a function for the new OPCODE: [See here for the proposed (broken) code](https://github.com/AntoineRondelet/go-ethereum/blob/eip-2274-implementation/core/vm/instructions.go#L780-L805)

- In `core/vm/evm.go` (see: [here](https://github.com/ethereum/go-ethereum/blob/master/core/vm/evm.go)) add: [See here](https://github.com/AntoineRondelet/go-ethereum/blob/eip-2274-implementation/core/vm/evm.go#L279-L305) and [here](https://github.com/AntoineRondelet/go-ethereum/blob/eip-2274-implementation/core/vm/evm.go#L73-L94) for some broken implementation of this EIP.

- Finally, we'd need to introduce a file `custom_contracts.go` in the [package "vm"](https://github.com/ethereum/go-ethereum/tree/master/core/vm), in which custom precompiled are implemented and where the `PrecompiledContractsCustomToTheFork` slice is defined pointing to the fork's precompiled addresses. This file would contain an empty slice `PrecompiledContractsCustomToTheFork` on mainnet, which could be populated by fork developers as they need to add custom and efficient instructions to their EVM. Moreover, this file would need to define the function `RunCustomPrecompiledContract` that will run the "custom precompiled contracts". [Here is an example implementation](https://github.com/AntoineRondelet/go-ethereum/blob/eip-2274-implementation/core/vm/custom_contracts.go).

**Important Note**: The code proposed above has only been added as an illustration matter. It has not been tested, and is broken. It only aims to illustrate the proposal and get some idea on the work required to implement this EIP.

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
